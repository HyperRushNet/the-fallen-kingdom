<!-- The Fallen Kingdom - v2.4.1 - Massive performance update -->
<!----------------------------------------->
<!-- Copyright, HyperRush Network - 2025 -->
<!-- Do not use this code in any way without the permission of HyperRushNet -->
<!-- hyperrushnetwork@gmail.com -->
<!--------------------->
<!-- Game code START -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>v2.4.1 - The Fallen Kingdom</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=MedievalSharp&display=swap" rel="stylesheet">
<style>
  body{margin:0;overflow:hidden;font-family:'MedievalSharp',cursive;color:#e6d7b7;background:#091f3b}
  #background{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;background-color:black;opacity:0}
  canvas{display:block;background:transparent;position:relative;z-index:10}
  #hud{position:fixed;top:10px;left:10px;background:rgba(20,15,10,0.8);padding:10px;border-radius:8px;border:1px solid #d4af37;font-size:12px;z-index:100;min-width:150px}
  .ability{margin-bottom:8px;display:flex;align-items:center;gap:5px}
  .ability-icon{width:16px;height:16px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:10px;color:white;background:#2a2a2a;border:1px solid #d4af37}
  .ready{color:#90ee90}
  .cooldown{color:#ff6b6b}
  .slope-info{background:rgba(0,0,0,0.3);padding:3px 6px;border-radius:3px;margin-top:5px;font-size:11px}
  .coords{font-family:'Courier New',monospace;background:rgba(0,0,0,0.4);padding:3px;border-radius:3px;margin-top:5px;font-size:11px}
  .health-container{margin-top:5px;display:flex;align-items:center;gap:5px;font-size:11px}
  .health-bar{flex:1;height:6px;background:rgba(0,0,0,0.5);border-radius:3px;overflow:hidden;border:1px solid #d4af37}
  .health-fill{height:100%;background:linear-gradient(90deg,#ff0000,#00ff00);transition:width 0.3s ease;border-radius:2px}
  #loadingScreen{position:fixed;top:0;left:0;width:100%;height:100%;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:1000}
  #loadingBarContainer{width:min(400px,90vw);height:20px;background:#333;border:1px solid #d4af37;border-radius:10px;overflow:hidden;margin:0 10px}
  #loadingBar{width:0;height:100%;background:#d4af37;transition:width 0.3s ease;border-radius:8px}
  #loadingText{color:#e6d7b7;margin-top:10px;font-size:clamp(14px,4vw,16px);text-shadow:0 0 5px #d4af37;font-family:'Cinzel',serif}
  .title{font-size:clamp(24px,8vw,40px);color:#d4af37;margin-bottom:10px;text-shadow:1px 1px 2px rgba(0,0,0,0.8);font-family:'Cinzel',serif}
  #startButton{margin-top:15px;padding:clamp(8px,2vw,10px) clamp(16px,4vw,20px);background:#d4af37;color:#1a0f0a;border:none;border-radius:25px;font-size:clamp(14px,4vw,16px);cursor:pointer;display:none;font-family:'Cinzel',serif;font-weight:600;transition:background 0.3s ease;touch-action:manipulation}
  #fpsMeter{position:fixed;top:10px;right:10px;background:rgba(20,15,10,0.8);color:#90ee90;padding:5px 10px;border-radius:5px;font-family:'Courier New',monospace;z-index:101;border:1px solid #90ee90;font-size:clamp(10px,3vw,12px)}
  @media (max-width:768px){
    #hud{top:5px;left:5px;padding:8px;font-size:clamp(10px,3vw,12px);min-width:auto;width:calc(100vw-10px);max-width:300px;border-radius:6px}
    .ability{flex-wrap:wrap;gap:3px}
    .ability-icon{width:14px;height:14px;font-size:9px}
    .slope-info,.coords{font-size:clamp(9px,2.5vw,11px);padding:2px 4px}
    .health-container{font-size:clamp(9px,2.5vw,11px);gap:3px}
    .health-bar{height:5px}
    #fpsMeter{top:5px;right:5px;padding:4px 8px;font-size:clamp(9px,2.5vw,12px)}
    .title{margin-bottom:5px}
    #loadingBarContainer{margin:5px 10px}
    #startButton{margin-top:10px}
  }
  #lightCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 15;
    pointer-events: none;
    mix-blend-mode: multiply;
  }
</style>
</head>
<body>
<div id="loadingScreen">
  <div class="title">The Fallen Kingdom</div>
  <div id="loadingBarContainer"><div id="loadingBar"></div></div>
  <div id="loadingText">Loading... 0%</div>
  <button id="startButton">Start Game</button>
</div>
<div id="background"></div>
<div id="hud">
  <div class="ability" id="dash">
    <div class="ability-icon">‚ö°</div>
    <span>Dash (Shift): Ready</span>
  </div>
  <div class="ability" id="airhop">
    <div class="ability-icon">ü¶Ö</div>
    <span>Air Hop (Space): Ready</span>
  </div>
  <div class="ability" id="block">
    <div class="ability-icon">‚öîÔ∏è</div>
    <span>Sword (C): Ready</span>
  </div>
  <div class="slope-info" id="slopeInfo">Slope: None (0¬∞)</div>
  <div class="coords" id="playerCoords">Coords: (0, 0)</div>
  <div class="health-container">
    <span>Health:</span>
    <div class="health-bar">
      <div class="health-fill" id="healthFill" style="width: 100%;"></div>
    </div>
    <span id="healthText">100</span>
  </div>
  <div class="coords" id="objectsInView">Objects in view: 0</div>
  <div class="coords" id="ramUsage">RAM: 0 MB</div>
</div>
<div id="fpsMeter">FPS: 0</div>
<canvas id="gameCanvas"></canvas>
<canvas id="lightCanvas"></canvas>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
  const CONFIG = {
    gravity: 1.3,
    maxGravityAcceleration: 15,
    zIndex: {
        background: 0,
        sword: 10,
        decor: 2,
        platform: 3,
        player: 4,
        hud: 100,
        fpsMeter: 101,
        loadingScreen: 1000
    },
    parallax: {
        decor: 0.5
    },
    player: {
        width: 50,
        height: 100,
        speed: 5,
        runSpeed: 7,
        dashSpeed: 15,
        jumpVelocity: -12,
        airHopVelocity: -12,
        dashDuration: 200,
        dashCooldown: 500,
        hopCooldown: 1000,
        collisionFilter: {
            category: 0x0001,
            mask: 0x0002 | 0x0004
        }
    },
    sword: {
        width: 50,
        height: 75,
        offsetYUp: 1
    },
    camera: {
        smoothFactor: 0.2,
        bgPanSpeed: 0,
        cullThreshold: 50
    },
    culling: {
        physicsMargin: 100,
        renderMargin: 50
    },
    rotationLimit: 5,
    maxVideoResolution: {
        width: 1920,
        height: 1080
    },
    fixedDelta: 1000 / 60,
    light: {
      enabled: true,
      radius: 350,
      gradientStops: [
        { offset: 0, color: 'rgba(255, 255, 255, 0.3)' },
        { offset: 0.5, color: 'rgba(0, 0, 0, 0.2)' },
        { offset: 1, color: 'rgba(0, 0, 0, 0.4)' }
      ],
      blendMode: 'multiply',
      canvasZIndex: 15,
      updateThreshold: 5
    },
    hudUpdateInterval: 1000,
    particlePoolSize: 100,
    maxActiveHitboxes: 5,
    nativeAnimationFps: 30
  };

  const mapData = {
  "playerStart": {
    "x": 0,
    "y": 0,
    "w": 50,
    "h": 100,
    "zIndex": 1,
    "angle": 0
  },
  "textures": [ "https://corsproxy.io/https://poki.com/favicon.ico"],
  "platforms": [
    {
      "id": "6nZuizW8hxb6-m0JFncfLJvDx",
      "type": "platform",
      "x": -15,
      "y": 101,
      "w": 2500,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 1
    },
    {
      "id": "keMuBhHTqzP2-ElDnZmfDgouW",
      "type": "platform",
      "x": -265,
      "y": -379,
      "w": 2000,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 2
    },
    {
      "id": "VejZRojgzHvF-blIm5xKkEuSc",
      "type": "wall",
      "x": 785,
      "y": -279,
      "w": 300,
      "h": 100,
      "angle": 90,
      "textureId": 0,
      "zIndex": 3
    },
    {
      "id": "ou9cBmQV4oSC-wSgRFhRiTbIE",
      "type": "platform",
      "x": 1035,
      "y": -179,
      "w": 400,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 4
    }
  ],
  "decor": []
};

  const playerAnimations = {
    idle: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 15 },
    runLeft: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 30 }, 
    runRight: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 20 },
    jump: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 12 },
    fall: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 12 },
    attackUp: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 24 },
    attackDown: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 24 },
    attackLeft: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 24 },
    attackRight: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 24 }
  };

  const swordAnimations = {
    attackUp: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 24 },
    attackDown: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 24 },
    attackLeft: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 24 },
    attackRight: { url: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm', fps: 24 }
  };

  const textureCache = new Map();
  const videoTextures = new Map();
  let soundtrack;
  const uniqueImageUrls = [...new Set(mapData.textures.filter(src => !src.endsWith('.webm')))];
  const uniqueAnimUrls = [...new Set([...Object.values(playerAnimations).map(a => a.url), ...Object.values(swordAnimations).map(a => a.url)])];
  const uniqueTextureVideoUrls = mapData.textures.filter(src => src.endsWith('.webm'));
  let totalAssets = uniqueImageUrls.length + uniqueAnimUrls.length + uniqueTextureVideoUrls.length + 1;
  let loadedAssets = 0;
  const failedAttempts = new Map();
  const animLoaded = new Set();
  const textureVideoLoaded = new Set();
  let soundtrackLoaded = false;
  let soundtrackAttempts = 0;

  const DOM = {
    canvas: document.getElementById("gameCanvas"),
    lightCanvas: document.getElementById("lightCanvas"),
    background: document.getElementById('background'),
    loadingBar: document.getElementById('loadingBar'),
    loadingText: document.getElementById('loadingText'),
    loadingScreen: document.getElementById('loadingScreen'),
    startButton: document.getElementById('startButton'),
    hud: {
      dash: document.getElementById('dash'),
      airhop: document.getElementById('airhop'),
      block: document.getElementById('block'),
      slopeInfo: document.getElementById('slopeInfo'),
      playerCoords: document.getElementById('playerCoords'),
      health: document.getElementById('healthText'),
      healthFill: document.getElementById('healthFill'),
      objectsInView: document.getElementById('objectsInView'),
      ramUsage: document.getElementById('ramUsage')
    }
  };

  let canvasWidth = window.innerWidth;
  let canvasHeight = window.innerHeight;
  let screenPlayerPos = { x: 0, y: 0 };

  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  function drawChecker(ctx, x, y, w, h, angle) {
    ctx.save();
    ctx.translate(Math.round(x), Math.round(y));
    ctx.rotate(angle);
    const size = 20;
    const cols = Math.ceil(w / size);
    const rows = Math.ceil(h / size);
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const px = col * size - w / 2;
        const py = row * size - h / 2;
        const color = ((row + col) % 2 === 0) ? '#000000' : '#ff00ff';
        ctx.fillStyle = color;
        const rectW = (col === cols - 1) ? (w % size || size) : size;
        const rectH = (row === rows - 1) ? (h % size || size) : size;
        ctx.fillRect(Math.round(px), Math.round(py), rectW, rectH);
      }
    }
    ctx.restore();
  }

  function preloadImages() {
    uniqueImageUrls.forEach(src => {
      const img = new Image();
      img.src = src;
      img.crossOrigin = "anonymous";
      img.onload = () => {
        textureCache.set(src, { w: img.width, h: img.height, img });
        loadedAssets++;
        updateLoading();
      };
      img.onerror = () => {
        const attempts = (failedAttempts.get(src) || 0) + 1;
        failedAttempts.set(src, attempts);
        if (attempts < 2) {
          console.warn(`Retrying image: ${src}`);
          setTimeout(() => {
            img.src = src;
          }, 1000);
        } else {
          console.warn(`Permanent fail image: ${src}`);
          textureCache.set(src, { w: 0, h: 0, img: null });
          loadedAssets++;
          updateLoading();
        }
      };
    });
  }

  function preloadAnimations() {
    const playerUniqueUrls = [...new Set(Object.values(playerAnimations).map(a => a.url))];
    const swordUniqueUrls = [...new Set(Object.values(swordAnimations).map(a => a.url))];
    const allUniqueUrls = [...new Set([...playerUniqueUrls, ...swordUniqueUrls])];
    if (allUniqueUrls.length === 0) {
      loadedAssets++;
      updateLoading();
      return;
    }
    allUniqueUrls.forEach(url => {
      const video = document.createElement('video');
      video.src = url;
      video.crossOrigin = "anonymous";
      video.muted = true;
      video.playsInline = true;
      video.preload = "metadata";
      video.playbackRate = 1.0; 
      video.addEventListener('loadedmetadata', () => {
        if (animLoaded.has(url)) return;
        animLoaded.add(url);
        const playerKeys = Object.entries(playerAnimations).filter(([k,v]) => v.url === url).map(([k]) => k);
        const playerNonAttackKeys = playerKeys.filter(k => !k.startsWith('attack'));
        const playerAttackKeys = playerKeys.filter(k => k.startsWith('attack'));
        if (playerNonAttackKeys.length > 0) {
          const loopVideo = video.cloneNode(true);
          loopVideo.loop = true;
          const loopData = { 
            video: loopVideo, 
            w: video.videoWidth, 
            h: video.videoHeight, 
            loaded: true, 
            isPlaying: false, 
            lastVisible: false
          };
          playerNonAttackKeys.forEach(key => {
            videoTextures.set(`player_${key}`, loopData);
          });
        }
        if (playerAttackKeys.length > 0) {
          const attackVideo = video.cloneNode(true);
          attackVideo.loop = false;
          const attackData = { 
            video: attackVideo, 
            w: video.videoWidth, 
            h: video.videoHeight, 
            loaded: true, 
            isPlaying: false, 
            lastVisible: false,
            duration: video.duration * 1000
          };
          playerAttackKeys.forEach(key => {
            videoTextures.set(`player_${key}`, attackData);
          });
        }
        const swordKeys = Object.entries(swordAnimations).filter(([k,v]) => v.url === url).map(([k]) => k);
        if (swordKeys.length > 0) {
          const swordVideo = video.cloneNode(true);
          swordVideo.loop = false;
          const swordData = { 
            video: swordVideo, 
            w: video.videoWidth, 
            h: video.videoHeight, 
            loaded: true, 
            isPlaying: false, 
            lastVisible: false,
            duration: video.duration * 1000 
          };
          swordKeys.forEach(key => {
            videoTextures.set(`sword_${key}`, swordData);
          });
        }
        loadedAssets++;
        updateLoading();
      });
      video.addEventListener('error', () => {
        const attempts = (failedAttempts.get(url) || 0) + 1;
        failedAttempts.set(url, attempts);
        if (attempts < 2) {
          console.warn(`Retrying animation video: ${url}`);
          setTimeout(() => {
            video.src = url;
            video.load();
          }, 1000);
        } else {
          console.warn(`Permanent fail animation: ${url}`);
          const playerKeys = Object.entries(playerAnimations).filter(([k,v]) => v.url === url).map(([k]) => k);
          const playerNonAttackKeys = playerKeys.filter(k => !k.startsWith('attack'));
          const playerAttackKeys = playerKeys.filter(k => k.startsWith('attack'));
          if (playerNonAttackKeys.length > 0) {
            const fallback = { 
              video: null, 
              w: 50, 
              h: 100, 
              loaded: true, 
              isPlaying: false, 
              lastVisible: false
            };
            playerNonAttackKeys.forEach(key => {
              videoTextures.set(`player_${key}`, fallback);
            });
          }
          if (playerAttackKeys.length > 0) {
            const fallbackAttack = { 
              video: null, 
              w: 50, 
              h: 100, 
              loaded: true, 
              isPlaying: false, 
              lastVisible: false,
              duration: 200
            };
            playerAttackKeys.forEach(key => {
              videoTextures.set(`player_${key}`, fallbackAttack);
            });
          }
          const swordKeys = Object.entries(swordAnimations).filter(([k,v]) => v.url === url).map(([k]) => k);
          if (swordKeys.length > 0) {
            const fallbackSword = { 
              video: null, 
              w: 50, 
              h: 75, 
              loaded: true, 
              isPlaying: false, 
              lastVisible: false,
              duration: 200 
            };
            swordKeys.forEach(key => {
              videoTextures.set(`sword_${key}`, fallbackSword);
            });
          }
          loadedAssets++;
          updateLoading();
        }
      });
      video.load();
    });
  }

  function preloadTextureVideos() {
    uniqueTextureVideoUrls.forEach(src => {
      const originalId = mapData.textures.indexOf(src);
      const video = document.createElement('video');
      video.src = src;
      video.crossOrigin = "anonymous";
      video.muted = true;
      video.playsInline = true;
      video.preload = "metadata";
      video.loop = true;
      video.playbackRate = 1.0;
      video.addEventListener('loadedmetadata', () => {
        if (textureVideoLoaded.has(src)) return;
        textureVideoLoaded.add(src);
        videoTextures.set(`texture_${originalId}`, { video, w: video.videoWidth, h: video.videoHeight, loaded: true, isPlaying: false, lastVisible: false });
        loadedAssets++;
        updateLoading();
      });
      video.addEventListener('error', () => {
        const attempts = (failedAttempts.get(src) || 0) + 1;
        failedAttempts.set(src, attempts);
        if (attempts < 2) {
          console.warn(`Retrying texture video: ${src}`);
          setTimeout(() => {
            video.src = src;
            video.load();
          }, 1000);
        } else {
          console.warn(`Permanent fail texture video: ${src}`);
          videoTextures.set(`texture_${originalId}`, { video: null, w: 0, h: 0, loaded: true, isPlaying: false, lastVisible: false });
          loadedAssets++;
          updateLoading();
        }
      });
      video.load();
    });
  }

  function updateLoading() {
    const progress = totalAssets > 0 ? Math.min((loadedAssets / totalAssets) * 100, 100) : 0;
    DOM.loadingBar.style.width = `${progress}%`;
    DOM.loadingText.textContent = `Loading... ${Math.round(progress)}%`;
    if (loadedAssets >= totalAssets) {
      setTimeout(() => {
        DOM.startButton.style.display = 'block';
      }, 500);
    }
  }

  let gameStarted = false;
  const tempNearbyArray = [];
  const tempAllVisible = [];
  let lastCamPosForCull = { x: 0, y: 0 };
  let lastHudUpdate = 0;
  let lastGroundInfo = { isOnGround: false, onSlope: false, slopeAngle: 0 };

  function startGame() {
    if (gameStarted) return;
    gameStarted = true;
    soundtrack.playbackRate = 1.0;
    soundtrack.play().catch(e => console.warn('Soundtrack play failed:', e));

    const { Engine, Render, Runner, Bodies, World, Body, Events, Composite, Query, Vector, Bounds, Common } = Matter;

    DOM.canvas.width = canvasWidth;
    DOM.canvas.height = canvasHeight;
    DOM.lightCanvas.width = canvasWidth;
    DOM.lightCanvas.height = canvasHeight;

    const ctx = DOM.canvas.getContext('2d', { willReadFrequently: false, alpha: true });
    if (!ctx) {
      console.error('Failed to get canvas context');
      return;
    }

    const engine = Engine.create();
    engine.world.gravity.y = CONFIG.gravity;
    engine.timing.timeScale = 1;
    Common._nextDelta = CONFIG.fixedDelta;

    const render = Render.create({
      canvas: DOM.canvas,
      engine: engine,
      options: {
        width: canvasWidth,
        height: canvasHeight,
        wireframes: false,
        background: 'transparent'
      },
      context: ctx
    });

    const blockHitboxes = [];
    let initialCamPos = { x: mapData.playerStart.x, y: mapData.playerStart.y };
    let decorObjects = [];
    let staticRenderables = [];
    let staticBodies = [];
    let particlesPool = [];
    let activeParticles = [];

    function getParticleFromPool() {
      if (particlesPool.length > 0) {
        return particlesPool.pop();
      }
      return Bodies.circle(0, 0, 3, {
        isStatic: false,
        label: 'particle',
        collisionFilter: { mask: 0x0000 },
        render: { fillStyle: '#ffff00' },
        friction: 0,
        frictionStatic: 0,
        frictionAir: 0,
        poolActive: false
      });
    }

    function returnParticleToPool(particle) {
      if (particle && !particle.poolActive) {
        World.remove(engine.world, particle);
        particle.poolActive = false;
        particlesPool.push(particle);
      }
    }

    function drawBodyVideo(ctx, source, x, y, w, h, angle) {
      if (!source || !source.videoWidth) return;
      ctx.save();
      ctx.translate(Math.round(x), Math.round(y));
      ctx.rotate(angle);
      ctx.drawImage(source, Math.round(-w / 2), Math.round(-h / 2), Math.round(w), Math.round(h));
      ctx.restore();
    }

    function updateVideoPlay(videoData, isVisible) {
      if (!videoData || !videoData.video) return;
      try {
        if (isVisible !== videoData.lastVisible) {
          videoData.lastVisible = isVisible;
          if (isVisible && !videoData.isPlaying) {
            videoData.video.playbackRate = 1.0; 
            videoData.video.play().catch(e => console.warn('Video play failed:', e));
            videoData.isPlaying = true;
          } else if (!isVisible && videoData.isPlaying) {
            videoData.video.pause();
            videoData.isPlaying = false;
          }
        }
      } catch (e) {
        console.warn('Video play error:', e);
      }
    }

    const boundsOverlap = (min1, max1, min2, max2) => !(max1.x < min2.x || min1.x > max2.x || max1.y < min2.y || min1.y > max2.y);

    Render.bodies = function(render, bodies, context) {
      const c = context;
      const baseCullBounds = {
        min: { x: render.bounds.min.x - CONFIG.culling.renderMargin, y: render.bounds.min.y - CONFIG.culling.renderMargin },
        max: { x: render.bounds.max.x + CONFIG.culling.renderMargin, y: render.bounds.max.y + CONFIG.culling.renderMargin }
      };
      tempAllVisible.length = 0;

      // Cleanup old hitboxes
      const now = performance.now();
      for (let i = blockHitboxes.length - 1; i >= 0; i--) {
        const block = blockHitboxes[i];
        if (now - block.creationTime > block.duration) {
          const videoData = videoTextures.get(block.videoTextureId);
          if (videoData && videoData.video && videoData.isPlaying) {
            videoData.video.pause();
            videoData.video.currentTime = 0;
            videoData.isPlaying = false;
          }
          blockHitboxes.splice(i, 1);
        }
      }

      let visibleStatic = [];
      for (let i = 0; i < staticRenderables.length; i++) {
        const {type, item, zIndex} = staticRenderables[i];
        let b;
        if (type === 'body') {
          b = item.bounds;
        } else {
          if (!item.currentPos) continue;
          b = {
            min: { x: item.currentPos.x - item.w / 2, y: item.currentPos.y - item.h / 2 },
            max: { x: item.currentPos.x + item.w / 2, y: item.currentPos.y + item.h / 2 }
          };
        }
        if (b && boundsOverlap(baseCullBounds.min, baseCullBounds.max, b.min, b.max)) {
          visibleStatic.push({type, item, zIndex});
          let videoData;
          if (type === 'body' && item.platformVideo) {
            videoData = videoTextures.get(item.videoTextureId);
          } else if (type === 'decor' && item.isVideo) {
            videoData = videoTextures.get(item.videoTextureId);
          }
          if (videoData) updateVideoPlay(videoData, true);
        } else {
          let videoData;
          if (type === 'body' && item.platformVideo) {
            videoData = videoTextures.get(item.videoTextureId);
          } else if (type === 'decor' && item.isVideo) {
            videoData = videoTextures.get(item.videoTextureId);
          }
          if (videoData) updateVideoPlay(videoData, false);
        }
      }

      const dynamicVisible = [];
      const allBodies = Composite.allBodies(render.engine.world);
      for (let i = 0; i < allBodies.length; i++) {
        const body = allBodies[i];
        if (body.label === 'player' || body.label === 'particle') {
          const b = body.bounds;
          if (b && boundsOverlap(baseCullBounds.min, baseCullBounds.max, b.min, b.max)) {
            dynamicVisible.push({type: 'body', item: body, zIndex: body.render ? (body.render.zIndex || 0) : 0});
            if (body.playerVideo) {
              const videoData = videoTextures.get(body.videoTextureId);
              if (videoData) updateVideoPlay(videoData, true);
            }
          } else if (body.playerVideo) {
            const videoData = videoTextures.get(body.videoTextureId);
            if (videoData) updateVideoPlay(videoData, false);
          }
        }
      }

      // Add visible hitboxes
      for (let i = 0; i < blockHitboxes.length; i++) {
        const block = blockHitboxes[i];
        const b = {
          min: { x: block.position.x - block.width / 2, y: block.position.y - block.height / 2 },
          max: { x: block.position.x + block.width / 2, y: block.position.y + block.height / 2 }
        };
        if (boundsOverlap(baseCullBounds.min, baseCullBounds.max, b.min, b.max)) {
          dynamicVisible.push({type: 'hitbox', item: block, zIndex: CONFIG.zIndex.sword});
          const videoData = videoTextures.get(block.videoTextureId);
          if (videoData && videoData.loaded && videoData.video) {
            if (!videoData.isPlaying) {
              videoData.video.currentTime = 0;
              videoData.video.play().catch(e => console.warn('Sword video play failed:', e));
              videoData.isPlaying = true;
            }
            updateVideoPlay(videoData, true);
          }
        } else {
          const videoData = videoTextures.get(block.videoTextureId);
          if (videoData) updateVideoPlay(videoData, false);
        }
      }

      tempAllVisible.length = 0;
      tempAllVisible.push(...visibleStatic, ...dynamicVisible);
      tempAllVisible.sort((a, b) => a.zIndex - b.zIndex);

      DOM.hud.objectsInView.textContent = `Objects in view: ${tempAllVisible.length}`;

      for (let i = 0; i < tempAllVisible.length; i++) {
        const {type, item} = tempAllVisible[i];
        if (type === 'decor') {
          const decor = item;
          if (decor.isChecker) {
            drawChecker(c, decor.currentPos.x, decor.currentPos.y, decor.w, decor.h, decor.angle);
          } else if (decor.isVideo) {
            const videoData = videoTextures.get(decor.videoTextureId);
            if (videoData && videoData.loaded && videoData.video) {
              drawBodyVideo(c, videoData.video, decor.currentPos.x, decor.currentPos.y, decor.videoW || decor.w, decor.videoH || decor.h, decor.angle);
            } else {
              drawChecker(c, decor.currentPos.x, decor.currentPos.y, decor.w, decor.h, decor.angle);
            }
          } else if (decor.isImage) {
            const textureSrc = mapData.textures[decor.textureId];
            const img = textureCache.get(textureSrc)?.img;
            if (img && img.complete) {
              c.save();
              c.translate(Math.round(decor.currentPos.x), Math.round(decor.currentPos.y));
              c.rotate(decor.angle);
              c.drawImage(img, Math.round(-decor.w / 2), Math.round(-decor.h / 2), Math.round(decor.w), Math.round(decor.h));
              c.restore();
            } else {
              drawChecker(c, decor.currentPos.x, decor.currentPos.y, decor.w, decor.h, decor.angle);
            }
          }
        } else if (type === 'hitbox') {
          const block = item;
          const videoData = videoTextures.get(block.videoTextureId);
          if (videoData && videoData.loaded && videoData.video) {
            drawBodyVideo(c, videoData.video, block.position.x, block.position.y, block.videoW || block.width, block.videoH || block.height, block.angle);
          } else {
            drawChecker(c, block.position.x, block.position.y, block.width, block.height, block.angle);
          }
        } else {
          const body = item;
          if (!body.position || (!body.circleRadius && (!body.width || !body.height))) continue;
          if (body.label === 'player' && body.playerVideo) {
            const videoData = videoTextures.get(body.videoTextureId);
            if (videoData && videoData.loaded && videoData.video) {
              drawBodyVideo(c, videoData.video, body.position.x, body.position.y, body.videoW || body.width, body.videoH || body.height, body.angle);
            } else {
              drawChecker(c, body.position.x, body.position.y, body.width, body.height, body.angle);
            }
          } else if (body.label === "platform" && body.platformVideo) {
            const videoData = videoTextures.get(body.videoTextureId);
            if (videoData && videoData.loaded && videoData.video) {
              drawBodyVideo(c, videoData.video, body.position.x, body.position.y, body.videoW || body.width, body.videoH || body.height, body.angle);
            } else {
              drawChecker(c, body.position.x, body.position.y, body.width, body.height, body.angle);
            }
          } else if (body.render.sprite && body.render.sprite.texture) {
            const img = textureCache.get(body.render.sprite.texture)?.img;
            if (img && img.complete) {
              c.save();
              c.translate(Math.round(body.position.x), Math.round(body.position.y));
              c.rotate(body.angle);
              c.drawImage(img, Math.round(-body.width / 2), Math.round(-body.height / 2), Math.round(body.width), Math.round(body.height));
              c.restore();
            } else {
              drawChecker(c, body.position.x, body.position.y, body.width, body.height, body.angle);
            }
          } else if (body.render.checker) {
            drawChecker(c, body.position.x, body.position.y, body.width, body.height, body.angle);
          } else if (body.render.fillStyle) {
            c.save();
            c.translate(Math.round(body.position.x), Math.round(body.position.y));
            c.rotate(body.angle);
            c.fillStyle = body.render.fillStyle;
            if (body.circleRadius) {
              c.beginPath();
              c.arc(0, 0, body.circleRadius, 0, Math.PI * 2);
              c.fill();
            } else {
              c.fillRect(Math.round(-body.width / 2), Math.round(-body.height / 2), Math.round(body.width), Math.round(body.height));
            }
            c.restore();
          }
        }
      }

      for (let i = activeParticles.length - 1; i >= 0; i--) {
        const particle = activeParticles[i];
        if (now - particle.creationTime > 500) {
          returnParticleToPool(particle);
          activeParticles.splice(i, 1);
        }
      }
    };

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    let player = Bodies.rectangle(mapData.playerStart.x, mapData.playerStart.y, mapData.playerStart.w, mapData.playerStart.h, {
      restitution: 0,
      friction: 0,
      frictionAir: 0,
      frictionStatic: 0,
      inertia: Infinity,
      render: { zIndex: CONFIG.zIndex.player },
      label: 'player',
      collisionFilter: CONFIG.player.collisionFilter,
      playerVideo: true,
      videoTextureId: 'player_idle',
      videoW: mapData.playerStart.w,
      videoH: mapData.playerStart.h,
      health: 100,
      isStatic: false
    });
    player.width = mapData.playerStart.w;
    player.height = mapData.playerStart.h;
    World.add(engine.world, player);

    const groundSensor = Bodies.rectangle(mapData.playerStart.x, mapData.playerStart.y + mapData.playerStart.h / 2 + 1, mapData.playerStart.w, 3, {
      isSensor: true,
      isStatic: false,
      collisionFilter: CONFIG.player.collisionFilter,
      render: { visible: false, fillStyle: 'transparent' }
    });
    groundSensor.width = mapData.playerStart.w;
    groundSensor.height = 3;
    World.add(engine.world, groundSensor);

    let camPos = { x: mapData.playerStart.x, y: mapData.playerStart.y };
    let camTarget = { x: camPos.x, y: camPos.y };
    const walls = [];
    const platforms = [];

    mapData.platforms.forEach(p => {
      let body;
      const texture = mapData.textures[p.textureId];
      const zIndex = p.zIndex || CONFIG.zIndex.platform;
      let renderOpts = { zIndex };
      if (texture) {
        if (texture.endsWith('.webm')) {
          body = Bodies.rectangle(p.x, p.y, p.w, p.h, {
            isStatic: true,
            restitution: 0,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0,
            label: p.type,
            angle: (p.angle || 0) * Math.PI / 180,
            collisionFilter: { category: 0x0004, mask: 0x0001 },
            render: renderOpts
          });
          body.platformVideo = true;
          body.videoTextureId = `texture_${p.textureId}`;
          body.videoW = p.w;
          body.videoH = p.h;
        } else {
          const imgSize = textureCache.get(texture) || { w: p.w, h: p.h };
          renderOpts.sprite = { texture, xScale: p.w / imgSize.w, yScale: p.h / imgSize.h };
          body = Bodies.rectangle(p.x, p.y, p.w, p.h, {
            isStatic: true,
            restitution: 0,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0,
            render: renderOpts,
            label: p.type,
            angle: (p.angle || 0) * Math.PI / 180,
            collisionFilter: { category: 0x0004, mask: 0x0001 },
            id: p.id
          });
        }
      } else {
        renderOpts.checker = true;
        body = Bodies.rectangle(p.x, p.y, p.w, p.h, {
          isStatic: true,
          restitution: 0,
          friction: 0,
          frictionStatic: 0,
          frictionAir: 0,
          render: renderOpts,
          label: p.type,
          angle: (p.angle || 0) * Math.PI / 180,
          collisionFilter: { category: 0x0004, mask: 0x0001 },
          id: p.id
        });
      }
      body.width = p.w;
      body.height = p.h;
      body.inWorld = true;
      World.add(engine.world, body);
      staticBodies.push(body);
      staticRenderables.push({type: 'body', item: body, zIndex: body.render.zIndex || 0});
      if (p.type === 'wall') walls.push(body);
      if (p.type === 'platform') platforms.push(body);
    });

    staticRenderables.sort((a, b) => a.zIndex - b.zIndex);

    const collidableBodies = [...platforms, ...walls];
    const obstacles = collidableBodies;

    mapData.decor.forEach(d => {
      const texture = mapData.textures[d.textureId];
      const decor = {
        id: d.id,
        x: d.x,
        y: d.y,
        w: d.w,
        h: d.h,
        angle: (d.angle || 0) * Math.PI / 180,
        textureId: d.textureId,
        zIndex: d.zIndex || CONFIG.zIndex.decor,
        parallaxSpeed: d.parallaxSpeed !== undefined ? d.parallaxSpeed : CONFIG.parallax.decor,
        originalPos: { x: d.x, y: d.y }
      };
      decor.enteredView = false;
      decor.baseCamPos = null;
      if (texture) {
        if (texture.endsWith('.webm')) {
          decor.isVideo = true;
          decor.videoTextureId = `texture_${d.textureId}`;
          decor.videoW = d.w;
          decor.videoH = d.h;
        } else {
          decor.isImage = true;
        }
      } else {
        decor.isChecker = true;
      }
      decorObjects.push(decor);
      staticRenderables.push({type: 'decor', item: decor, zIndex: decor.zIndex || 0});
    });

    const state = {
      keys: { left: false, right: false, up: false, down: false, dash: false, hop: false, sword: false, run: false },
      isDashing: false,
      dashStartTime: 0,
      lastDash: 0,
      lastHop: 0,
      isFrozen: false,
      facingDirection: 1,
      lastDirection: { x: 0, y: 0 },
      dashVelocity: { x: 0, y: 0 },
      wasInAir: false,
      currentAnimation: 'idle',
      isAttacking: false,
      attackDirection: null,
      attackStartTime: 0,
      dashHopInitiated: false
    };

    const keyMap = {
      ArrowLeft: 'left',
      ArrowRight: 'right',
      ArrowUp: 'up',
      ArrowDown: 'down',
      ShiftLeft: 'dash',
      ShiftRight: 'dash',
      Space: 'hop',
      KeyC: 'sword',
      KeyR: 'run'
    };

    let lastBlockTime = 0;
    const blockCooldown = 50;

    document.addEventListener('keydown', e => {
      if (keyMap[e.code]) state.keys[keyMap[e.code]] = true;
      if (e.code === 'KeyC') placeBlock();
    });

    document.addEventListener('keyup', e => {
      if (keyMap[e.code]) state.keys[keyMap[e.code]] = false;
    });

    function createParticles(x, y, count) {
      for (let i = 0; i < count; i++) {
        const particle = getParticleFromPool();
        Body.setPosition(particle, { x, y });
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        Body.setVelocity(particle, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
        particle.creationTime = performance.now();
        particle.poolActive = true;
        World.add(engine.world, particle);
        activeParticles.push(particle);
        if (activeParticles.length > CONFIG.particlePoolSize) {
          const old = activeParticles.shift();
          returnParticleToPool(old);
        }
      }
    }

    function setAnimationPlaybackRate(videoData, animName, animType = 'player') {
      if (!videoData || !videoData.video) return;
      let anim;
      if (animType === 'player') {
        anim = playerAnimations[animName];
      } else if (animType === 'sword') {
        anim = swordAnimations[animName];
      }
      if (anim && anim.fps) {
        const rate = anim.fps / CONFIG.nativeAnimationFps;
        videoData.video.playbackRate = rate;
      }
    }

    function placeBlock() {
      const now = Date.now();
      if (now - lastBlockTime < blockCooldown || state.isAttacking) return;
      lastBlockTime = now;
      // Limit active hitboxes
      while (blockHitboxes.length >= CONFIG.maxActiveHitboxes) {
        const old = blockHitboxes.shift();
        const videoData = videoTextures.get(old.videoTextureId);
        if (videoData && videoData.video && videoData.isPlaying) {
          videoData.video.pause();
          videoData.video.currentTime = 0;
          videoData.isPlaying = false;
        }
      }
      let direction;
      if (state.keys.down) {
        direction = 'down';
      } else if (state.lastDirection.y < 0) {
        direction = 'up';
      } else if (state.lastDirection.x > 0) {
        direction = 'right';
      } else if (state.lastDirection.x < 0) {
        direction = 'left';
      } else {
        direction = 'right';
      }
      state.isAttacking = true;
      state.attackDirection = direction;
      state.attackStartTime = now;
      let blockWidth = CONFIG.sword.width;
      let blockHeight = CONFIG.sword.height;
      let blockOffsetX = 0, blockOffsetY = 0;
      const extend = CONFIG.sword.offsetYUp;
      if (direction === 'up' || direction === 'down') {
        blockHeight = player.height + CONFIG.sword.height * extend;
        if (direction === 'up') {
          blockOffsetY = -player.height / 2;
        } else {
          blockOffsetY = player.height / 2;
        }
      } else {
        blockWidth = player.width + CONFIG.sword.width * extend;
        if (direction === 'right') {
          blockOffsetX = player.width / 2;
        } else {
          blockOffsetX = -player.width / 2;
        }
      }
      const attackDir = `attack${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
      const videoTextureId = `sword_${attackDir}`;
      const videoData = videoTextures.get(videoTextureId) || { w: blockWidth, h: blockHeight, duration: 200 };
      const block = {
        position: { x: player.position.x + blockOffsetX, y: player.position.y + blockOffsetY },
        angle: player.angle,
        width: blockWidth,
        height: blockHeight,
        videoW: blockWidth,
        videoH: blockHeight,
        videoTextureId: videoTextureId,
        creationTime: performance.now(),
        duration: videoData.duration || 200,
        offsetX: blockOffsetX,
        offsetY: blockOffsetY
      };
      blockHitboxes.push(block);

      setAnimationPlaybackRate(videoData, attackDir, 'sword');
      setTimeout(() => {
        state.isAttacking = false;
        state.attackDirection = null;
      }, block.duration);
      createParticles(player.position.x + blockOffsetX, player.position.y + blockOffsetY, 5);
    }

    function getVertices(body) {
      if (!body || !body.position || (!body.circleRadius && (!body.width || !body.height))) return [];
      const { position, angle } = body;
      const cos = Math.cos(angle), sin = Math.sin(angle);
      if (body.circleRadius) {
        const sides = 16;
        const vertices = [];
        for (let i = 0; i < sides; i++) {
          const theta = (i / sides) * Math.PI * 2;
          const vx = body.circleRadius * Math.cos(theta);
          const vy = body.circleRadius * Math.sin(theta);
          vertices.push({ x: vx * cos - vy * sin + position.x, y: vx * sin + vy * cos + position.y });
        }
        return vertices;
      } else {
        const hw = body.width / 2, hh = body.height / 2;
        const vertices = [{ x: -hw, y: -hh }, { x: hw, y: -hh }, { x: hw, y: hh }, { x: -hw, y: hh }];
        return vertices.map(v => ({ x: v.x * cos - v.y * sin + position.x, y: v.x * sin + v.y * cos + position.y }));
      }
    }

    function projectVertices(vertices, axis) {
      let min = Infinity, max = -Infinity;
      for (const v of vertices) {
        const dot = v.x * axis.x + v.y * axis.y;
        min = Math.min(min, dot);
        max = Math.max(max, dot);
      }
      return { min, max };
    }

    function getAxes(body) {
      const vertices = getVertices(body);
      if (vertices.length === 0) return [];
      const axes = [];
      for (let i = 0; i < vertices.length; i++) {
        const p1 = vertices[i];
        const p2 = vertices[(i + 1) % vertices.length];
        const edge = { x: p2.x - p1.x, y: p2.y - p1.y };
        const normal = { x: -edge.y, y: edge.x };
        const len = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
        if (len === 0) continue;
        axes.push({ x: normal.x / len, y: normal.y / len });
      }
      return axes;
    }

    function satCollision(bodyA, bodyB) {
      if (!bodyA || !bodyB || !bodyA.position || !bodyB.position) return null;
      const axes = [...getAxes(bodyA), ...getAxes(bodyB)];
      if (axes.length === 0) return null;
      let mtv = null, overlap = Infinity;
      for (const axis of axes) {
        const projA = projectVertices(getVertices(bodyA), axis);
        const projB = projectVertices(getVertices(bodyB), axis);
        if (projA.max < projB.min || projB.max < projA.min) return null;
        const o = Math.min(projA.max - projB.min, projB.max - projA.min);
        if (o < overlap) {
          overlap = o;
          mtv = { axis, overlap };
        }
      }
      if (!mtv || isNaN(mtv.overlap) || isNaN(mtv.axis.x) || isNaN(mtv.axis.y)) return null;
      const aCenter = bodyA.position;
      const bCenter = bodyB.position;
      const centerDiff = { x: aCenter.x - bCenter.x, y: aCenter.y - bCenter.y };
      const dot = centerDiff.x * mtv.axis.x + centerDiff.y * mtv.axis.y;
      if (dot < 0) {
        mtv.axis.x = -mtv.axis.x;
        mtv.axis.y = -mtv.axis.y;
      }
      return mtv;
    }

    function isPlayerOnGround() {
      if (!player || !groundSensor) return { isOnGround: false, onSlope: false, slopeAngle: 0 };
      const sensorHeight = 3;
      const sensorOffsetY = player.height / 2 + 1;
      const angle = player.angle;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const sensorOffsetX = -sensorOffsetY * sin;
      const sensorOffsetYVal = sensorOffsetY * cos;
      Body.setPosition(groundSensor, { x: player.position.x + sensorOffsetX, y: player.position.y + sensorOffsetYVal });
      Body.setAngle(groundSensor, angle);
      Body.setVelocity(groundSensor, { x: 0, y: 0 });
      Body.setAngularVelocity(groundSensor, 0);
      const margin = 100;
      const queryMin = { x: groundSensor.position.x - groundSensor.width / 2 - margin, y: groundSensor.position.y - groundSensor.height / 2 - margin };
      const queryMax = { x: groundSensor.position.x + groundSensor.width / 2 + margin, y: groundSensor.position.y + groundSensor.height / 2 + margin };
      tempNearbyArray.length = 0;
      for (let i = 0; i < collidableBodies.length; i++) {
        const body = collidableBodies[i];
        const b = body.bounds;
        if (!b) continue;
        if (boundsOverlap(queryMin, queryMax, b.min, b.max)) {
          tempNearbyArray.push(body);
        }
      }
      const collisions = Query.collides(groundSensor, tempNearbyArray);
      let isOnGround = false, onSlope = false, slopeAngle = 0;
      let deepestCollision = null;
      let maxDepth = 0;
      for (const collision of collisions) {
        let otherBody = null;
        if (collision.bodyA && (collision.bodyA.label === 'platform' || collision.bodyA.label === 'wall')) {
          otherBody = collision.bodyA;
        } else if (collision.bodyB && (collision.bodyB.label === 'platform' || collision.bodyB.label === 'wall')) {
          otherBody = collision.bodyB;
        }
        if (otherBody && collision.normal && collision.normal.y < -0.5) {
          const depth = collision.depth || 0;
          if (depth > maxDepth) {
            maxDepth = depth;
            deepestCollision = otherBody;
          }
        }
      }
      if (deepestCollision) {
        isOnGround = true;
        if (deepestCollision.label === 'platform') {
          const platform = mapData.platforms.find(p => p.id === deepestCollision.id);
          if (platform && Math.abs(platform.angle) > 5) {
            onSlope = true;
            slopeAngle = Math.round(platform.angle);
          }
        }
      }
      return { isOnGround, onSlope, slopeAngle };
    }

    function updatePlayerAnimation(now, groundInfo) {
      const velY = player ? player.velocity.y : 0;
      let newAnimation = state.currentAnimation;
      if (state.isAttacking && now - state.attackStartTime < (videoTextures.get(`player_attack${state.attackDirection ? state.attackDirection.charAt(0).toUpperCase() + state.attackDirection.slice(1) : 'Up'}`)?.duration || 200)) {
        newAnimation = `attack${state.attackDirection ? state.attackDirection.charAt(0).toUpperCase() + state.attackDirection.slice(1) : 'Up'}`;
      } else {
        if (!groundInfo.isOnGround) {
          if (velY < -1) {
            newAnimation = 'jump';
          } else if (velY > 1) {
            newAnimation = 'fall';
          }
        } else {
          if (state.keys.right && !state.keys.left) {
            newAnimation = 'runRight';
          } else if (state.keys.left && !state.keys.right) {
            newAnimation = 'runLeft';
          } else {
            newAnimation = 'idle';
          }
        }
      }
      if (newAnimation !== state.currentAnimation) {
        const oldId = `player_${state.currentAnimation}`;
        const newId = `player_${newAnimation}`;
        const oldData = videoTextures.get(oldId);
        const newData = videoTextures.get(newId);
        const isSameVideo = oldData?.video === newData?.video;
        const oldIsAttack = state.currentAnimation.startsWith('attack');
        const newIsAttack = newAnimation.startsWith('attack');
        if (!isSameVideo || oldIsAttack !== newIsAttack) {
          if (oldData?.video && oldData.isPlaying) {
            oldData.video.pause();
            oldData.isPlaying = false;
          }
          if (newData?.video) {
            newData.video.currentTime = newIsAttack ? 0 : newData.video.currentTime;
            if (!newData.isPlaying) {
              newData.video.play().catch(e => console.warn('Player animation play failed:', e));
              newData.isPlaying = true;
            }
          }
        }

        setAnimationPlaybackRate(newData, newAnimation, 'player');
        state.currentAnimation = newAnimation;
        if (player) {
          player.videoTextureId = newId;
        }
      }
    }

    function updateHUD(now) {
      if (!player || now - lastHudUpdate < CONFIG.hudUpdateInterval) return;
      lastHudUpdate = now;
      const updateStatus = (element, name, lastTime, cooldown) => {
        const isReady = now - lastTime >= cooldown;
        element.className = `ability ${isReady?'ready':'cooldown'}`;
        element.querySelector('span').textContent = `${name}: ${isReady?'Ready':'Cooldown'}`;
      };
      updateStatus(DOM.hud.dash, 'Dash (Shift)', state.lastDash, CONFIG.player.dashCooldown);
      updateStatus(DOM.hud.airhop, 'Air Hop (Space)', state.lastHop, CONFIG.player.hopCooldown);
      DOM.hud.block.className = 'ability ready';
      DOM.hud.block.querySelector('span').textContent = `Sword (C): ${Date.now()-lastBlockTime>=blockCooldown?'Ready':'Cooldown'}`;
      const { onSlope, slopeAngle } = lastGroundInfo;
      DOM.hud.slopeInfo.textContent = onSlope ? `Slope: Active (${slopeAngle}¬∞)` : `Slope: None (0¬∞)`;
      DOM.hud.slopeInfo.className = onSlope ? 'slope-info ready' : 'slope-info';
      DOM.hud.playerCoords.textContent = `Coords: (${Math.round(player.position.x)}, ${Math.round(player.position.y)})`;
      const healthPercent = (player.health / 100) * 100;
      DOM.hud.health.textContent = Math.round(player.health);
      DOM.hud.healthFill.style.width = `${healthPercent}%`;
      const memory = performance && performance.memory ? performance.memory : null;
      if (memory) {
        const used = Math.round(memory.usedJSHeapSize / 1024 / 1024);
        DOM.hud.ramUsage.textContent = `RAM: ${used} MB`;
      }
    }

    const resizeHandler = debounce(() => {
      canvasWidth = window.innerWidth;
      canvasHeight = window.innerHeight;
      DOM.canvas.width = canvasWidth;
      DOM.canvas.height = canvasHeight;
      DOM.lightCanvas.width = canvasWidth;
      DOM.lightCanvas.height = canvasHeight;
      if (render) {
        render.options.width = canvasWidth;
        render.options.height = canvasHeight;
        render.bounds.max.x = render.bounds.min.x + canvasWidth;
        render.bounds.max.y = render.bounds.min.y + canvasHeight;
      }
    }, 100);

    window.addEventListener('resize', resizeHandler);

    Render.lookAt(render, {
      min: { x: mapData.playerStart.x - canvasWidth / 2, y: mapData.playerStart.y - canvasHeight / 2 },
      max: { x: mapData.playerStart.x + canvasWidth / 2, y: mapData.playerStart.y + canvasHeight / 2 }
    });

    let lastTime = performance.now();
    let frames = 0;
    let fps = 0;

    function updateFPS() {
      const now = performance.now();
      frames++;
      if (now - lastTime >= 1000) {
        fps = Math.round(frames * 1000 / (now - lastTime));
        frames = 0;
        lastTime = now;
        document.getElementById('fpsMeter').textContent = 'FPS: ' + fps;
      }
      if (gameStarted) requestAnimationFrame(updateFPS);
    }

    updateFPS();

    function endDash() {
      if (state.isDashing) {
        state.isDashing = false;
        state.lastDash = Date.now();
        const postDashSpeed = CONFIG.player.speed;
        if (state.dashHopInitiated) {
          const dashDirection = state.dashVelocity.x > 0 ? 1 : -1;
          Body.setVelocity(player, { x: dashDirection * postDashSpeed, y: player.velocity.y });
        } else {
          const magnitude = Math.sqrt(state.dashVelocity.x ** 2 + state.dashVelocity.y ** 2);
          const scaledX = magnitude > 0 ? state.dashVelocity.x * (postDashSpeed / magnitude) : 0;
          const scaledY = magnitude > 0 ? state.dashVelocity.y * (postDashSpeed / magnitude) : 0;
          Body.setVelocity(player, { x: scaledX, y: scaledY });
        }
        player.force = { x: 0, y: 0 };
        state.dashHopInitiated = false;
      }
    }

    let lastGroundState = { isOnGround: false, onSlope: false, slopeAngle: 0 };
    let slopeFrameCount = 0;
    const hysteresisFrames = 3;
    let previousPlayerState = {
      position: { x: mapData.playerStart.x, y: mapData.playerStart.y },
      velocity: { x: 0, y: 0 },
      angle: 0
    };
    let cachedCos = 1, cachedSin = 0;
    let lastPlayerVelMag = 0;

    Events.on(engine, 'beforeUpdate', () => {
      if (!player) return;
      previousPlayerState = {
        position: { ...player.position },
        velocity: { ...player.velocity },
        angle: player.angle
      };
      const now = Date.now();
      const groundInfo = isPlayerOnGround();
      updatePlayerAnimation(now, groundInfo);
      if (state.keys.right && !state.keys.left) {
        state.facingDirection = 1;
        state.lastDirection = { x: 1, y: 0 };
      } else if (state.keys.left && !state.keys.right) {
        state.facingDirection = -1;
        state.lastDirection = { x: -1, y: 0 };
      } else if (state.keys.up && !state.keys.right && !state.keys.left) {
        state.lastDirection = { x: 0, y: -1 };
      }
      const justLanded = !lastGroundState.isOnGround && groundInfo.isOnGround;
      const maxTilt = CONFIG.rotationLimit * Math.PI / 180;
      if (groundInfo.onSlope) {
        slopeFrameCount = Math.min(slopeFrameCount + 1, hysteresisFrames);
      } else {
        slopeFrameCount = Math.max(slopeFrameCount - 1, 0);
      }
      groundInfo.onSlope = slopeFrameCount >= hysteresisFrames;
      if (!groundInfo.onSlope) groundInfo.slopeAngle = 0;
      let targetAngle = groundInfo.onSlope ? groundInfo.slopeAngle * Math.PI / 180 : 0;
      targetAngle = Math.max(-maxTilt * 10, Math.min(targetAngle, maxTilt * 10));
      let lerpSpeed = 0.1;
      if (justLanded && groundInfo.onSlope) {
        lerpSpeed = 0.3;
      }
      const newPlayerAngle = player.angle + (targetAngle - player.angle) * lerpSpeed;
      Body.setAngle(player, newPlayerAngle);
      const angle = player.angle;
      if (Math.abs(angle - Math.atan2(cachedSin, cachedCos)) > 0.01) {
        cachedCos = Math.cos(angle);
        cachedSin = Math.sin(angle);
      }
      const sensorOffsetYVal = player.height / 2 + 1;
      const groundSensorOffsetX = -sensorOffsetYVal * cachedSin;
      const groundSensorOffsetY = sensorOffsetYVal * cachedCos;
      Body.setPosition(groundSensor, { x: player.position.x + groundSensorOffsetX, y: player.position.y + groundSensorOffsetY });
      Body.setAngle(groundSensor, angle);
      Body.setVelocity(groundSensor, { x: 0, y: 0 });
      Body.setAngularVelocity(groundSensor, 0);
      lastGroundState = groundInfo;
      lastGroundInfo = groundInfo;
      state.wasInAir = !groundInfo.isOnGround;
      if (state.isDashing && now - state.dashStartTime < CONFIG.player.dashDuration) {
        if (state.dashHopInitiated) {
          Body.setVelocity(player, { x: state.dashVelocity.x, y: player.velocity.y });
          player.force = { x: 0, y: 0 };
        } else {
          const g = engine.world.gravity;
          player.force.y = -(g.y * g.scale * player.mass);
          player.force.x = 0;
        }
      } else if (state.isDashing) {
        endDash();
      }
      if (state.keys.dash && !state.isDashing && now - state.lastDash >= CONFIG.player.dashCooldown) {
        const dir = state.keys.right ? 1 : state.keys.left ? -1 : state.facingDirection;
        let dashVx = dir * CONFIG.player.dashSpeed;
        let dashVy = 0;
        if (groundInfo.isOnGround && groundInfo.onSlope) {
          const theta = groundInfo.slopeAngle * Math.PI / 180;
          dashVx = dir * CONFIG.player.dashSpeed * Math.cos(theta);
          dashVy = dir * CONFIG.player.dashSpeed * Math.sin(theta);
        }
        state.dashVelocity = { x: dashVx, y: dashVy };
        Body.setVelocity(player, state.dashVelocity);
        state.isDashing = true;
        state.dashStartTime = now;
        state.dashHopInitiated = false;
        player.frictionAir = 0;
        setTimeout(endDash, CONFIG.player.dashDuration);
      }
      if (!state.isDashing) {
        const input = (state.keys.right ? 1 : 0) - (state.keys.left ? 1 : 0);
        const speed = state.keys.run ? CONFIG.player.runSpeed : CONFIG.player.speed;
        let targetVelX = input * speed;
        let targetVelY = 0;
        if (groundInfo.isOnGround && groundInfo.onSlope) {
          const theta = groundInfo.slopeAngle * Math.PI / 180;
          targetVelX = input * speed * Math.cos(theta);
          targetVelY = input * speed * Math.sin(theta);
        }
        if (groundInfo.isOnGround) {
          Body.setVelocity(player, { x: targetVelX, y: targetVelY });
        } else {
          Body.setVelocity(player, { x: player.velocity.x + (targetVelX - player.velocity.x) * 0.1, y: player.velocity.y });
        }
        if (state.keys.right) state.facingDirection = 1;
        if (state.keys.left) state.facingDirection = -1;
      }
      if (state.keys.hop && !groundInfo.isOnGround && now - state.lastHop >= CONFIG.player.hopCooldown) {
        const hopVelocity = state.isDashing ? CONFIG.player.jumpVelocity : CONFIG.player.airHopVelocity;
        Body.setVelocity(player, { x: player.velocity.x, y: hopVelocity });
        state.lastHop = now;
        if (state.isDashing) {
          state.dashHopInitiated = true;
        }
      }
      if (state.keys.up && groundInfo.isOnGround) {
        Body.setVelocity(player, { x: player.velocity.x, y: CONFIG.player.jumpVelocity });
      }
      if (!state.isDashing && !groundInfo.isOnGround) {
        const maxFallSpeed = CONFIG.maxGravityAcceleration;
        if (player.velocity.y > maxFallSpeed) {
          Body.setVelocity(player, { x: player.velocity.x, y: maxFallSpeed });
        }
      }
      const playerVelMag = Math.hypot(player.velocity.x, player.velocity.y);
      let wallCollision = false;
      if (playerVelMag > 1 || Math.random() < 0.1) {  
        const playerMargin = 20;
        const pMin = { x: player.position.x - player.width / 2 - playerMargin, y: player.position.y - player.height / 2 - playerMargin };
        const pMax = { x: player.position.x + player.width / 2 + playerMargin, y: player.position.y + player.height / 2 + playerMargin };
        tempNearbyArray.length = 0;
        for (let i = 0; i < obstacles.length; i++) {
          const body = obstacles[i];
          const b = body.bounds;
          if (!b) continue;
          if (boundsOverlap(pMin, pMax, b.min, b.max)) {
            tempNearbyArray.push(body);
          }
        }
        for (let j = 0; j < tempNearbyArray.length; j++) {
          const obstacle = tempNearbyArray[j];
          if (!obstacle.position || (!obstacle.circleRadius && (!obstacle.width || !obstacle.height))) continue;
          const mtv = satCollision(player, obstacle);
          if (mtv && mtv.overlap > 0.1) {
            const pos = player.position;
            Body.setPosition(player, { x: pos.x + mtv.axis.x * mtv.overlap * 1.01, y: pos.y + mtv.axis.y * mtv.overlap * 1.01 });
            const vel = player.velocity;
            const dot = vel.x * mtv.axis.x + vel.y * mtv.axis.y;
            if (dot < 0) {
              const normalVel = { x: dot * mtv.axis.x, y: dot * mtv.axis.y };
              let newVelX = vel.x - normalVel.x;
              let newVelY = vel.y - normalVel.y;
              if (groundInfo.isOnGround && Math.abs(mtv.axis.x) > 0.7) {
                newVelX = vel.x;
              }
              if (state.isDashing && Math.abs(mtv.axis.x) > 0.7) {
                endDash();
                newVelX = Math.abs(mtv.axis.x) > 0.9 ? 0 : newVelX;
                newVelY = Math.abs(mtv.axis.y) > 0.9 ? 0 : newVelY;
              }
              Body.setVelocity(player, { x: newVelX, y: newVelY });
            }
            wallCollision = true;
          }
        }
      }
      lastPlayerVelMag = playerVelMag;
      camTarget.x = player.position.x;
      camTarget.y = player.position.y;
      camPos.x += (camTarget.x - camPos.x) * CONFIG.camera.smoothFactor;
      camPos.y += (camTarget.y - camPos.y) * CONFIG.camera.smoothFactor;
      decorObjects.forEach(decor => {
        const staticX = decor.originalPos.x;
        const staticY = decor.originalPos.y;
        const halfW = decor.w / 2;
        const halfH = decor.h / 2;
        const staticMinX = staticX - halfW;
        const staticMaxX = staticX + halfW;
        const staticMinY = staticY - halfH;
        const staticMaxY = staticY + halfH;
        const camX = camPos.x - canvasWidth / 2;
        const camY = camPos.y - canvasHeight / 2;
        const viewRight = camX + canvasWidth;
        const viewBottom = camY + canvasHeight;
        const isInView = !(staticMaxX < camX || staticMinX > viewRight || staticMaxY < camY || staticMinY > viewBottom);
        if (isInView && !decor.enteredView) {
          decor.enteredView = true;
          decor.baseCamPos = { x: camPos.x, y: camPos.y };
        }
        let offsetX = 0, offsetY = 0;
        if (decor.enteredView) {
          const deltaCamX = camPos.x - decor.baseCamPos.x;
          const deltaCamY = camPos.y - decor.baseCamPos.y;
          const speed = decor.parallaxSpeed;
          offsetX = deltaCamX * speed;
          offsetY = deltaCamY * speed;
        }
        decor.currentPos = { x: decor.originalPos.x + offsetX, y: decor.originalPos.y + offsetY };
      });
      const camX = camPos.x - canvasWidth / 2;
      const camY = camPos.y - canvasHeight / 2;
      render.bounds.min.x = camX;
      render.bounds.min.y = camY;
      render.bounds.max.x = camX + canvasWidth;
      render.bounds.max.y = camY + canvasHeight;
      screenPlayerPos.x = player.position.x - camX;
      screenPlayerPos.y = player.position.y - camY;
      const camDist = Math.sqrt((camPos.x - lastCamPosForCull.x)**2 + (camPos.y - lastCamPosForCull.y)**2);
      if (camDist > CONFIG.camera.cullThreshold) {
        lastCamPosForCull = { ...camPos };
        const physBounds = {
          min: { x: camX - CONFIG.culling.physicsMargin, y: camY - CONFIG.culling.physicsMargin },
          max: { x: camX + canvasWidth + CONFIG.culling.physicsMargin, y: camY + canvasHeight + CONFIG.culling.physicsMargin }
        };
        for (let k = 0; k < staticBodies.length; k++) {
          const body = staticBodies[k];
          if (!body) continue;
          const b = body.bounds;
          if (!b) continue;
          const inPhysView = boundsOverlap(physBounds.min, physBounds.max, b.min, b.max);
          if (inPhysView && !body.inWorld) {
            World.add(engine.world, body);
            body.inWorld = true;
          } else if (!inPhysView && body.inWorld) {
            World.remove(engine.world, body);
            body.inWorld = false;
            if (body.platformVideo) {
              const videoData = videoTextures.get(body.videoTextureId);
              updateVideoPlay(videoData, false);
            }
          }
        }
      }
      if (isNaN(player.position.x) || isNaN(player.position.y) || isNaN(player.velocity.x) || isNaN(player.velocity.y) || isNaN(player.angle)) {
        console.warn('Player state NaN - resetting');
        Body.setPosition(player, previousPlayerState.position);
        Body.setVelocity(player, previousPlayerState.velocity);
        Body.setAngle(player, previousPlayerState.angle);
      }
      updateHUD(now);
    });

    Events.on(engine, 'afterUpdate', () => {
      if (!player) return;
      const playerAngle = player.angle;
      const cos = cachedCos;  
      const sin = cachedSin;
      blockHitboxes.forEach(block => {
        const rotatedOffsetX = block.offsetX * cos - block.offsetY * sin;
        const rotatedOffsetY = block.offsetX * sin + block.offsetY * cos;
        block.position.x = player.position.x + rotatedOffsetX;
        block.position.y = player.position.y + rotatedOffsetY;
        block.angle = playerAngle;
      });
    });

    let lastLightX = screenPlayerPos.x;
    let lastLightY = screenPlayerPos.y;

    function drawLight() {
      if (!CONFIG.light.enabled || !player) return;
      const dist = Math.hypot(screenPlayerPos.x - lastLightX, screenPlayerPos.y - lastLightY);
      if (dist < CONFIG.light.updateThreshold) {
        requestAnimationFrame(drawLight);
        return;
      }
      lastLightX = screenPlayerPos.x;
      lastLightY = screenPlayerPos.y;
      const lightCtx = DOM.lightCanvas.getContext('2d', { willReadFrequently: false, alpha: true });
      if (!lightCtx) return;
      lightCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      const gradient = lightCtx.createRadialGradient(
        screenPlayerPos.x, screenPlayerPos.y, 0,
        screenPlayerPos.x, screenPlayerPos.y, CONFIG.light.radius
      );
      CONFIG.light.gradientStops.forEach(stop => {
        gradient.addColorStop(stop.offset, stop.color);
      });
      lightCtx.fillStyle = gradient;
      lightCtx.fillRect(0, 0, canvasWidth, canvasHeight);
      requestAnimationFrame(drawLight);
    }

    drawLight();
  }

  preloadImages();
  preloadAnimations();
  preloadTextureVideos();

  soundtrack = new Audio('https://github.com/HyperRushNet/game/releases/download/soundtrack/soundtrack.mp3');
  soundtrack.loop = true;
  soundtrack.volume = 1;
  soundtrack.preload = "metadata";
  soundtrack.playbackRate = 1.0;
  soundtrack.addEventListener('canplaythrough', () => {
    if (soundtrackLoaded) return;
    soundtrackLoaded = true;
    loadedAssets++;
    updateLoading();
  });
  soundtrack.addEventListener('error', () => {
    soundtrackAttempts++;
    if (soundtrackAttempts < 2) {
      console.warn(`Retrying soundtrack ${soundtrackAttempts}`);
      setTimeout(() => {
        soundtrack.src = 'https://github.com/HyperRushNet/game/releases/download/soundtrack/soundtrack.mp3';
        soundtrack.load();
      }, 2000);
    } else {
      console.warn('Permanent fail soundtrack');
      loadedAssets++;
      updateLoading();
    }
  });
  soundtrack.load();

  DOM.startButton.addEventListener('click', () => {
    DOM.loadingScreen.style.display = 'none';
    startGame();
  });
</script>
</body>
</html>
<!-- Game code END -->
