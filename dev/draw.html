<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pixel Art Editor â€” Worker + Progress versie</title>
<style>
  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #1e1e1e;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  header {
    background: #333;
    padding: 1rem;
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    justify-content: center;
    width: 100%;
  }
  input[type="number"], input[type="file"] { width: 70px; }
  button, select, input[type="color"] {
    border-radius: 4px;
    border: none;
    background: #444;
    color: white;
    padding: 0.4rem 0.8rem;
    cursor: pointer;
  }
  button:hover { background: #666; }
  button:disabled { background: #222; cursor: not-allowed; }
  #progressContainer {
    width: 100%;
    max-width: 800px;
    margin: 0.5rem 0;
    display: none;
  }
  #progressBar {
    width: 100%;
    height: 20px;
    background: #444;
    border-radius: 10px;
    overflow: hidden;
  }
  #progressFill {
    height: 100%;
    background: #4CAF50;
    width: 0%;
    transition: width 0.3s;
  }
  #progressText {
    text-align: center;
    margin-top: 0.25rem;
    font-size: 0.9rem;
  }
  canvas {
    background: #fff;
    border: 1px solid #555;
    margin-top: 1rem;
    image-rendering: pixelated;
    cursor: crosshair;
    touch-action: none;
  }
  .transparent-checker {
    background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
                      linear-gradient(-45deg, #ccc 25%, transparent 25%),
                      linear-gradient(45deg, transparent 75%, #ccc 75%),
                      linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 20px 20px;
    background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
  }
  #eyedropperBtn {
    background: #555;
  }
  #eyedropperBtn.active {
    background: #4CAF50;
  }
</style>
</head>
<body>
<header>
  <label>Breedte: <input type="number" id="widthInput" value="16" min="1"></label>
  <label>Hoogte: <input type="number" id="heightInput" value="16" min="1"></label>
  <button id="createGrid">Nieuw raster</button>
  <input type="file" id="importImage" accept="image/png,image/jpeg,image/webp" style="padding: 0.4rem;">
  <button id="importBtn">Importeren</button>
  <input type="color" id="colorPicker" value="#000000">
  <button id="eyedropperBtn">Pipet</button>
  <button id="transparentBtn">Transparant</button>
  <label>Penseel: <input type="number" id="brushSize" value="1" min="1" max="10"></label>
  <button id="saveProject">Opslaan</button>
  <select id="projectSelect"></select>
  <button id="loadProject">Laden</button>
  <label>Export: <select id="exportFormat">
    <option value="png">PNG</option>
    <option value="jpg">JPG</option>
    <option value="webp">WebP</option>
  </select></label>
  <button id="exportImage">Exporteer</button>
</header>
<div id="progressContainer">
  <div id="progressBar"><div id="progressFill"></div></div>
  <div id="progressText">Voorbereiden...</div>
</div>
<canvas id="pixelCanvas" width="800" height="800" class="transparent-checker"></canvas>
<script>
(function() {
  'use strict';
  // ---------- Hoofd thread ----------
  const canvas = document.getElementById("pixelCanvas");
  const ctx = canvas.getContext("2d");
  let pixelData = new Map(); // Sparse: key = `${x},${y}`, value = color
  let pixelSize = 32;
  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;
  let color = "#000000";
  let transparentMode = false;
  let eyedropperMode = false;
  let width = 16;
  let height = 16;
  let brushSize = 1;
  let isDrawing = false;
  let isPanning = false;
  let lastPanX = 0;
  let lastPanY = 0;
  let canvasWidth = 800;
  let canvasHeight = 800;
  // Progress UI
  const progressContainer = document.getElementById("progressContainer");
  const progressFill = document.getElementById("progressFill");
  const progressText = document.getElementById("progressText");
  const createBtn = document.getElementById("createGrid");
  const exportBtn = document.getElementById("exportImage");
  const importBtn = document.getElementById("importBtn");
  const eyedropperBtn = document.getElementById("eyedropperBtn");
  // ---------- IndexedDB setup ----------
  let db = null;
  const request = indexedDB.open("PixelArtDB", 1);
  request.onupgradeneeded = e => {
    db = e.target.result;
    if (!db.objectStoreNames.contains("projects")) {
      db.createObjectStore("projects", { keyPath: "name" });
    }
  };
  request.onerror = e => console.error("IndexedDB error:", e);
  request.onsuccess = e => {
    db = e.target.result;
    loadProjectList();
  };
  // ---------- Render viewport only (met max resolutie cap) ----------
  function drawGrid() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
   
    let startX = Math.max(0, Math.floor(-offsetX / (pixelSize * zoom)));
    let endX = Math.min(width, Math.ceil((canvasWidth - offsetX) / (pixelSize * zoom)));
    let startY = Math.max(0, Math.floor(-offsetY / (pixelSize * zoom)));
    let endY = Math.min(height, Math.ceil((canvasHeight - offsetY) / (pixelSize * zoom)));
   
    // Cap maximale zichtbare world pixels op 750x750, zelfs bij extreme zoom out
    const maxVisible = 750;
    let visibleW = endX - startX;
    let visibleH = endY - startY;
   
    if (visibleW > maxVisible) {
      const extra = visibleW - maxVisible;
      const shrinkLeft = Math.floor(extra / 2);
      const shrinkRight = extra - shrinkLeft;
      startX += shrinkLeft;
      endX -= shrinkRight;
      visibleW = maxVisible;
    }
    if (visibleH > maxVisible) {
      const extra = visibleH - maxVisible;
      const shrinkTop = Math.floor(extra / 2);
      const shrinkBottom = extra - shrinkTop;
      startY += shrinkTop;
      endY -= shrinkBottom;
      visibleH = maxVisible;
    }
   
    const visiblePixels = visibleW * visibleH;
   
    ctx.setTransform(zoom, 0, 0, zoom, offsetX, offsetY);
   
    // Optimalisatie: Bij grote viewports, gebruik solid achtergrond
    if (visiblePixels > 1000000) {
      ctx.fillStyle = "#e8e8e8";
      ctx.fillRect(startX * pixelSize, startY * pixelSize, visibleW * pixelSize, visibleH * pixelSize);
    } else {
      // Volledige checkerboard
      for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
          const screenX = x * pixelSize;
          const screenY = y * pixelSize;
          const checkerColor = ((x + y) % 2 === 0 ? "#ddd" : "#fff");
          ctx.fillStyle = checkerColor;
          ctx.fillRect(screenX, screenY, pixelSize, pixelSize);
        }
      }
    }
   
    // Pixels tekenen (sparse)
    for (let y = startY; y < endY; y++) {
      for (let x = startX; x < endX; x++) {
        const key = x + "," + y;
        if (pixelData.has(key)) {
          const pxColor = pixelData.get(key);
          if (pxColor !== "rgba(0,0,0,0)") {
            ctx.fillStyle = pxColor;
            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
          }
        }
      }
    }
  }
  // ---------- Web Worker init ----------
  let worker = null;
  function initWorker() {
    if (worker) return worker;
    const workerScript = [
      "self.onmessage = function(e) {",
      " try {",
      " const msg = e.data;",
      " const type = msg.type;",
      " if (type === 'create') {",
      " const w = msg.data.w;",
      " const h = msg.data.h;",
      " const totalSteps = Math.max(10, Math.log(w * h) * 5 || 10);",
      " let step = 0;",
      " const interval = setInterval(() => {",
      " step++;",
      " self.postMessage({ type: 'progress', progress: (step / totalSteps) * 100, task: 'create' });",
      " if (step >= totalSteps) {",
      " clearInterval(interval);",
      " self.postMessage({ type: 'done', width: w, height: h });",
      " }",
      " }, 50);",
      " } else if (type === 'export') {",
      " const offscreen = msg.canvas;",
      " const offCtx = offscreen.getContext('2d');",
      " offCtx.imageSmoothingEnabled = false;",
      " ",
      " const sparseData = msg.data;",
      " const totalPixels = sparseData.length;",
      " let processed = 0;",
      " ",
      " if (msg.format === 'jpg') {",
      " offCtx.fillStyle = '#ffffff';",
      " offCtx.fillRect(0, 0, msg.width, msg.height);",
      " }",
      " ",
      " sparseData.forEach(([key, pxColor]) => {",
      " if (pxColor !== 'rgba(0,0,0,0)') {",
      " const [x, y] = key.split(',').map(Number);",
      " offCtx.fillStyle = pxColor;",
      " offCtx.fillRect(x, y, 1, 1);",
      " }",
      " processed++;",
      " self.postMessage({ type: 'progress', progress: (processed / totalPixels) * 100, task: 'export' });",
      " });",
      " ",
      " const mimeType = msg.format === 'png' ? 'image/png' : msg.format === 'jpg' ? 'image/jpeg' : 'image/webp';",
      " const quality = msg.format === 'jpg' ? 0.95 : 1.0;",
      " ",
      " offscreen.convertToBlob({ type: mimeType, quality: quality }).then(blob => {",
      " self.postMessage({ type: 'done', blob: blob });",
      " }).catch(err => {",
      " self.postMessage({ type: 'error', message: err.message });",
      " });",
      " } else if (type === 'import') {",
      " const imageBitmap = msg.imageBitmap;",
      " const gridWidth = msg.data.gridWidth;",
      " const gridHeight = msg.data.gridHeight;",
      " ",
      " const offscreenResized = new OffscreenCanvas(gridWidth, gridHeight);",
      " const offCtxResized = offscreenResized.getContext('2d');",
      " offCtxResized.imageSmoothingEnabled = false;",
      " offCtxResized.drawImage(imageBitmap, 0, 0, gridWidth, gridHeight);",
      " ",
      " const chunkSize = 100;",
      " const totalChunks = Math.ceil(gridHeight / chunkSize);",
      " let processedChunks = 0;",
      " let sparseData = [];",
      " ",
      " for (let chunk = 0; chunk < totalChunks; chunk++) {",
      " const startRow = chunk * chunkSize;",
      " const endRow = Math.min(startRow + chunkSize, gridHeight);",
      " ",
      " const chunkHeight = endRow - startRow;",
      " const chunkImageData = offCtxResized.getImageData(0, startRow, gridWidth, chunkHeight);",
      " const chunkData = chunkImageData.data;",
      " ",
      " for (let y = startRow; y < endRow; y++) {",
      " for (let x = 0; x < gridWidth; x++) {",
      " const localY = y - startRow;",
      " const idx = (localY * gridWidth + x) * 4;",
      " const r = chunkData[idx];",
      " const g = chunkData[idx + 1];",
      " const b = chunkData[idx + 2];",
      " const a = chunkData[idx + 3];",
      " if (a > 128) {",
      " const hex = '#' + [r, g, b].map(function(c) { return c.toString(16).padStart(2, '0'); }).join('');",
      " sparseData.push([x + ',' + y, hex]);",
      " }",
      " }",
      " }",
      " ",
      " processedChunks++;",
      " self.postMessage({ ",
      " type: 'progress', ",
      " progress: (processedChunks / totalChunks) * 100, ",
      " task: 'import' ",
      " });",
      " }",
      " ",
      " self.postMessage({ type: 'done', sparseData: sparseData });",
      " }",
      " } catch (err) {",
      " self.postMessage({ type: 'error', message: err.message });",
      " }",
      "};"
    ].join('\n');
    worker = new Worker(URL.createObjectURL(new Blob([workerScript], { type: 'application/javascript' })));
   
    worker.onmessage = function(e) {
      const type = e.data.type;
      const progress = e.data.progress;
      const task = e.data.task;
      const blob = e.data.blob;
      const newWidth = e.data.width;
      const newHeight = e.data.height;
      const message = e.data.message;
      const sparseData = e.data.sparseData;
      if (type === 'progress') {
        progressFill.style.width = progress + '%';
        const percent = Math.round(progress);
        if (task === 'create') {
          progressText.textContent = "Raster initialiseren... " + percent + "%";
        } else if (task === 'export') {
          progressText.textContent = "Export... " + percent + "%";
        } else if (task === 'import') {
          progressText.textContent = "Importeren... " + percent + "%";
        }
      } else if (type === 'done') {
        if (blob) {
          // Export done
          const randomId = crypto.randomUUID().slice(0, 8);
          const format = document.getElementById("exportFormat").value;
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = randomId + ".pixelart." + format;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          hideProgress();
          exportBtn.disabled = false;
        } else if (sparseData) {
          // Import done
          pixelData = new Map(sparseData);
          drawGrid();
          hideProgress();
          importBtn.disabled = false;
        } else {
          // Create done
          width = newWidth;
          height = newHeight;
          pixelData.clear();
          pixelSize = 32;
          zoom = Math.min(canvasWidth / (width * pixelSize), canvasHeight / (height * pixelSize));
          offsetX = (canvasWidth - width * pixelSize * zoom) / 2;
          offsetY = (canvasHeight - height * pixelSize * zoom) / 2;
          drawGrid();
          hideProgress();
          createBtn.disabled = false;
        }
      } else if (type === 'error') {
        console.error("Worker error:", message);
        progressText.textContent = "Fout: " + message;
        setTimeout(hideProgress, 3000);
        if (task === 'create') createBtn.disabled = false;
        if (task === 'export') exportBtn.disabled = false;
        if (task === 'import') importBtn.disabled = false;
      }
    };
    worker.onerror = function(e) {
      console.error("Worker fatal error:", e);
      progressText.textContent = "Onverwachte fout in worker.";
      setTimeout(hideProgress, 3000);
      createBtn.disabled = false;
      exportBtn.disabled = false;
      importBtn.disabled = false;
    };
    return worker;
  }
  // ---------- Raster aanmaken ----------
  document.getElementById("createGrid").onclick = () => {
    const w = parseInt(document.getElementById("widthInput").value) || 16;
    const h = parseInt(document.getElementById("heightInput").value) || 16;
    if (w < 1 || h < 1) {
      alert("Breedte en hoogte moeten minimaal 1 zijn.");
      return;
    }
    const totalSize = BigInt(w) * BigInt(h); // Use BigInt for huge numbers to avoid precision loss
   
    const myWorker = initWorker();
   
    if (Number(totalSize) <= 1000000) {
      // Klein: direct
      width = w;
      height = h;
      pixelData.clear();
      pixelSize = 32;
      zoom = Math.min(canvasWidth / (width * pixelSize), canvasHeight / (height * pixelSize));
      offsetX = (canvasWidth - width * pixelSize * zoom) / 2;
      offsetY = (canvasHeight - height * pixelSize * zoom) / 2;
      drawGrid();
    } else {
      // Groot: via worker met progress
      if (!confirm("Groot raster (" + w + "x" + h + ", " + totalSize.toLocaleString() + " pixels). Dit kan even duren om te initialiseren. OK?")) return;
      createBtn.disabled = true;
      myWorker.postMessage({ type: 'create', data: { w: w, h: h } });
      showProgress();
      progressText.textContent = "Raster initialiseren... 0%";
    }
  };
  // ---------- Importeren ----------
  const importFile = document.getElementById("importImage");
  const importButton = document.getElementById("importBtn");
  importButton.onclick = () => {
    const file = importFile.files[0];
    if (!file) {
      alert("Selecteer een afbeelding (PNG, JPG, WebP).");
      return;
    }
    if (width === 0 || height === 0) {
      alert("Maak eerst een raster aan met breedte en hoogte.");
      return;
    }
    const reader = new FileReader();
    reader.onload = e => {
      const img = new Image();
      img.onload = () => {
        createImageBitmap(img).then(imageBitmap => {
          const myWorker = initWorker();
          myWorker.postMessage({
            type: 'import',
            data: { gridWidth: width, gridHeight: height },
            imageBitmap: imageBitmap
          }, [imageBitmap]);
          showProgress();
          progressText.textContent = "Importeren... 0%";
          importBtn.disabled = true;
        }).catch(err => {
          console.error("ImageBitmap creation failed:", err);
          alert("Fout bij voorbereiden van afbeelding.");
          importBtn.disabled = false;
        });
      };
      img.onerror = () => alert("Fout bij laden van afbeelding.");
      img.src = e.target.result;
    };
    reader.onerror = () => alert("Fout bij lezen van bestand.");
    reader.readAsDataURL(file);
  };
  // ---------- Kleuren / penseel ----------
  document.getElementById("colorPicker").oninput = e => {
    color = e.target.value;
    transparentMode = false;
    eyedropperMode = false;
    document.getElementById("transparentBtn").textContent = "Transparant";
    eyedropperBtn.classList.remove('active');
  };
  document.getElementById("transparentBtn").onclick = () => {
    transparentMode = !transparentMode; // Toggle voor gebruiksgemak
    document.getElementById("transparentBtn").textContent = transparentMode ? "Kleur" : "Transparant"; // Visual feedback
    eyedropperMode = false;
    eyedropperBtn.classList.remove('active');
  };
  document.getElementById("eyedropperBtn").onclick = () => {
    eyedropperMode = !eyedropperMode;
    if (eyedropperMode) {
      eyedropperBtn.classList.add('active');
      canvas.style.cursor = 'crosshair';
      transparentMode = false;
      document.getElementById("transparentBtn").textContent = "Transparant";
    } else {
      eyedropperBtn.classList.remove('active');
      canvas.style.cursor = 'crosshair';
    }
  };
  document.getElementById("brushSize").oninput = e => brushSize = Math.max(1, Math.min(10, parseInt(e.target.value) || 1));
  // ---------- Tekenen / pan / zoom / eyedropper ----------
  canvas.addEventListener("mousedown", e => {
    const rect = canvas.getBoundingClientRect();
    if (e.button === 0) {
      if (eyedropperMode) {
        // Eyedropper: pick color
        const xPos = (e.clientX - rect.left - offsetX) / (pixelSize * zoom);
        const yPos = (e.clientY - rect.top - offsetY) / (pixelSize * zoom);
        const x = Math.floor(xPos);
        const y = Math.floor(yPos);
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const key = x + "," + y;
          const pickedColor = pixelData.get(key);
          if (pickedColor && pickedColor !== "rgba(0,0,0,0)") {
            color = pickedColor;
            document.getElementById("colorPicker").value = color;
          }
        }
        return;
      }
      isDrawing = true;
      drawPixel(e);
    } else if (e.button === 2) {
      isPanning = true;
      lastPanX = e.clientX;
      lastPanY = e.clientY;
      e.preventDefault();
    }
  });
  canvas.addEventListener("mousemove", e => {
    if (eyedropperMode) {
      canvas.style.cursor = 'crosshair';
      return;
    }
    if (isDrawing) drawPixel(e);
    if (isPanning) {
      const deltaX = e.clientX - lastPanX;
      const deltaY = e.clientY - lastPanY;
      offsetX += deltaX;
      offsetY += deltaY;
      lastPanX = e.clientX;
      lastPanY = e.clientY;
      drawGrid();
    }
  });
  canvas.addEventListener("mouseup", () => {
    isDrawing = false;
    isPanning = false;
  });
  canvas.addEventListener("mouseleave", () => {
    isDrawing = false;
    isPanning = false;
  });
  canvas.addEventListener("contextmenu", e => e.preventDefault());
  function drawPixel(e) {
    const rect = canvas.getBoundingClientRect();
    const xPos = (e.clientX - rect.left - offsetX) / (pixelSize * zoom);
    const yPos = (e.clientY - rect.top - offsetY) / (pixelSize * zoom);
    const x = Math.floor(xPos);
    const y = Math.floor(yPos);
    if (x < 0 || x >= width || y < 0 || y >= height) return;
    const half = Math.floor(brushSize / 2);
   
    let updated = false;
    for (let dy = -half; dy <= half; dy++) {
      for (let dx = -half; dx <= half; dx++) {
        const px = x + dx;
        const py = y + dy;
        if (px >= 0 && px < width && py >= 0 && py < height) {
          const key = px + "," + py;
          const isTransparent = transparentMode;
          const newColor = isTransparent ? "rgba(0,0,0,0)" : color;
          const oldColor = pixelData.get(key);
          if (oldColor !== newColor) {
            if (newColor === "rgba(0,0,0,0)") {
              pixelData.delete(key);
            } else {
              pixelData.set(key, newColor);
            }
            updated = true;
          }
        }
      }
    }
    if (updated) drawGrid();
  }
  function applyZoom(zoomFactor, centerX, centerY) {
    const worldX = (centerX - offsetX) / zoom;
    const worldY = (centerY - offsetY) / zoom;
    zoom *= zoomFactor;
    zoom = Math.min(Math.max(zoom, 0.01), 100);
    offsetX = centerX - worldX * zoom;
    offsetY = centerY - worldY * zoom;
    drawGrid();
  }
  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
    applyZoom(zoomFactor, cx, cy);
  }, { passive: false });
  let pinchLastDist = 0;
  let pinchInitialZoom = 0;
  canvas.addEventListener("touchstart", e => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      pinchLastDist = Math.hypot(dx, dy);
      pinchInitialZoom = zoom;
      isPanning = false; // Stop panning during pinch
    } else if (e.touches.length === 1) {
      lastPanX = e.touches[0].clientX;
      lastPanY = e.touches[0].clientY;
      isPanning = true;
    }
  });
  canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    if (e.touches.length === 1 && isPanning) {
      // Single touch pan
      const deltaX = e.touches[0].clientX - lastPanX;
      const deltaY = e.touches[0].clientY - lastPanY;
      offsetX += deltaX;
      offsetY += deltaY;
      lastPanX = e.touches[0].clientX;
      lastPanY = e.touches[0].clientY;
      drawGrid();
    } else if (e.touches.length === 2) {
      // Pinch zoom
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.hypot(dx, dy);
      if (pinchLastDist > 0) {
        const zoomFactor = dist / pinchLastDist;
        const rect = canvas.getBoundingClientRect();
        const cx = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
        const cy = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;
        applyZoom(zoomFactor, cx, cy);
      }
      pinchLastDist = dist;
    }
  }, { passive: false });
  canvas.addEventListener("touchend", e => {
    if (e.touches.length < 2) {
      pinchLastDist = 0;
    }
    if (e.touches.length === 0) {
      isPanning = false;
    }
  });
  // ---------- Export ----------
  document.getElementById("exportImage").onclick = () => {
    const format = document.getElementById("exportFormat").value;
    const sparseData = Array.from(pixelData.entries());
    if (sparseData.length === 0) {
      alert("Geen pixels om te exporteren. Teken eerst iets!");
      return;
    }
   
    const estimatedSizeMB = (sparseData.length * 1 * 1 * 4) / (1024 * 1024);
    if (width * height > 10000 || estimatedSizeMB > 100) {
      if (!confirm("Groot project (" + width + "x" + height + ", ~" + Math.round(estimatedSizeMB) + " MB). Exporteren kan even duren. OK?")) return;
    }
   
    const myWorker = initWorker();
    const offscreen = new OffscreenCanvas(width, height);
    myWorker.postMessage({
      type: 'export',
      data: sparseData,
      format: format,
      width: width,
      height: height,
      canvas: offscreen
    }, [offscreen]);
   
    showProgress();
    progressText.textContent = "Export starten... 0%";
    exportBtn.disabled = true;
  };
  function showProgress() {
    progressContainer.style.display = 'block';
    progressFill.style.width = '0%';
  }
  function hideProgress() {
    progressContainer.style.display = 'none';
  }
  // ---------- Opslaan / laden ----------
  document.getElementById("saveProject").onclick = () => {
    if (!db) {
      alert("Database niet geladen. Probeer opnieuw.");
      return;
    }
    const name = prompt("Naam van project:");
    if (!name) return;
    const sparseData = Array.from(pixelData.entries());
    const tx = db.transaction("projects", "readwrite");
    const store = tx.objectStore("projects");
    const req = store.put({ name: name, width: width, height: height, pixelData: sparseData });
    req.onerror = e => alert("Opslaan mislukt: " + e.target.error);
    req.onsuccess = loadProjectList;
  };
  document.getElementById("loadProject").onclick = () => {
    if (!db) {
      alert("Database niet geladen. Probeer opnieuw.");
      return;
    }
    const select = document.getElementById("projectSelect");
    const name = select.value;
    if (!name) {
      alert("Selecteer een project.");
      return;
    }
    const tx = db.transaction("projects", "readonly");
    const store = tx.objectStore("projects");
    const req = store.get(name);
    req.onerror = e => alert("Laden mislukt: " + e.target.error);
    req.onsuccess = () => {
      const proj = req.result;
      if (!proj) return;
      width = proj.width;
      height = proj.height;
      pixelData = new Map(proj.pixelData || []);
      pixelSize = 32;
      zoom = Math.min(canvasWidth / (width * pixelSize), canvasHeight / (height * pixelSize));
      offsetX = (canvasWidth - width * pixelSize * zoom) / 2;
      offsetY = (canvasHeight - height * pixelSize * zoom) / 2;
      drawGrid();
    };
  };
  function loadProjectList() {
    if (!db) return;
    const tx = db.transaction("projects", "readonly");
    const store = tx.objectStore("projects");
    const req = store.getAll();
    req.onsuccess = () => {
      const select = document.getElementById("projectSelect");
      select.innerHTML = "";
      req.result.forEach(p => {
        const opt = document.createElement("option");
        opt.value = p.name;
        opt.textContent = p.name;
        select.appendChild(opt);
      });
    };
  }
  // ---------- Init ----------
  window.addEventListener('load', () => {
    document.getElementById("createGrid").click();
  });
})();
</script>
</body>
</html>
