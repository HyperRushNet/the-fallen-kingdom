<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fallen Kingdom Map Editor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --bg: #2B2B2B;
            --dark: #1E1E1E;
            --light: #3C3C3C;
            --accent: #87CEEB;
            --blue: #4B6B9B;
            --green: #4EC9B0;
            --red: #E64539;
            --yellow: #FDD835;
            --text: #E0E0E0;
            --text-dim: #9D9D9D;
            --border: #333;
            --tab: #313131;
            --tab-active: #404040;
            --tab-text: #B0B0B0;
            --tab-active-text: #FFFFFF;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }
        #toolbar {
            height: 40px;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 12px;
        }
        #toolbar .section {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }
        #toolbar button {
            background: var(--light);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 4px 8px;
            margin: 0 2px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: background 0.2s;
        }
        #toolbar button:hover {
            background: var(--accent);
            color: #000;
        }
        #toolbar select, #toolbar input {
            background: var(--dark);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 2px 4px;
            margin: 0 2px;
            border-radius: 3px;
            font-size: 11px;
        }
        #status-icon {
            margin-left: auto;
            font-size: 12px;
            color: var(--yellow);
        }
        #main-container {
            display: flex;
            height: calc(100vh - 40px);
        }
        #hierarchy {
            width: 250px;
            background: var(--bg);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            transition: width 0.3s;
        }
        #hierarchy-header {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            font-weight: bold;
            font-size: 12px;
            color: var(--accent);
        }
        #objects-list {
            flex: 1;
            padding: 5px;
        }
        .object-item {
            padding: 6px 8px;
            margin: 3px 0;
            background: var(--dark);
            border: 1px solid transparent;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        .object-item:hover {
            background: var(--light);
        }
        .object-item.selected {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }
        .object-item .type-icon {
            font-size: 10px;
            opacity: 0.7;
            width: 16px;
        }
        #scene-view {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, #1a1a1a, #222);
            cursor: crosshair;
            overflow: hidden;
            touch-action: none;
        }
        #scene-view canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        #inspector {
            width: 300px;
            background: var(--bg);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: width 0.3s;
        }
        #inspector-header {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            font-weight: bold;
            font-size: 12px;
            color: var(--accent);
        }
        #inspector-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        .property-group {
            margin-bottom: 24px;
        }
        .property-group h3 {
            font-size: 11px;
            color: var(--text-dim);
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }
        .property-row label {
            width: 70px;
            color: var(--text-dim);
            font-size: 10px;
            text-transform: uppercase;
        }
        .property-row input, .property-row select {
            flex: 1;
            background: var(--dark);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 5px 6px;
            border-radius: 3px;
            font-size: 11px;
        }
        .property-row textarea {
            flex: 1;
            background: var(--dark);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 5px 6px;
            border-radius: 3px;
            font-size: 11px;
            resize: vertical;
            min-height: 60px;
        }
        .property-row button {
            background: var(--dark);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 3px 6px;
            margin-left: 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: background 0.2s;
        }
        .property-row button:hover {
            background: var(--accent);
            color: #000;
        }
        #layer-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        #layer-controls button {
            flex: 1;
            padding: 5px;
            font-size: 10px;
            background: var(--dark);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #layer-controls button:hover {
            background: var(--accent);
            color: #000;
        }
        #json-section {
            border-top: 1px solid var(--border);
            padding: 10px;
            background: var(--dark);
        }
        #json-section textarea {
            width: 100%;
            height: 150px;
            background: var(--dark);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 10px;
            resize: none;
        }
        #json-section button {
            width: 100%;
            margin-top: 8px;
            padding: 6px;
            background: var(--light);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #json-section button:hover {
            background: var(--accent);
            color: #000;
        }
        #help-toggle {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: var(--blue);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: background 0.2s;
            z-index: 10;
        }
        #help-toggle:hover {
            background: var(--accent);
        }
        #help-content {
            position: absolute;
            bottom: 50px;
            right: 10px;
            background: var(--dark);
            border: 1px solid var(--border);
            padding: 10px;
            border-radius: 3px;
            max-width: 300px;
            font-size: 10px;
            display: none;
            z-index: 100;
        }
        #help-content ul {
            margin: 5px 0;
            padding-left: 15px;
        }
        #no-selection {
            text-align: center;
            color: var(--text-dim);
            font-size: 12px;
            padding: 40px 20px;
        }
        button.delete-btn {
            background: var(--red) !important;
            color: white !important;
            flex: 1;
            margin-left: 0;
            margin-top: 10px;
        }
        button.delete-btn:hover {
            background: #c53b30 !important;
        }
        @media (max-width: 768px) {
            #hierarchy { width: 200px; }
            #inspector { width: 250px; }
            #toolbar { padding: 0 5px; }
            #toolbar button { padding: 2px 4px; font-size: 10px; margin: 0 1px; }
            .property-row label { width: 50px; }
            .object-item { font-size: 10px; padding: 4px 6px; }
        }
        @media (max-width: 600px) {
            #main-container { flex-direction: column; }
            #hierarchy, #inspector { width: 100%; height: 200px; }
            #scene-view { flex: 1; height: calc(100vh - 40px - 400px); }
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <div class="section">
            <button id="load-json"><i class="fas fa-upload"></i> Load</button>
            <button id="save-json"><i class="fas fa-download"></i> Save</button>
            <button id="clear-map"><i class="fas fa-trash"></i> Clear</button>
            <button id="reset-map"><i class="fas fa-sync-alt"></i> Reset</button>
            <button id="toggle-debug"><i class="fas fa-bug"></i> Debug</button>
        </div>
        <div id="status-icon"><i class="fas fa-pause-circle" style="display:none; color: var(--yellow);"></i></div>
    </div>
    <div id="main-container">
        <div id="hierarchy">
            <div id="hierarchy-header"><i class="fas fa-list"></i> Hierarchy</div>
            <div id="objects-list"></div>
        </div>
        <div id="scene-view">
            <canvas id="canvas"></canvas>
        </div>
        <div id="inspector">
            <div id="inspector-header"><i class="fas fa-cog"></i> Inspector</div>
            <div id="inspector-content">
                <div id="no-selection">Select an object</div>
                <div id="properties" style="display: none;">
                    <!-- Dynamic properties here -->
                </div>
            </div>
            <div id="json-section">
                <textarea id="json-out" placeholder="JSON will appear here..."></textarea>
                <button id="copy-json"><i class="fas fa-copy"></i> Copy</button>
            </div>
        </div>
    </div>
    <button id="help-toggle" title="Help"><i class="fas fa-question-circle"></i></button>
    <div id="help-content">
        <strong>Instructions:</strong>
        <ul>
            <li>Click objects in hierarchy or scene to select.</li>
            <li>Drag in scene to move.</li>
            <li>Edit properties in Inspector.</li>
            <li>Use toolbar for load/save.</li>
            <li>Shift+Drag to pan, Wheel to zoom (pinch on mobile).</li>
            <li>Backspace to delete selected.</li>
            <li>Ctrl+Z/Y for undo/redo.</li>
            <li>Ctrl+C/V for copy/paste.</li>
        </ul>
    </div>
    <script>
        let db;
        const DB_NAME = 'FKMapEditor';
        const DB_VERSION = 1;
        const STORE_NAME = 'maps';
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                request.onupgradeneeded = (e) => {
                    db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }
        async function saveToDB(data) {
            if (!db) return;
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            await store.put({ id: 'current', data: JSON.stringify(data) });
        }
        async function loadFromDB() {
            if (!db) return null;
            const tx = db.transaction(STORE_NAME, 'readonly');
            const store = tx.objectStore(STORE_NAME);
            return new Promise((resolve) => {
                const req = store.get('current');
                req.onsuccess = () => resolve(req.result ? JSON.parse(req.result.data) : null);
                req.onerror = () => resolve(null);
            });
        }
        let history = [];
        let historyIndex = -1;
        function saveState() {
            const state = {
                objects: JSON.parse(JSON.stringify(objects)),
                player: JSON.parse(JSON.stringify(player)),
                selected: selected ? (selected === 'player' ? 'player' : selected.id) : null
            };
            if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
            history.push(state);
            historyIndex++;
            if (history.length > 20) {
                history.shift();
                historyIndex--;
            }
        }
        let isHelpOpen = false;
        const helpToggle = document.getElementById("help-toggle");
        const helpContent = document.getElementById("help-content");
        helpToggle.addEventListener("click", () => {
            isHelpOpen = !isHelpOpen;
            helpContent.style.display = isHelpOpen ? "block" : "none";
        });
        let paused = false;
        function updateStatus() {
            document.getElementById("status-icon").querySelector("i").style.display = paused ? "inline" : "none";
        }
        const sidebarElements = document.querySelectorAll('#hierarchy input, #hierarchy select, #hierarchy button, #inspector input, #inspector select, #inspector button');
        sidebarElements.forEach(el => {
            el.addEventListener('focusin', () => { paused = true; updateStatus(); });
            el.addEventListener('focusout', () => { paused = false; updateStatus(); });
        });
        const uiElements = document.querySelectorAll('#toolbar, #hierarchy, #inspector, #help-toggle, #help-content');
        uiElements.forEach(el => {
            el.addEventListener('mouseenter', () => { paused = true; updateStatus(); });
            el.addEventListener('mouseleave', () => { paused = false; updateStatus(); });
        });
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        ctx.imageSmoothingEnabled = false;
        let canvasWidth = window.innerWidth - 550;
        let canvasHeight = window.innerHeight - 40;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        let camX = 0, camY = 0, isPanning = false, panStartX = 0, panStartY = 0;
        let scale = 1, zoomSpeed = 0.1;
        let debugMode = false;
        let lastTouchDist = 0;
        let objects = [], selected = null, dragging = false, dragOffsetX = 0, dragOffsetY = 0;
        let player = {x: 200, y: 200, w: 50, h: 50, zIndex: 1, angle: 0};
        let clipboard = null;
        const imageCache = new Map();
        const videoCache = new Map();
        const usedIds = new Set(); // For fast ID checking
        class VideoManager {
            constructor() {
                this.activeVideos = new Set();
                this.maxActiveVideos = 4;
            }
            getVideo(src) {
                if (!videoCache.has(src)) {
                    const video = document.createElement('video');
                    video.src = src;
                    video.crossOrigin = "anonymous";
                    video.muted = true;
                    video.playsInline = true;
                    video.preload = "auto";
                    video.loop = true;
                    videoCache.set(src, { video, w: 1, h: 1, loaded: false, isPlaying: false, ready: false });
                    video.addEventListener('loadedmetadata', () => {
                        const cache = videoCache.get(src);
                        if (cache) {
                            cache.w = video.videoWidth;
                            cache.h = video.videoHeight;
                            cache.loaded = true;
                            cache.ready = video.readyState >= 2;
                        }
                    });
                    video.addEventListener('canplay', () => {
                        const cache = videoCache.get(src);
                        if (cache) cache.ready = true;
                    });
                    video.addEventListener('error', () => {
                        const cache = videoCache.get(src);
                        if (cache) cache.ready = false;
                        console.warn('Video load error:', src);
                    });
                }
                return videoCache.get(src);
            }
            playVideo(src) {
                const cache = videoCache.get(src);
                if (!cache || !cache.loaded || !cache.ready) return false;
                if (this.activeVideos.size >= this.maxActiveVideos) {
                    const first = this.activeVideos.values().next().value;
                    if (first) {
                        first.video.pause();
                        first.isPlaying = false;
                        this.activeVideos.delete(first);
                    }
                }
                cache.video.play().catch(e => {
                    console.warn('Video playback failed:', e);
                    cache.isPlaying = false;
                    return false;
                });
                cache.isPlaying = true;
                this.activeVideos.add(cache);
                return true;
            }
            pauseVideo(src) {
                const cache = videoCache.get(src);
                if (cache && cache.isPlaying) {
                    cache.video.pause();
                    cache.isPlaying = false;
                    this.activeVideos.delete(cache);
                }
            }
            isVideoPlaying(src) {
                const cache = videoCache.get(src);
                return cache && cache.isPlaying;
            }
        }
        const videoManager = new VideoManager();
        function generateId() {
            const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            let part1 = "", part2 = "";
            for (let i = 0; i < 12; i++) part1 += chars[Math.floor(Math.random() * chars.length)];
            for (let i = 0; i < 12; i++) part2 += chars[Math.floor(Math.random() * chars.length)];
            return part1 + "-" + part2;
        }
        function updateUsedIds() {
            usedIds.clear();
            objects.forEach(o => {
                if (o.id) usedIds.add(o.id);
            });
        }
        function isIdUnique(id) {
            return id && !usedIds.has(id);
        }
        function setObjectId(obj, newId) {
            if (!newId) {
                obj.id = generateId();
                usedIds.add(obj.id);
                return true;
            }
            if (usedIds.has(newId) && obj.id !== newId) {
                alert(`ID "${newId}" already exists!`);
                return false;
            }
            if (obj.id) usedIds.delete(obj.id);
            obj.id = newId;
            usedIds.add(newId);
            return true;
        }
        function updateHierarchy() {
            updateUsedIds();
            const list = document.getElementById("objects-list");
            list.innerHTML = "";
            objects.forEach((o, index) => {
                const item = document.createElement("div");
                item.className = `object-item ${selected === o ? 'selected' : ''}`;
                const iconMap = {
                    'platform': 'fas fa-square',
                    'wall': 'fas fa-th',
                    'deadly': 'fas fa-skull',
                    'teleporter': 'fas fa-exchange-alt',
                    'jumpPad': 'fas fa-arrow-up',
                    'chest': 'fas fa-box',
                    'respawn': 'fas fa-home',
                    'decor': 'fas fa-star'
                };
                const objType = o.type || 'unknown';
                const iconClass = iconMap[objType] || 'fas fa-cube';
                item.innerHTML = `<span>${objType.toUpperCase()} ${index + 1} ${o.id ? `(${o.id})` : ''}</span><i class="${iconClass} type-icon"></i>`;
                item.addEventListener("click", () => selectObject(o));
                list.appendChild(item);
            });
            const playerItem = document.createElement("div");
            playerItem.className = `object-item ${selected === 'player' ? 'selected' : ''}`;
            playerItem.innerHTML = '<span>PLAYER</span><i class="fas fa-user type-icon"></i>';
            playerItem.addEventListener("click", () => selectObject('player'));
            list.appendChild(playerItem);
        }
        function selectObject(obj) {
            selected = obj === 'player' ? 'player' : obj;
            updateHierarchy();
            updateInspector();
        }
        function updateInspector() {
            const noSel = document.getElementById("no-selection");
            const props = document.getElementById("properties");
            if (selected === null) {
                noSel.style.display = "block";
                props.style.display = "none";
                noSel.textContent = "Select an object";
                return;
            }
            noSel.style.display = "none";
            props.style.display = "block";
            if (selected === 'player') {
                props.innerHTML = `
                    <div class="property-group">
                        <h3>Player Start</h3>
                        <div class="property-row">
                            <label>Position X</label>
                            <input type="number" id="player-x" value="${Math.round(player.x)}">
                        </div>
                        <div class="property-row">
                            <label>Position Y</label>
                            <input type="number" id="player-y" value="${Math.round(player.y)}">
                        </div>
                        <div class="property-row">
                            <label>Rotation</label>
                            <input type="number" id="player-rot" value="${Math.round(player.angle || 0)}">
                        </div>
                        <div class="property-row">
                            <label>Width</label>
                            <input type="number" id="player-w" value="${Math.round(player.w)}">
                        </div>
                        <div class="property-row">
                            <label>Height</label>
                            <input type="number" id="player-h" value="${Math.round(player.h)}">
                        </div>
                        <div class="property-row">
                            <label>Z-Index</label>
                            <input type="number" id="player-z" value="${player.zIndex || 1}">
                        </div>
                    </div>
                `;
                ['player-x', 'player-y', 'player-rot', 'player-w', 'player-h', 'player-z'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.addEventListener("input", () => {
                        if (id === 'player-x') player.x = parseInt(el.value) || 0;
                        if (id === 'player-y') player.y = parseInt(el.value) || 0;
                        if (id === 'player-rot') player.angle = parseFloat(el.value) || 0;
                        if (id === 'player-w') player.w = parseInt(el.value) || 50;
                        if (id === 'player-h') player.h = parseInt(el.value) || 50;
                        if (id === 'player-z') player.zIndex = parseInt(el.value) || 1;
                        saveState();
                        updateJSON();
                        draw();
                    });
                });
                return;
            }
            const oldType = selected.type || 'platform';
            let extraTeleportHTML = '';
            if (selected.type === 'teleporter') {
                extraTeleportHTML = `
                    <div class="property-group">
                        <h3>Teleport</h3>
                        <div class="property-row">
                            <label>Target X</label>
                            <input type="number" id="target-x" value="${selected.targetX || 0}">
                        </div>
                        <div class="property-row">
                            <label>Target Y</label>
                            <input type="number" id="target-y" value="${selected.targetY || 0}">
                        </div>
                        <div class="property-row">
                            <label>Delay (s)</label>
                            <input type="number" id="teleport-delay" step="0.1" value="${selected.teleportDelay || 0}">
                        </div>
                    </div>
                `;
            }
            let extraJumpHTML = '';
            if (selected.type === 'jumpPad') {
                extraJumpHTML = `
                    <div class="property-group">
                        <h3>Jump Pad</h3>
                        <div class="property-row">
                            <label>Boost</label>
                            <input type="number" id="jump-boost" value="${selected.jumpBoost || 800}">
                        </div>
                    </div>
                `;
            }
            let extraChestHTML = '';
            if (selected.type === 'chest') {
                extraChestHTML = `
                    <div class="property-group">
                        <h3>Chest</h3>
                        <div class="property-row">
                            <label>Detection Radius</label>
                            <input type="number" id="chest-radius" value="${selected.detectionRadius || 100}">
                        </div>
                        <div class="property-row">
                            <label>Items (comma-separated)</label>
                            <textarea id="chest-items" placeholder="item1,item2,...">${(selected.items || []).join(',')}</textarea>
                        </div>
                        <div class="property-row">
                            <label>Closed Texture ID</label>
                            <input type="number" id="closed-texture-id" value="${selected.closedTextureId !== undefined ? selected.closedTextureId : 0}">
                        </div>
                        <div class="property-row">
                            <label>Open Texture ID</label>
                            <input type="number" id="open-texture-id" value="${selected.openTextureId !== undefined ? selected.openTextureId : 1}">
                        </div>
                        <div class="property-row">
                            <label>Opening Texture ID</label>
                            <input type="number" id="opening-texture-id" value="${selected.openingTextureId !== undefined ? selected.openingTextureId : 2}">
                        </div>
                        <div class="property-row">
                            <label>Closing Texture ID</label>
                            <input type="number" id="closing-texture-id" value="${selected.closingTextureId !== undefined ? selected.closingTextureId : 3}">
                        </div>
                    </div>
                `;
            }
            let extraRespawnHTML = '';
            if (selected.type === 'respawn') {
                extraRespawnHTML = `
                    <div class="property-group">
                        <h3>Respawn</h3>
                        <div class="property-row">
                            <label>Detection Radius</label>
                            <input type="number" id="respawn-radius" value="${selected.detectionRadius || 1200}">
                        </div>
                        <div class="property-row">
                            <label>Pass Through</label>
                            <input type="checkbox" id="respawn-passthrough" ${selected.passThrough ? 'checked' : ''}>
                        </div>
                        <div class="property-row">
                            <label>Respawn X</label>
                            <input type="number" id="respawn-x" value="${selected.respawnX !== undefined ? selected.respawnX : selected.x}">
                        </div>
                        <div class="property-row">
                            <label>Respawn Y</label>
                            <input type="number" id="respawn-y" value="${selected.respawnY !== undefined ? selected.respawnY : selected.y}">
                        </div>
                        <div class="property-row">
                            <label>Inactive Texture ID</label>
                            <input type="number" id="inactive-texture-id" value="${selected.inactiveTextureId !== undefined ? selected.inactiveTextureId : 0}">
                        </div>
                        <div class="property-row">
                            <label>Active Texture ID</label>
                            <input type="number" id="active-texture-id" value="${selected.activeTextureId !== undefined ? selected.activeTextureId : 1}">
                        </div>
                    </div>
                `;
            }
            let extraParallaxHTML = '';
            if (selected.type === 'decor') {
                extraParallaxHTML = `
                    <div class="property-row">
                        <label>Parallax</label>
                        <input type="number" id="parallax" step="0.1" min="0" max="1" value="${selected.parallaxSpeed || 1}">
                    </div>
                `;
            }
            let idHTML = `
                <div class="property-row">
                    <label>ID</label>
                    <input type="text" id="obj-id" value="${selected.id || ''}" placeholder="Optional unique ID">
                </div>
            `;
            props.innerHTML = `
                <div class="property-group">
                    <h3>Transform</h3>
                    <div class="property-row">
                        <label>Position X</label>
                        <input type="number" id="pos-x" value="${Math.round(selected.x)}">
                    </div>
                    <div class="property-row">
                        <label>Position Y</label>
                        <input type="number" id="pos-y" value="${Math.round(selected.y)}">
                    </div>
                    <div class="property-row">
                        <label>Rotation</label>
                        <input type="number" id="rot" value="${Math.round(selected.angle || 0)}">
                    </div>
                </div>
                <div class="property-group">
                    <h3>Shape</h3>
                    <div class="property-row">
                        <label>Width</label>
                        <input type="number" id="width" value="${Math.round(selected.w)}">
                    </div>
                    <div class="property-row">
                        <label>Height</label>
                        <input type="number" id="height" value="${Math.round(selected.h)}">
                    </div>
                </div>
                <div class="property-group">
                    <h3>Object</h3>
                    ${idHTML}
                    <div class="property-row">
                        <label>Type</label>
                        <select id="type">
                            <option value="platform" ${oldType === 'platform' ? 'selected' : ''}>Platform</option>
                            <option value="wall" ${oldType === 'wall' ? 'selected' : ''}>Wall</option>
                            <option value="deadly" ${oldType === 'deadly' ? 'selected' : ''}>Deadly</option>
                            <option value="teleporter" ${oldType === 'teleporter' ? 'selected' : ''}>Teleporter</option>
                            <option value="jumpPad" ${oldType === 'jumpPad' ? 'selected' : ''}>Jump Pad</option>
                            <option value="chest" ${oldType === 'chest' ? 'selected' : ''}>Chest</option>
                            <option value="respawn" ${oldType === 'respawn' ? 'selected' : ''}>Respawn</option>
                            <option value="decor" ${oldType === 'decor' ? 'selected' : ''}>Decor</option>
                        </select>
                    </div>
                    <div class="property-row">
                        <label>Z-Index</label>
                        <input type="number" id="z-index" value="${selected.zIndex || 0}">
                    </div>
                    ${extraParallaxHTML}
                </div>
                <div class="property-group">
                    <h3>Texture</h3>
                    <div class="property-row">
                        <label>URL</label>
                        <input type="text" id="texture-url" value="${selected.texture || ''}" placeholder="Enter URL">
                    </div>
                </div>
                ${extraTeleportHTML}
                ${extraJumpHTML}
                ${extraChestHTML}
                ${extraRespawnHTML}
                <div id="layer-controls">
                    <button id="to-front"><i class="fas fa-arrow-up"></i></button>
                    <button id="to-back"><i class="fas fa-arrow-down"></i></button>
                    <button id="up"><i class="fas fa-chevron-up"></i></button>
                    <button id="down"><i class="fas fa-chevron-down"></i></button>
                </div>
                <div class="property-row">
                    <button class="delete-btn" id="delete-obj"><i class="fas fa-trash"></i> Delete</button>
                </div>
            `;
            // Event listeners for common fields
            ['pos-x', 'pos-y', 'rot', 'width', 'height', 'z-index', 'parallax', 'texture-url', 'target-x', 'target-y', 'teleport-delay', 'jump-boost', 'chest-radius', 'respawn-radius', 'respawn-x', 'respawn-y', 'closed-texture-id', 'open-texture-id', 'opening-texture-id', 'closing-texture-id', 'inactive-texture-id', 'active-texture-id'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener("input", () => {
                    applyInspectorChanges();
                    saveState();
                });
            });
            const chestItemsEl = document.getElementById("chest-items");
            if (chestItemsEl) chestItemsEl.addEventListener("input", () => {
                applyInspectorChanges();
                saveState();
            });
            const respawnPassEl = document.getElementById("respawn-passthrough");
            if (respawnPassEl) respawnPassEl.addEventListener("change", () => {
                applyInspectorChanges();
                saveState();
            });
            // ID field listener
            const idEl = document.getElementById("obj-id");
            if (idEl) {
                idEl.addEventListener("input", (e) => {
                    if (setObjectId(selected, e.target.value)) {
                        updateHierarchy();
                        updateJSON();
                    } else {
                        e.target.value = selected.id || '';
                    }
                    saveState();
                });
            }
            const typeEl = document.getElementById("type");
            if (typeEl) {
                typeEl.addEventListener("change", (e) => {
                    const newType = e.target.value;
                    if (newType !== oldType) {
                        selected.type = newType;
                        if (newType === 'decor' && selected.parallaxSpeed === undefined) selected.parallaxSpeed = 1;
                        if (newType === 'teleporter') {
                            if (selected.targetX === undefined) selected.targetX = 0;
                            if (selected.targetY === undefined) selected.targetY = 0;
                            if (selected.teleportDelay === undefined) selected.teleportDelay = 0;
                        }
                        if (newType === 'jumpPad') {
                            if (selected.jumpBoost === undefined) selected.jumpBoost = 800;
                        }
                        if (newType === 'chest') {
                            if (selected.detectionRadius === undefined) selected.detectionRadius = 100;
                            if (selected.items === undefined) selected.items = [];
                            if (selected.closedTextureId === undefined) selected.closedTextureId = 0;
                            if (selected.openTextureId === undefined) selected.openTextureId = 1;
                            if (selected.openingTextureId === undefined) selected.openingTextureId = 2;
                            if (selected.closingTextureId === undefined) selected.closingTextureId = 3;
                        }
                        if (newType === 'respawn') {
                            if (selected.detectionRadius === undefined) selected.detectionRadius = 1200;
                            if (selected.passThrough === undefined) selected.passThrough = false;
                            if (selected.respawnX === undefined) selected.respawnX = selected.x;
                            if (selected.respawnY === undefined) selected.respawnY = selected.y;
                            if (selected.inactiveTextureId === undefined) selected.inactiveTextureId = 0;
                            if (selected.activeTextureId === undefined) selected.activeTextureId = 1;
                        }
                        updateInspector();
                        saveState();
                    }
                    applyInspectorChanges();
                });
            }
            document.getElementById("to-front").addEventListener("click", () => {
                selected.zIndex = getMaxZIndex() + 1;
                updateInspector();
                draw();
                saveState();
            });
            document.getElementById("to-back").addEventListener("click", () => {
                selected.zIndex = getMinZIndex() - 1;
                updateInspector();
                draw();
                saveState();
            });
            document.getElementById("up").addEventListener("click", () => {
                selected.zIndex = (selected.zIndex || 0) + 1;
                updateInspector();
                draw();
                saveState();
            });
            document.getElementById("down").addEventListener("click", () => {
                selected.zIndex = (selected.zIndex || 0) - 1;
                updateInspector();
                draw();
                saveState();
            });
            document.getElementById("delete-obj").addEventListener("click", () => {
                objects = objects.filter(o => o !== selected);
                selected = null;
                updateHierarchy();
                updateInspector();
                draw();
                updateJSON();
                saveState();
            });
        }
        function applyInspectorChanges() {
            if (!selected || selected === 'player') return;
            selected.x = parseInt(document.getElementById("pos-x").value) || 0;
            selected.y = parseInt(document.getElementById("pos-y").value) || 0;
            selected.angle = parseFloat(document.getElementById("rot").value) || 0;
            selected.w = parseInt(document.getElementById("width").value) || 10;
            selected.h = parseInt(document.getElementById("height").value) || 10;
            selected.zIndex = parseInt(document.getElementById("z-index").value) || 0;
            const parallaxEl = document.getElementById("parallax");
            if (parallaxEl) selected.parallaxSpeed = parseFloat(parallaxEl.value) || 1;
            const targetXEl = document.getElementById("target-x");
            if (targetXEl) selected.targetX = parseInt(targetXEl.value) || 0;
            const targetYEl = document.getElementById("target-y");
            if (targetYEl) selected.targetY = parseInt(targetYEl.value) || 0;
            const delayEl = document.getElementById("teleport-delay");
            if (delayEl) selected.teleportDelay = parseFloat(delayEl.value) || 0;
            const boostEl = document.getElementById("jump-boost");
            if (boostEl) selected.jumpBoost = parseInt(boostEl.value) || 800;
            const chestRadiusEl = document.getElementById("chest-radius");
            if (chestRadiusEl) selected.detectionRadius = parseInt(chestRadiusEl.value) || 100;
            const chestItemsEl = document.getElementById("chest-items");
            if (chestItemsEl) selected.items = chestItemsEl.value.split(',').map(s => s.trim()).filter(s => s);
            const respawnRadiusEl = document.getElementById("respawn-radius");
            if (respawnRadiusEl) selected.detectionRadius = parseInt(respawnRadiusEl.value) || 1200;
            const respawnPassEl = document.getElementById("respawn-passthrough");
            if (respawnPassEl) selected.passThrough = respawnPassEl.checked;
            const respawnXEl = document.getElementById("respawn-x");
            if (respawnXEl) selected.respawnX = parseInt(respawnXEl.value) || selected.x;
            const respawnYEl = document.getElementById("respawn-y");
            if (respawnYEl) selected.respawnY = parseInt(respawnYEl.value) || selected.y;
            const closedTexEl = document.getElementById("closed-texture-id");
            if (closedTexEl) selected.closedTextureId = parseInt(closedTexEl.value) || 0;
            const openTexEl = document.getElementById("open-texture-id");
            if (openTexEl) selected.openTextureId = parseInt(openTexEl.value) || 1;
            const openingTexEl = document.getElementById("opening-texture-id");
            if (openingTexEl) selected.openingTextureId = parseInt(openingTexEl.value) || 2;
            const closingTexEl = document.getElementById("closing-texture-id");
            if (closingTexEl) selected.closingTextureId = parseInt(closingTexEl.value) || 3;
            const inactiveTexEl = document.getElementById("inactive-texture-id");
            if (inactiveTexEl) selected.inactiveTextureId = parseInt(inactiveTexEl.value) || 0;
            const activeTexEl = document.getElementById("active-texture-id");
            if (activeTexEl) selected.activeTextureId = parseInt(activeTexEl.value) || 1;
            selected.texture = document.getElementById("texture-url").value || null;
            if (selected.type !== 'decor') delete selected.parallaxSpeed;
            draw();
            updateJSON();
            updateHierarchy();
        }
        function draw() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(scale, scale);
            ctx.translate(-camX, -camY);
            const sortedObjects = objects.slice().sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
            sortedObjects.forEach(o => {
                let angle = Math.round(o.angle || 0) % 360;
                const w = Math.round(o.w);
                const h = Math.round(o.h);
                let px = Math.round(o.x);
                let py = Math.round(o.y);
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(angle * Math.PI / 180);
                if (o.texture) {
                    if (o.texture.match(/\.(webm|mp4)$/i)) {
                        const videoData = videoManager.getVideo(o.texture);
                        if (videoData && videoData.ready) {
                            const isInView = px + w / 2 >= camX && px - w / 2 <= camX + canvas.width / scale && py + h / 2 >= camY && py - h / 2 <= camY + canvas.height / scale;
                            if (isInView && !videoManager.isVideoPlaying(o.texture)) videoManager.playVideo(o.texture);
                            else if (!isInView && videoManager.isVideoPlaying(o.texture)) videoManager.pauseVideo(o.texture);
                            if (videoManager.isVideoPlaying(o.texture)) ctx.drawImage(videoData.video, -w / 2, -h / 2, w, h);
                            else {
                                ctx.fillStyle = "#888";
                                ctx.fillRect(-w / 2, -h / 2, w, h);
                            }
                        } else {
                            ctx.fillStyle = "#888";
                            ctx.fillRect(-w / 2, -h / 2, w, h);
                        }
                    } else {
                        if (!imageCache.has(o.texture)) {
                            const img = new Image();
                            img.src = o.texture;
                            img.crossOrigin = "anonymous";
                            img.onload = () => draw();
                            img.onerror = () => console.warn("Broken image:", o.texture);
                            imageCache.set(o.texture, img);
                        }
                        const img = imageCache.get(o.texture);
                        if (img && img.complete && img.naturalWidth > 0) ctx.drawImage(img, -w / 2, -h / 2, w, h);
                        else {
                            ctx.fillStyle = "#888";
                            ctx.fillRect(-w / 2, -h / 2, w, h);
                        }
                    }
                } else {
                    let color;
                    const objType = o.type || 'platform';
                    switch (objType) {
                        case "platform": color = "#654321"; break;
                        case "wall": color = "#444"; break;
                        case "deadly": color = "#f00"; break;
                        case "teleporter": color = "#00f"; break;
                        case "jumpPad": color = "#0f0"; break;
                        case "chest": color = "#8B4513"; break;
                        case "respawn": color = "#FFD700"; break;
                        case "decor": color = "#880088"; break;
                        default: color = "#654321";
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(-w / 2, -h / 2, w, h);
                }
                if (o === selected) {
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.fillRect(-w / 2, -h / 2, w, h);
                }
                if (debugMode) {
                    let strokeColor;
                    const objType = o.type || 'platform';
                    switch (objType) {
                        case "platform": strokeColor = "yellow"; break;
                        case "wall": strokeColor = "red"; break;
                        case "deadly": strokeColor = "red"; break;
                        case "teleporter": strokeColor = "blue"; break;
                        case "jumpPad": strokeColor = "lime"; break;
                        case "chest": strokeColor = "brown"; break;
                        case "respawn": strokeColor = "gold"; break;
                        case "decor": strokeColor = "purple"; break;
                        default: strokeColor = "yellow";
                    }
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1 / scale;
                    ctx.strokeRect(-w / 2, -h / 2, w, h);
                }
                ctx.restore();
            });
            const pw = Math.round(player.w);
            const ph = Math.round(player.h);
            const px = Math.round(player.x);
            const py = Math.round(player.y);
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate((player.angle || 0) * Math.PI / 180);
            ctx.fillStyle = "lime";
            ctx.fillRect(-pw / 2, -ph / 2, pw, ph);
            if (selected === 'player') {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.fillRect(-pw / 2, -ph / 2, pw, ph);
            }
            ctx.strokeStyle = "#0ff";
            ctx.lineWidth = 2 / scale;
            ctx.strokeRect(-pw / 2, -ph / 2, pw, ph);
            if (debugMode) {
                ctx.strokeStyle = "green";
                ctx.lineWidth = 1 / scale;
                ctx.strokeRect(-pw / 2, -ph / 2, pw, ph);
            }
            ctx.fillStyle = "#fff";
            ctx.font = `${12 / scale}px monospace`;
            ctx.textAlign = "center";
            ctx.fillText("PLAYER", 0, -ph / 2 - 4 / scale);
            ctx.restore();
            ctx.restore();
        }
        async function updateJSON() {
            updateUsedIds();
            const textures = [];
            objects.forEach(o => {
                if (o.texture && !textures.includes(o.texture)) textures.push(o.texture);
            });
            const platforms = objects.filter(o => o.type !== "decor").map(o => {
                let platObj = {
                    id: o.id || generateId(),
                    type: o.type || 'platform',
                    x: Math.round(o.x),
                    y: Math.round(o.y),
                    w: Math.round(o.w),
                    h: Math.round(o.h),
                    angle: Math.round(o.angle || 0),
                    textureId: o.texture ? textures.indexOf(o.texture) : null,
                    zIndex: o.zIndex || 0
                };
                if (o.type === 'teleporter') {
                    platObj.targetX = o.targetX || 0;
                    platObj.targetY = o.targetY || 0;
                    platObj.teleportDelay = o.teleportDelay || 0;
                }
                if (o.type === 'jumpPad') {
                    platObj.jumpBoost = o.jumpBoost || 800;
                }
                if (o.type === 'chest') {
                    platObj.detectionRadius = o.detectionRadius || 100;
                    platObj.items = o.items || [];
                    platObj.closedTextureId = o.closedTextureId !== undefined ? o.closedTextureId : 0;
                    platObj.openTextureId = o.openTextureId !== undefined ? o.openTextureId : 1;
                    platObj.openingTextureId = o.openingTextureId !== undefined ? o.openingTextureId : 2;
                    platObj.closingTextureId = o.closingTextureId !== undefined ? o.closingTextureId : 3;
                }
                if (o.type === 'respawn') {
                    platObj.detectionRadius = o.detectionRadius || 1200;
                    platObj.passThrough = o.passThrough || false;
                    platObj.respawnX = o.respawnX !== undefined ? o.respawnX : o.x;
                    platObj.respawnY = o.respawnY !== undefined ? o.respawnY : o.y;
                    platObj.inactiveTextureId = o.inactiveTextureId !== undefined ? o.inactiveTextureId : 0;
                    platObj.activeTextureId = o.activeTextureId !== undefined ? o.activeTextureId : 1;
                }
                return platObj;
            });
            const decor = objects.filter(o => o.type === "decor").map(o => ({
                id: o.id || generateId(),
                x: Math.round(o.x),
                y: Math.round(o.y),
                w: Math.round(o.w),
                h: Math.round(o.h),
                angle: Math.round(o.angle || 0),
                textureId: o.texture ? textures.indexOf(o.texture) : null,
                zIndex: o.zIndex || 0,
                parallaxSpeed: o.parallaxSpeed || 1
            }));
            const json = {
                playerStart: {
                    x: Math.round(player.x),
                    y: Math.round(player.y),
                    w: Math.round(player.w),
                    h: Math.round(player.h),
                    zIndex: player.zIndex,
                    angle: player.angle || 0
                },
                textures,
                platforms,
                decor
            };
            document.getElementById("json-out").value = JSON.stringify(json, null, 2);
            await saveToDB(json);
        }
        function pointInRotatedRect(px, py, o) {
            const rad = -(o.angle || 0) * Math.PI / 180;
            const dx = px - o.x;
            const dy = py - o.y;
            const localX = dx * Math.cos(rad) - dy * Math.sin(rad);
            const localY = dx * Math.sin(rad) + dy * Math.cos(rad);
            return localX >= -o.w / 2 && localX <= o.w / 2 && localY >= -o.h / 2 && localY <= o.h / 2;
        }
        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return {
                x: (clientX - rect.left) / scale + camX,
                y: (clientY - rect.top) / scale + camY
            };
        }
        canvas.addEventListener("touchstart", e => {
            if (paused) return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const x = coords.x;
            const y = coords.y;
            if (e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastTouchDist = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
                return;
            }
            if (e.touches.length > 1) {
                isPanning = true;
                panStartX = e.touches[0].clientX;
                panStartY = e.touches[0].clientY;
                return;
            }
            let clicked = null;
            const playerCopy = { ...player, id: 'player-temp', type: 'player', isPlayer: true };
            let all = [...objects, playerCopy];
            const sorted = all.slice().sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
            for (let o of sorted) {
                if (pointInRotatedRect(x, y, o)) {
                    clicked = o.isPlayer ? 'player' : o;
                    break;
                }
            }
            if (clicked) {
                selectObject(clicked);
                dragging = true;
                const sel = clicked === 'player' ? player : clicked;
                dragOffsetX = x - sel.x;
                dragOffsetY = y - sel.y;
            } else {
                selected = {
                    x, y, w: 100, h: 20, angle: 0, texture: null, type: "platform",
                    zIndex: getMaxZIndex() + 1, id: generateId()
                };
                setObjectId(selected, selected.id);
                objects.push(selected);
                dragging = true;
                dragOffsetX = 0;
                dragOffsetY = 0;
            }
            updateHierarchy();
            updateInspector();
            draw();
        }, { passive: false });
        canvas.addEventListener("touchmove", e => {
            if (paused) return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const x = coords.x;
            const y = coords.y;
            if (e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const dist = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
                if (lastTouchDist > 0) {
                    const delta = dist / lastTouchDist;
                    const rect = canvas.getBoundingClientRect();
                    const mx = ((touch1.clientX + touch2.clientX) / 2 - rect.left) / scale + camX;
                    const my = ((touch1.clientY + touch2.clientY) / 2 - rect.top) / scale + camY;
                    scale *= delta;
                    scale = Math.min(Math.max(scale, 0.2), 5);
                    camX = mx - ((touch1.clientX + touch2.clientX) / 2 - rect.left) / scale;
                    camY = my - ((touch1.clientY + touch2.clientY) / 2 - rect.top) / scale;
                }
                lastTouchDist = dist;
                draw();
                return;
            }
            if (isPanning) {
                const clientX = e.touches[0].clientX;
                const clientY = e.touches[0].clientY;
                camX -= (clientX - panStartX) / scale;
                camY -= (clientY - panStartY) / scale;
                panStartX = clientX;
                panStartY = clientY;
                draw();
            } else if (dragging && selected) {
                const sel = selected === 'player' ? player : selected;
                sel.x = Math.round(x - dragOffsetX);
                sel.y = Math.round(y - dragOffsetY);
                if (selected !== 'player') updateInspector();
                draw();
            }
        }, { passive: false });
        canvas.addEventListener("touchend", e => {
            e.preventDefault();
            dragging = false;
            isPanning = false;
            lastTouchDist = 0;
            if (selected && selected !== 'player') saveState();
        });
        canvas.addEventListener("mousedown", e => {
            if (paused) return;
            const coords = getEventCoords(e);
            const x = coords.x;
            const y = coords.y;
            if (e.shiftKey) {
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                return;
            }
            let clicked = null;
            const playerCopy = { ...player, id: 'player-temp', type: 'player', isPlayer: true };
            let all = [...objects, playerCopy];
            const sorted = all.slice().sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
            for (let o of sorted) {
                if (pointInRotatedRect(x, y, o)) {
                    clicked = o.isPlayer ? 'player' : o;
                    break;
                }
            }
            if (clicked) {
                selectObject(clicked);
                dragging = true;
                const sel = clicked === 'player' ? player : clicked;
                dragOffsetX = x - sel.x;
                dragOffsetY = y - sel.y;
            } else {
                selected = {
                    x, y, w: 100, h: 20, angle: 0, texture: null, type: "platform",
                    zIndex: getMaxZIndex() + 1, id: generateId()
                };
                setObjectId(selected, selected.id);
                objects.push(selected);
                dragging = true;
                dragOffsetX = 0;
                dragOffsetY = 0;
            }
            saveState();
            updateHierarchy();
            updateInspector();
            draw();
        });
        canvas.addEventListener("mousemove", e => {
            if (paused) return;
            const coords = getEventCoords(e);
            const x = coords.x;
            const y = coords.y;
            if (isPanning) {
                camX -= (e.clientX - panStartX) / scale;
                camY -= (e.clientY - panStartY) / scale;
                panStartX = e.clientX;
                panStartY = e.clientY;
                draw();
            } else if (dragging && selected) {
                const sel = selected === 'player' ? player : selected;
                sel.x = Math.round(x - dragOffsetX);
                sel.y = Math.round(y - dragOffsetY);
                if (selected !== 'player') updateInspector();
                draw();
            }
        });
        canvas.addEventListener("mouseup", () => {
            dragging = false;
            isPanning = false;
        });
        canvas.addEventListener("wheel", e => {
            if (paused) return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const mx = coords.x;
            const my = coords.y;
            const zoom = e.deltaY < 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
            scale *= zoom;
            scale = Math.min(Math.max(scale, 0.2), 5);
            camX = mx - (e.clientX - canvas.getBoundingClientRect().left) / scale;
            camY = my - (e.clientY - canvas.getBoundingClientRect().top) / scale;
            draw();
        });
        window.addEventListener("keydown", e => {
            if (paused) return;
            if (e.ctrlKey) {
                if (e.key === "z") {
                    if (historyIndex > 0) {
                        historyIndex--;
                        const state = history[historyIndex];
                        objects = state.objects;
                        player = state.player;
                        if (state.selected === 'player') selected = 'player';
                        else selected = objects.find(o => o.id === state.selected) || null;
                        updateHierarchy();
                        updateInspector();
                        updateJSON();
                        draw();
                    }
                    e.preventDefault();
                    return;
                }
                if (e.key === "y") {
                    if (historyIndex < history.length - 1) {
                        historyIndex++;
                        const state = history[historyIndex];
                        objects = state.objects;
                        player = state.player;
                        if (state.selected === 'player') selected = 'player';
                        else selected = objects.find(o => o.id === state.selected) || null;
                        updateHierarchy();
                        updateInspector();
                        updateJSON();
                        draw();
                    }
                    e.preventDefault();
                    return;
                }
                if (e.key === "c") {
                    if (selected === 'player') {
                        clipboard = { ...player, type: 'platform' };
                    } else {
                        clipboard = { ...selected };
                    }
                    e.preventDefault();
                    return;
                }
                if (e.key === "v" && clipboard) {
                    const newObj = { ...clipboard, id: generateId(), x: (clipboard.x || player.x) + 20, y: (clipboard.y || player.y) + 20, zIndex: getMaxZIndex() + 1 };
                    if (!newObj.type) newObj.type = 'platform';
                    if (newObj.type === 'decor' && newObj.parallaxSpeed === undefined) newObj.parallaxSpeed = 1;
                    if (newObj.type === 'teleporter') {
                        if (newObj.targetX === undefined) newObj.targetX = 0;
                        if (newObj.targetY === undefined) newObj.targetY = 0;
                        if (newObj.teleportDelay === undefined) newObj.teleportDelay = 0;
                    }
                    if (newObj.type === 'jumpPad') {
                        if (newObj.jumpBoost === undefined) newObj.jumpBoost = 800;
                    }
                    if (newObj.type === 'chest') {
                        if (newObj.detectionRadius === undefined) newObj.detectionRadius = 100;
                        if (newObj.items === undefined) newObj.items = [];
                        if (newObj.closedTextureId === undefined) newObj.closedTextureId = 0;
                        if (newObj.openTextureId === undefined) newObj.openTextureId = 1;
                        if (newObj.openingTextureId === undefined) newObj.openingTextureId = 2;
                        if (newObj.closingTextureId === undefined) newObj.closingTextureId = 3;
                    }
                    if (newObj.type === 'respawn') {
                        if (newObj.detectionRadius === undefined) newObj.detectionRadius = 1200;
                        if (newObj.passThrough === undefined) newObj.passThrough = false;
                        if (newObj.respawnX === undefined) newObj.respawnX = newObj.x;
                        if (newObj.respawnY === undefined) newObj.respawnY = newObj.y;
                        if (newObj.inactiveTextureId === undefined) newObj.inactiveTextureId = 0;
                        if (newObj.activeTextureId === undefined) newObj.activeTextureId = 1;
                    }
                    setObjectId(newObj, newObj.id);
                    objects.push(newObj);
                    selectObject(newObj);
                    saveState();
                    updateJSON();
                    draw();
                    e.preventDefault();
                    return;
                }
            }
            if (e.key === "Backspace") {
                if (selected === 'player') return;
                objects = objects.filter(o => o !== selected);
                selected = null;
                saveState();
                updateHierarchy();
                updateInspector();
                updateJSON();
                draw();
                e.preventDefault();
                return;
            }
            const moveAmount = e.shiftKey ? 10 : 1;
            if (selected === 'player') {
                switch (e.key) {
                    case "ArrowLeft": player.x -= moveAmount; break;
                    case "ArrowRight": player.x += moveAmount; break;
                    case "ArrowUp": player.y -= moveAmount; break;
                    case "ArrowDown": player.y += moveAmount; break;
                }
                saveState();
                updateJSON();
                draw();
            } else if (selected) {
                switch (e.key) {
                    case "ArrowLeft": selected.x -= moveAmount; break;
                    case "ArrowRight": selected.x += moveAmount; break;
                    case "ArrowUp": selected.y -= moveAmount; break;
                    case "ArrowDown": selected.y += moveAmount; break;
                }
                saveState();
                updateInspector();
                updateJSON();
                draw();
            }
        });
        document.getElementById("load-json").addEventListener("click", () => {
            const jsonIn = prompt("Paste JSON:");
            if (jsonIn) {
                try {
                    const data = JSON.parse(jsonIn);
                    player = {
                        x: data.playerStart.x,
                        y: data.playerStart.y,
                        w: data.playerStart.w,
                        h: data.playerStart.h,
                        zIndex: data.playerStart.zIndex || 1,
                        angle: data.playerStart.angle || 0
                    };
                    objects = [];
                    (data.platforms || []).forEach(p => {
                        const obj = { ...p, type: p.type || 'platform', texture: data.textures?.[p.textureId] || null };
                        if (p.type === 'teleporter') {
                            obj.targetX = p.targetX || 0;
                            obj.targetY = p.targetY || 0;
                            obj.teleportDelay = p.teleportDelay || 0;
                        }
                        if (p.type === 'jumpPad') {
                            obj.jumpBoost = p.jumpBoost || 800;
                        }
                        if (p.type === 'chest') {
                            obj.detectionRadius = p.detectionRadius || 100;
                            obj.items = p.items || [];
                            obj.closedTextureId = p.closedTextureId !== undefined ? p.closedTextureId : 0;
                            obj.openTextureId = p.openTextureId !== undefined ? p.openTextureId : 1;
                            obj.openingTextureId = p.openingTextureId !== undefined ? p.openingTextureId : 2;
                            obj.closingTextureId = p.closingTextureId !== undefined ? p.closingTextureId : 3;
                        }
                        if (p.type === 'respawn') {
                            obj.detectionRadius = p.detectionRadius || 1200;
                            obj.passThrough = p.passThrough || false;
                            obj.respawnX = p.respawnX !== undefined ? p.respawnX : p.x;
                            obj.respawnY = p.respawnY !== undefined ? p.respawnY : p.y;
                            obj.inactiveTextureId = p.inactiveTextureId !== undefined ? p.inactiveTextureId : 0;
                            obj.activeTextureId = p.activeTextureId !== undefined ? p.activeTextureId : 1;
                        }
                        objects.push(obj);
                    });
                    (data.decor || []).forEach(d => {
                        const obj = { ...d, type: 'decor', texture: data.textures?.[d.textureId] || null, parallaxSpeed: d.parallaxSpeed || 1 };
                        objects.push(obj);
                    });
                    updateUsedIds();
                    selected = null;
                    history = [];
                    historyIndex = -1;
                    updateHierarchy();
                    updateInspector();
                    updateJSON();
                    draw();
                } catch (err) {
                    alert("Invalid JSON");
                }
            }
        });
        document.getElementById("save-json").addEventListener("click", () => {
            navigator.clipboard.writeText(document.getElementById("json-out").value);
            alert("JSON copied to clipboard");
        });
        document.getElementById("clear-map").addEventListener("click", () => {
            if (confirm("Clear all?")) {
                objects = [];
                selected = null;
                history = [];
                historyIndex = -1;
                updateHierarchy();
                updateInspector();
                updateJSON();
                draw();
            }
        });
        document.getElementById("reset-map").addEventListener("click", () => {
            if (confirm("Reset to default?")) {
                objects = [];
                player = {x: 200, y: 200, w: 50, h: 50, zIndex: 1, angle: 0};
                selected = null;
                history = [];
                historyIndex = -1;
                updateHierarchy();
                updateInspector();
                updateJSON();
                draw();
            }
        });
        document.getElementById("toggle-debug").addEventListener("click", () => {
            debugMode = !debugMode;
            document.getElementById("toggle-debug").innerHTML = `<i class="fas fa-${debugMode ? 'check' : 'times'}-circle"></i> ${debugMode ? 'Debug On' : 'Debug Off'}`;
            draw();
        });
        document.getElementById("copy-json").addEventListener("click", () => {
            navigator.clipboard.writeText(document.getElementById("json-out").value);
            alert("Copied!");
        });
        function getMaxZIndex() {
            return objects.length > 0 ? Math.max(...objects.map(o => o.zIndex || 0)) : 0;
        }
        function getMinZIndex() {
            return objects.length > 0 ? Math.min(...objects.map(o => o.zIndex || 0)) : 0;
        }
        function animate() {
            draw();
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
        window.addEventListener("resize", () => {
            canvasWidth = window.innerWidth - 550;
            canvasHeight = window.innerHeight - 40;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            updateJSON();
            draw();
        });
        openDB().then(async () => {
            const saved = await loadFromDB();
            if (saved) {
                player = {
                    x: saved.playerStart.x,
                    y: saved.playerStart.y,
                    w: saved.playerStart.w,
                    h: saved.playerStart.h,
                    zIndex: saved.playerStart.zIndex || 1,
                    angle: saved.playerStart.angle || 0
                };
                objects = [];
                (saved.platforms || []).forEach(p => {
                    const obj = { ...p, type: p.type || 'platform', texture: saved.textures?.[p.textureId] || null };
                    if (p.type === 'teleporter') {
                        obj.targetX = p.targetX || 0;
                        obj.targetY = p.targetY || 0;
                        obj.teleportDelay = p.teleportDelay || 0;
                    }
                    if (p.type === 'jumpPad') {
                        obj.jumpBoost = p.jumpBoost || 800;
                    }
                    if (p.type === 'chest') {
                        obj.detectionRadius = p.detectionRadius || 100;
                        obj.items = p.items || [];
                        obj.closedTextureId = p.closedTextureId !== undefined ? p.closedTextureId : 0;
                        obj.openTextureId = p.openTextureId !== undefined ? p.openTextureId : 1;
                        obj.openingTextureId = p.openingTextureId !== undefined ? p.openingTextureId : 2;
                        obj.closingTextureId = p.closingTextureId !== undefined ? p.closingTextureId : 3;
                    }
                    if (p.type === 'respawn') {
                        obj.detectionRadius = p.detectionRadius || 1200;
                        obj.passThrough = p.passThrough || false;
                        obj.respawnX = p.respawnX !== undefined ? p.respawnX : p.x;
                        obj.respawnY = p.respawnY !== undefined ? p.respawnY : p.y;
                        obj.inactiveTextureId = p.inactiveTextureId !== undefined ? p.inactiveTextureId : 0;
                        obj.activeTextureId = p.activeTextureId !== undefined ? p.activeTextureId : 1;
                    }
                    objects.push(obj);
                });
                (saved.decor || []).forEach(d => {
                    const obj = { ...d, type: 'decor', texture: saved.textures?.[d.textureId] || null, parallaxSpeed: d.parallaxSpeed || 1 };
                    objects.push(obj);
                });
                updateUsedIds();
            }
            updateHierarchy();
            updateInspector();
            updateJSON();
            draw();
            updateStatus();
            saveState();
        }).catch(console.error);
    </script>
</body>
</html>
