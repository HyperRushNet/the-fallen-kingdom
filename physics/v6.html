<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/assets/images/favicon/000000.png" media="(prefers-color-scheme: light)">  
    <link rel="icon" href="/assets/images/favicon/ffffff.png" media="(prefers-color-scheme: dark)">  
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <title>Game Engine</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            overflow: hidden; 
            background: #0a0a0a; 
            color: #b0d0ff; 
            font-family: 'Orbitron', 'Courier New', monospace;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        canvas { background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); display: block; width: 100vw; height: 100vh; }
        #fadeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            opacity: 0;
            z-index: 10000;
            pointer-events: none;
        }
        #debug {
            position: fixed; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.4);
            padding: 12px; border: 1px dashed #b0d0ff; border-radius: 8px;
            width: 260px; font-size: 11px; line-height: 1.1;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); backdrop-filter: blur(8px);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: all 0.3s ease;
        }
        #debug:hover {
            box-shadow: 0 0 20px rgba(176, 208, 255, 0.3);
            border-color: #ffffff;
        }
        #debug button {
            display: block;
            width: 100%;
            padding: 8px;
            background: linear-gradient(145deg, rgba(255, 0, 0, 0.3), rgba(255, 0, 0, 0.1));
            color: #ff6b6b;
            border: none;
            border-radius: 0 0 8px 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.2s;
            margin-bottom: 12px;
        }
        #debug button:hover {
            background: linear-gradient(145deg, rgba(255, 0, 0, 0.5), rgba(255, 0, 0, 0.2));
            color: white;
        }
        #inventory {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 450px;
            height: 350px;
            background: linear-gradient(145deg, rgba(10, 10, 10, 0.95), rgba(20, 20, 20, 0.95));
            border: 2px solid #b0d0ff;
            border-radius: 16px;
            padding: 24px;
            color: #b0d0ff;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            z-index: 1000;
            display: none;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 15px rgba(176, 208, 255, 0.05);
            animation: uiSlideIn 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            will-change: transform;
        }
        @keyframes uiSlideIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        #inventory h2 {
            margin-bottom: 16px;
            text-align: center;
            font-weight: 700;
            font-size: 18px;
            background: linear-gradient(90deg, #b0d0ff, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 10px rgba(176, 208, 255, 0.5);
        }
        #inventoryGrid {
            margin: 16px 0;
            padding: 12px;
            background: rgba(176, 208, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(176, 208, 255, 0.1);
        }
        #chestUI {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 550px;
            background: linear-gradient(145deg, rgba(10, 10, 10, 0.95), rgba(20, 20, 20, 0.95));
            border: 2px solid #b0d0ff;
            border-radius: 16px;
            padding: 24px;
            color: #b0d0ff;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            z-index: 1000;
            display: none;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 15px rgba(176, 208, 255, 0.05);
            will-change: transform;
        }
        #chestUI h2 {
            margin-bottom: 16px;
            text-align: center;
            font-weight: 700;
            font-size: 18px;
            background: linear-gradient(90deg, #b0d0ff, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 10px rgba(176, 208, 255, 0.5);
        }
        #chestSection, #playerSection {
            margin-bottom: 24px;
            display: flex;
            flex-direction: column;
            background: rgba(176, 208, 255, 0.05);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(176, 208, 255, 0.1);
        }
        #chestSection h3, #playerSection h3 {
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 14px;
            color: #ffffff;
        }
        .grid-inventory {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 12px 0;
        }
        .grid-chest {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 12px 0;
        }
        .slot {
            width: 48px;
            height: 48px;
            border: 2px solid rgba(176, 208, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        .slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(176, 208, 255, 0.1), transparent);
            transition: left 0.5s;
        }
        .slot:hover::before {
            left: 100%;
        }
        .slot:hover {
            border-color: #b0d0ff;
            box-shadow: 0 0 15px rgba(176, 208, 255, 0.3);
            transform: scale(1.05);
        }
        .slot.has-item {
            border-color: #ffffff;
            box-shadow: inset 0 0 10px rgba(176, 208, 255, 0.2);
        }
        .item {
            display: flex;
            align-items: center;
            cursor: grab;
            transition: transform 0.2s ease;
            z-index: 10;
        }
        .item:hover {
            transform: scale(1.1);
        }
        .item:active {
            cursor: grabbing;
        }
        .item img {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            filter: drop-shadow(0 0 5px rgba(176, 208, 255, 0.5));
        }
        #closeInventory, #closeChest {
            position: absolute;
            top: 12px;
            right: 12px;
            background: linear-gradient(145deg, rgba(255, 0, 0, 0.2), rgba(255, 0, 0, 0.1));
            border: 1px solid rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            color: #ff6b6b;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        #closeInventory:hover, #closeChest:hover {
            background: linear-gradient(145deg, rgba(255, 0, 0, 0.4), rgba(255, 0, 0, 0.2));
            color: #ffffff;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #b0d0ff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 20;
            backdrop-filter: blur(10px);
        }
        .slot:hover .tooltip {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="fadeOverlay"></div>
    <div id="debug">
    </div>
    <div id="inventory">
        <button id="closeInventory">&times;</button>
        <h2>Inventory</h2>
        <div id="inventoryGrid"></div>
    </div>
    <div id="chestUI">
        <button id="closeChest">&times;</button>
        <h2>Chest Interactions</h2>
        <div id="chestSection">
            <h3>Chest Contents</h3>
            <div id="chestGrid" class="grid-chest"></div>
        </div>
        <div id="playerSection">
            <h3>Your Inventory</h3>
            <div id="playerGridInChest" class="grid-inventory"></div>
        </div>
    </div>
    <script>
        const config = {
            gravity: 900,
            playerSpeed: 200,
            jumpHeight: 600,
            airJumpCooldown: 1.5,
            dashDuration: 0.2,
            dashSpeed: 800,
            cameraSmoothing: 0.05,
            maxPlayerSlots: 12,
            maxChestSlots: 9,
            chestDetectionRadius: 100,
            respawnDetectionRadius: 1200,
            fadeDuration: 1,
            mostlyDarkPercentage: 0.8,
            autoSaveInterval: 5000,
            debugKey: "KeyD",
            inventoryKey: "KeyI",
            chestKey: "KeyE",
            respawnKey: "KeyR",
            dashKeys: ["ShiftLeft", "ShiftRight"],
            jumpKey: "Space",
            leftKey: "ArrowLeft",
            rightKey: "ArrowRight",
            clearStorageKey: "Backspace",
            ctrlForClear: true,
            godModeKey: "KeyG",
            infiniteJumpKey: "KeyJ",
            noclipKey: "KeyN"
        };

        const mapData = {
  "playerStart": {
    "x": 0,
    "y": -13,
    "w": 59,
    "h": 100,
    "zIndex": 1,
    "angle": 0
  },
  "textures": [],
  "platforms": [
    {
      "id": "jgWo6uTND6pu-Os4J6efGYCzb",
      "type": "platform",
      "x": 210,
      "y": 100,
      "w": 1200,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 1
    },
    {
      "id": "kkjpb16uNZiC-wXbrlAZlZh6G",
      "type": "platform",
      "x": 750,
      "y": -360,
      "w": 100,
      "h": 200,
      "angle": 0,
      "textureId": null,
      "zIndex": 2
    },
    {
      "id": "8j6gnj4GmL6Z-yO60LctfFFzb",
      "type": "platform",
      "x": 635,
      "y": -843,
      "w": 400,
      "h": 100,
      "angle": 30,
      "textureId": null,
      "zIndex": 3
    },
    {
      "id": "edCMMNq3n6xB-pQMRIUBnzSQ0",
      "type": "platform",
      "x": 900,
      "y": -210,
      "w": 200,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 4
    },
    {
      "id": "3rQKxqosrA06-8dkJiryN0Bbm",
      "type": "platform",
      "x": 1077,
      "y": -241,
      "w": 200,
      "h": 100,
      "angle": -20,
      "textureId": null,
      "zIndex": 5
    },
    {
      "id": "X2Qnky1oVNud-IjZmQYypmDHg",
      "type": "platform",
      "x": 1211,
      "y": -281,
      "w": 100,
      "h": 100,
      "angle": -10,
      "textureId": null,
      "zIndex": 6
    },
    {
      "id": "2KGvRRd1pYqF-lf6mZxwt59dc",
      "type": "platform",
      "x": 1302,
      "y": -289,
      "w": 100,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 7
    },
    {
      "id": "oWxYgmS6AQWg-kyNXNHFKVwAI",
      "type": "platform",
      "x": 1392,
      "y": -281,
      "w": 100,
      "h": 100,
      "angle": 10,
      "textureId": null,
      "zIndex": 8
    },
    {
      "id": "8peAJm7lGCkV-kzrYFYGaCTDC",
      "type": "platform",
      "x": 1526,
      "y": -240,
      "w": 200,
      "h": 100,
      "angle": 20,
      "textureId": null,
      "zIndex": 9
    },
    {
      "id": "9vCbybOEpKba-kxu7XvSfB8SD",
      "type": "platform",
      "x": 1410,
      "y": 100,
      "w": 1200,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 1
    },
    {
      "id": "MS1PZMAEiRFM-dZFkoEtwGk7j",
      "type": "platform",
      "x": 1250,
      "y": -360,
      "w": 900,
      "h": 200,
      "angle": 0,
      "textureId": null,
      "zIndex": 11
    },
    {
      "id": "mB9AGahnURyG-SRwduaagJUTa",
      "type": "platform",
      "x": 1491,
      "y": -510,
      "w": 780,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 12
    },
    {
      "id": "4mSqoDGYUcVg-uVvKKDYiEFyL",
      "type": "platform",
      "x": 860,
      "y": -781,
      "w": 200,
      "h": 100,
      "angle": -20,
      "textureId": null,
      "zIndex": 13
    },
    {
      "id": "0vTEKctsJJgh-bojJAgRYlkSz",
      "type": "platform",
      "x": 1093,
      "y": -839,
      "w": 300,
      "h": 100,
      "angle": -10,
      "textureId": null,
      "zIndex": 14
    },
    {
      "id": "CmBavJ0hZhFq-GrwUXjNqhTpr",
      "type": "platform",
      "x": 1311,
      "y": -909,
      "w": 200,
      "h": 100,
      "angle": -30,
      "textureId": null,
      "zIndex": 15
    },
    {
      "id": "VqLONgs03hiY-ogv3zTN5M3dK",
      "type": "platform",
      "x": 786,
      "y": -245,
      "w": 141,
      "h": 100,
      "angle": 45,
      "textureId": null,
      "zIndex": 16
    },
    {
      "id": "Vb8HWAKBdL6Z-aIoE71xlQDgI",
      "type": "platform",
      "x": 1650,
      "y": -210,
      "w": 100,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 17
    },
    {
      "id": "84t3a75ooIRX-T1OnrwMWNA6B",
      "type": "platform",
      "x": 1529,
      "y": -979,
      "w": 300,
      "h": 100,
      "angle": -10,
      "textureId": null,
      "zIndex": 18
    },
    {
      "id": "gE7XXXicjEat-mnS07sjDfPvx",
      "type": "platform",
      "x": 1739,
      "y": -913,
      "w": 300,
      "h": 100,
      "angle": 45,
      "textureId": null,
      "zIndex": 19
    },
    {
      "id": "wR44RJanvFEX-xjzmUm1QIC83",
      "type": "platform",
      "x": 1831,
      "y": -701,
      "w": 100,
      "h": 283,
      "angle": 0,
      "textureId": null,
      "zIndex": 20
    },
    {
      "id": "9RsFfEXShyPx-L3bz8ljUsu0C",
      "type": "platform",
      "x": 2310,
      "y": 50,
      "w": 600,
      "h": 200,
      "angle": 0,
      "textureId": null,
      "zIndex": 1
    },
    {
      "id": "wFUMitBwRH8N-jaQEV6NVDoea",
      "type": "platform",
      "x": 1795,
      "y": -394,
      "w": 450,
      "h": 235,
      "angle": -40,
      "textureId": null,
      "zIndex": 22
    },
    {
      "id": "IAJZ6SZzR4YH-bq4lnwKOYhsj",
      "type": "platform",
      "x": 1969,
      "y": -515,
      "w": 355,
      "h": 175,
      "angle": -20,
      "textureId": null,
      "zIndex": 23
    },
    {
      "id": "h8UAI1ADfe9H-R4jmVGaQc9xO",
      "type": "platform",
      "x": 2295,
      "y": -605,
      "w": 355,
      "h": 175,
      "angle": -10,
      "textureId": null,
      "zIndex": 24
    },
    {
      "id": "rZaZix5aGw88-qwNz0CJUpQKs",
      "type": "platform",
      "x": 3441,
      "y": -186,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 27
    },
    {
      "id": "zlUUglmdDa54-WEb8AuvqA7xS",
      "type": "platform",
      "x": 3771,
      "y": -237,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 28
    },
    {
      "id": "pTqWy92PbcBF-Pwa8dvWqg7M9",
      "type": "platform",
      "x": 2910,
      "y": -42,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 29
    },
    {
      "id": "A3ckQ4o67yQp-xqTd68CPc0Vx",
      "type": "platform",
      "x": 3199,
      "y": -52,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 30
    },
    {
      "id": "GWX8BWSXmc7L-d30Ee41JSOpy",
      "type": "platform",
      "x": 3984,
      "y": -417,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 31
    },
    {
      "id": "F3cbLQKZGswe-OzeWvsmhx3KC",
      "type": "platform",
      "x": 3673,
      "y": -574,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 32
    },
    {
      "id": "jURZ7N1idbLU-ilSWg1t84xuZ",
      "type": "deadly",
      "x": 2910,
      "y": -22,
      "w": 98,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 33
    },
    {
      "id": "hwOm68RaIRHX-zEXB3Ze04DaI",
      "type": "deadly",
      "x": 3199,
      "y": -32,
      "w": 98,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 34
    },
    {
      "id": "zzmsdIG86uol-ifMTnU8xQMB1",
      "type": "deadly",
      "x": 3441,
      "y": -166,
      "w": 98,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 35
    },
    {
      "id": "872NIw92j9aD-hA8iQGKGtXbU",
      "type": "deadly",
      "x": 3771,
      "y": -217,
      "w": 98,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 36
    },
    {
      "id": "BlhZ9dgvWdWB-kiHylVXZiObj",
      "type": "deadly",
      "x": 3984,
      "y": -397,
      "w": 98,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 37
    },
    {
      "id": "z39vM1L7cE5Q-bB9RBVbfTk8a",
      "type": "deadly",
      "x": 3673,
      "y": -554,
      "w": 98,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 38
    },
    {
      "id": "raAYBYWQSgvh-2ULmY9IOfiNv",
      "type": "platform",
      "x": 3385,
      "y": 450,
      "w": 2750,
      "h": 600,
      "angle": 0,
      "textureId": null,
      "zIndex": 39
    },
    {
      "id": "p8jDcXstfhOM-QSNUJnBykSV3",
      "type": "platform",
      "x": 4460,
      "y": 50,
      "w": 600,
      "h": 200,
      "angle": 0,
      "textureId": null,
      "zIndex": 40
    },
    {
      "id": "v0WiMvC6M2qK-kDjUXzqeANwX",
      "type": "platform",
      "x": 4550,
      "y": -370,
      "w": 600,
      "h": 400,
      "angle": 0,
      "textureId": null,
      "zIndex": 41
    },
    {
      "id": "uCFZiV6yv4UN-SadspmUsg5FV",
      "type": "platform",
      "x": 3957,
      "y": -682,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 42
    },
    {
      "id": "W3GH8M6LJkLs-TZBvsjZntFjg",
      "type": "deadly",
      "x": 3957,
      "y": -662,
      "w": 98,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 43
    },
    {
      "id": "W0fXvWWTxMol-OMpY660ni3d1",
      "type": "platform",
      "x": 4150,
      "y": -1030,
      "w": 600,
      "h": 200,
      "angle": -10,
      "textureId": null,
      "zIndex": 44
    },
    {
      "id": "UVRO79gn60Fa-qR4McfpfUNuv",
      "type": "platform",
      "x": 4648,
      "y": -1006,
      "w": 721,
      "h": 200,
      "angle": 7,
      "textureId": null,
      "zIndex": 45
    },
    {
      "id": "1BUqI8Ofi6ms-oRamBygx0D9l",
      "type": "platform",
      "x": 4200,
      "y": -420,
      "w": 100,
      "h": 300,
      "angle": 0,
      "textureId": null,
      "zIndex": 46
    },
    {
      "id": "6gehgTx3BD6O-xXi9vvMSMLBI",
      "type": "platform",
      "x": 4228,
      "y": -250,
      "w": 145,
      "h": 80,
      "angle": 45,
      "textureId": null,
      "zIndex": 47
    },
    {
      "id": "pkpDsWpzctKL-5OwQigDTbIma",
      "type": "platform",
      "x": 3551,
      "y": -1070,
      "w": 721,
      "h": 200,
      "angle": 15,
      "textureId": null,
      "zIndex": 48
    },
    {
      "id": "3LmKr3UGZEbo-oZqx3tKCAMDs",
      "type": "platform",
      "x": 2952,
      "y": -1109,
      "w": 600,
      "h": 200,
      "angle": -10,
      "textureId": null,
      "zIndex": 49
    },
    {
      "id": "eoyRw3WubzR1-DbMIf038kjjL",
      "type": "platform",
      "x": 2576,
      "y": -855,
      "w": 600,
      "h": 200,
      "angle": -55,
      "textureId": null,
      "zIndex": 50
    },
    {
      "id": "7KIgFCDRwdF8-U0yUPGrWyEqm",
      "type": "platform",
      "x": 4366,
      "y": -639,
      "w": 433,
      "h": 138,
      "angle": 0,
      "textureId": null,
      "zIndex": 53
    },
    {
      "id": "VOvckp2nyAe5-Q8U76TEKoQeO",
      "type": "deadly",
      "x": 3385,
      "y": 140,
      "w": 1550,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 54
    },
    {
      "id": "udUfT3MNj0Cq-KJ7Zsh70Ue5q",
      "type": "platform",
      "x": 1308,
      "y": -88,
      "w": 220,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 57
    },
    {
      "id": "SGG8pcYQm6mQ-KelDCAx3MBhP",
      "type": "chest",
      "x": 1309,
      "y": -135,
      "w": 75,
      "h": 75,
      "angle": 0,
      "textureId": null,
      "zIndex": 1,
      "detectionRadius": 100,
      "items": [
        "rosaries",
        "stone"
      ]
    },
    {
      "id": "1QDwJg388Lnv-bRNjkmuWhFaJ",
      "type": "platform",
      "x": 2156,
      "y": -739,
      "w": 700,
      "h": 300,
      "angle": 0,
      "textureId": null,
      "zIndex": 59
    },
    {
      "id": "grUfrpf3npIq-vvdKdShPsT0r",
      "type": "platform",
      "x": 2174,
      "y": -1035,
      "w": 948,
      "h": 300,
      "angle": 0,
      "textureId": null,
      "zIndex": 60
    },
    {
      "id": "PUWunsdRlN0O-JKgeIBhYmDtE",
      "type": "platform",
      "x": 4810,
      "y": 350,
      "w": 100,
      "h": 800,
      "angle": 0,
      "textureId": null,
      "zIndex": 1
    },
    {
      "id": "bUCHEPHsDCZW-Ox8b1I5c4cng",
      "type": "platform",
      "x": 5010,
      "y": 350,
      "w": 100,
      "h": 800,
      "angle": 0,
      "textureId": null,
      "zIndex": 62
    },
    {
      "id": "f3m3R5o2BQzW-fI3gFRtTA3ER",
      "type": "respawn",
      "x": 1714,
      "y": -616,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 63,
      "detectionRadius": 100,
      "passThrough": false,
      "respawnX": 1714,
      "respawnY": -616
    }
  ],
  "decor": [
    {
      "id": "HOJZq7kFaugY-LxBMwFAE7Nd0",
      "x": 1408,
      "y": -168,
      "w": 150,
      "h": 20,
      "angle": 90,
      "textureId": null,
      "zIndex": 55,
      "parallaxSpeed": 1
    },
    {
      "id": "HsNHzCP3C4Dt-1K9hrQ34VdzX",
      "x": 1208,
      "y": -168,
      "w": 150,
      "h": 20,
      "angle": 90,
      "textureId": null,
      "zIndex": 56,
      "parallaxSpeed": 1
    }
  ]
};

        const allItems = new Set();
        mapData.platforms.forEach(plat => {
            if (plat.type === "chest" && plat.items) {
                plat.items.forEach(item => allItems.add(item));
            }
        });
        const itemImages = {};
        Array.from(allItems).forEach(item => {
            const img = new Image();
            img.src = `https://placehold.co/32x32/0000FF/FFFFFF?text=${item.charAt(0).toUpperCase()}`;
            img.onload = () => console.log(`Preloaded ${item}`);
            itemImages[item] = img;
        });

        class Vec2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
            scale(s) { return new Vec2(this.x * s, this.y * s); }
            dot(v) { return this.x * v.x + this.y * v.y; }
            perp() { return new Vec2(-this.y, this.x); }
            len() { return Math.hypot(this.x, this.y); }
            lenSq() { return this.x * this.x + this.y * this.y; }
            norm() { const l = this.len(); return l ? this.scale(1 / l) : new Vec2(); }
            clone() { return new Vec2(this.x, this.y); }
            set(x, y) { this.x = x; this.y = y; return this; }
        }

        function aabbOverlap(a, b) {
            return a.maxX >= b.minX && a.minX <= b.maxX && a.maxY >= b.minY && a.minY <= b.maxY;
        }

        class Polygon {
            constructor(points) {
                this.points = points.map(p => new Vec2(p.x, p.y));
                this.axes = this.getAxes();
            }
            getAxes() {
                const axes = [];
                for (let i = 0; i < this.points.length; i++) {
                    const edge = this.points[(i + 1) % this.points.length].sub(this.points[i]);
                    const axis = edge.perp().norm();
                    if (axis.len() > 0) axes.push(axis);
                }
                return axes;
            }
            getAABB(posX, posY) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of this.points) {
                    const px = p.x + posX;
                    const py = p.y + posY;
                    minX = Math.min(minX, px); minY = Math.min(minY, py);
                    maxX = Math.max(maxX, px); maxY = Math.max(maxY, py);
                }
                return { minX, minY, maxX, maxY };
            }
            project(axis, posX, posY) {
                let min = Infinity, max = -Infinity;
                for (const p of this.points) {
                    const px = p.x + posX;
                    const py = p.y + posY;
                    const proj = px * axis.x + py * axis.y;
                    min = Math.min(min, proj);
                    max = Math.max(max, proj);
                }
                return { min, max };
            }
            static overlap(A, posAX, posAY, B, posBX, posBY) {
                const axes = [...A.axes, ...B.axes];
                let overlap = Infinity, smallestAxis = null;
                for (const axis of axes) {
                    if (axis.lenSq() < 1e-6) continue;
                    const projA = A.project(axis, posAX, posAY);
                    const projB = B.project(axis, posBX, posBY);
                    const o = Math.min(projA.max, projB.max) - Math.max(projA.min, projB.min);
                    if (o < 1e-6) return null;
                    if (o < overlap) { overlap = o; smallestAxis = axis; }
                }
                if (!smallestAxis) return null;
                const dX = posAX - posBX;
                const dY = posAY - posBY;
                const dLen = Math.hypot(dX, dY);
                let dirX = 0, dirY = -1;
                if (dLen > 1e-6) {
                    dirX = dX / dLen;
                    dirY = dY / dLen;
                }
                let axisX = smallestAxis.x;
                let axisY = smallestAxis.y;
                const dirDotAxis = dirX * axisX + dirY * axisY;
                if (dirDotAxis < 0) {
                    axisX = -axisX;
                    axisY = -axisY;
                }
                return { axis: { x: axisX, y: axisY }, overlap };
            }
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return new Float32Array([r, g, b, 1]);
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsource, fsource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsource);
            if (!vs) return null;
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsource);
            if (!fs) return null;
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const projviewMatrix = new Float32Array(12);

        function getProjViewMatrix(width, height, camX, camY, matrix, isUI = false) {
            if (isUI) {
                matrix[0] = 2 / width;
                matrix[1] = 0;
                matrix[2] = 0;
                matrix[3] = 0;
                matrix[4] = 0;
                matrix[5] = -2 / height;
                matrix[6] = 0;
                matrix[7] = 0;
                matrix[8] = -1;
                matrix[9] = 1;
                matrix[10] = 1;
                matrix[11] = 0;
            } else {
                matrix[0] = 2 / width;
                matrix[1] = 0;
                matrix[2] = 0;
                matrix[3] = 0;
                matrix[4] = 0;
                matrix[5] = -2 / height;
                matrix[6] = 0;
                matrix[7] = 0;
                matrix[8] = -1 - 2 * camX / width;
                matrix[9] = 1 + 2 * camY / height;
                matrix[10] = 1;
                matrix[11] = 0;
            }
            return matrix;
        }

        const vsSource = `#version 300 es
            precision mediump float;
            layout(std140) uniform Matrices {
                mat3 u_matrix;
            };
            layout(location = 0) in vec2 a_position;
            layout(location = 1) in vec2 a_texcoord;
            layout(location = 2) in vec4 a_color;
            out vec2 v_texcoord;
            out vec4 v_color;
            void main() {
                gl_Position = vec4((u_matrix * vec3(a_position, 1.0)).xy, 0.0, 1.0);
                v_texcoord = a_texcoord;
                v_color = a_color;
            }
        `;

        const fsSource = `#version 300 es
            precision mediump float;
            in vec2 v_texcoord;
            in vec4 v_color;
            uniform sampler2D u_texture;
            uniform bool u_useTexture;
            out vec4 fragColor;
            void main() {
                if (u_useTexture) {
                    fragColor = texture(u_texture, v_texcoord) * v_color;
                } else {
                    fragColor = v_color;
                }
            }
        `;

        function isTextureReady(texObj) {
            if (!texObj) return false;
            if (texObj instanceof HTMLImageElement) {
                return texObj.complete && texObj.naturalWidth > 0;
            } else if (texObj && texObj.video) {
                return texObj.video.readyState >= 2 && texObj.isReady;
            }
            return false;
        }

        class BaseShape {
            constructor(x, y, w, h, angleDeg, z, textureIndex, isDecor = false, parallaxSpeed = 0.7) {
                this.pos = new Vec2(x, y);
                this.width = w;
                this.height = h;
                this.angle = angleDeg * Math.PI / 180;
                this.z = z || 0;
                this.textureIndex = textureIndex;
                this.isDecor = isDecor;
                this.parallaxSpeed = parallaxSpeed;
                const hw = w / 2, hh = h / 2;
                const cos = Math.cos(this.angle), sin = Math.sin(this.angle);
                this.localPoints = [
                    new Vec2(-hw * cos - hh * sin, -hw * sin + hh * cos),
                    new Vec2(hw * cos - hh * sin, hw * sin + hh * cos),
                    new Vec2(hw * cos + hh * sin, hw * sin - hh * cos),
                    new Vec2(-hw * cos + hh * sin, -hw * sin - hh * cos)
                ];
                this.shape = new Polygon(this.localPoints);
                this.updateAABB();
                this.lineArray = new Float32Array(16);
                this.colorArray = hexToRgb("#4af");
                if (!isDecor) {
                    this.vel = new Vec2(0, 0);
                    this.onGround = false;
                    this.groundNormal = new Vec2(0, -1);
                    this.oldOnGround = false;
                    this.groundAngle = 0;
                }
            }
            updateAABB() {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                const posX = this.pos.x;
                const posY = this.pos.y;
                for (const p of this.localPoints) {
                    const px = p.x + posX;
                    const py = p.y + posY;
                    minX = Math.min(minX, px); minY = Math.min(minY, py);
                    maxX = Math.max(maxX, px); maxY = Math.max(maxY, py);
                }
                this.aabb = { minX, minY, maxX, maxY };
            }
            updateLineArray(posX, posY) {
                const la = this.lineArray;
                for (let i = 0; i < 4; i++) {
                    const curr = this.localPoints[i];
                    const next = this.localPoints[(i + 1) % 4];
                    const cx = curr.x + posX;
                    const cy = curr.y + posY;
                    const nx = next.x + posX;
                    const ny = next.y + posY;
                    const base = i * 4;
                    la[base + 0] = cx;
                    la[base + 1] = cy;
                    la[base + 2] = nx;
                    la[base + 3] = ny;
                }
            }
            appendDebugLines(arr, lineColor, posX, posY, vel = null, velColor = null, startIdx = 0, world) {
                this.updateLineArray(posX, posY);
                const la = this.lineArray;
                let idx = startIdx;
                for (let k = 0; k < 8; k++) {
                    const i = k * 2;
                    arr[idx++] = la[i]; arr[idx++] = la[i + 1]; arr[idx++] = 0; arr[idx++] = 0;
                    arr[idx++] = lineColor[0]; arr[idx++] = lineColor[1]; arr[idx++] = lineColor[2]; arr[idx++] = lineColor[3];
                }
                if (vel && vel.len() > 0) {
                    const scale = 0.1;
                    arr[idx++] = posX; arr[idx++] = posY; arr[idx++] = 0; arr[idx++] = 0;
                    arr[idx++] = velColor[0]; arr[idx++] = velColor[1]; arr[idx++] = velColor[2]; arr[idx++] = velColor[3];
                    arr[idx++] = posX + vel.x * scale; arr[idx++] = posY + vel.y * scale; arr[idx++] = 0; arr[idx++] = 0;
                    arr[idx++] = velColor[0]; arr[idx++] = velColor[1]; arr[idx++] = velColor[2]; arr[idx++] = velColor[3];
                }
                return idx;
            }
        }

        class Entity extends BaseShape {
            constructor(x, y, w, h, angleDeg, color, isStatic = false, z, textureIndex, parallaxSpeed) {
                super(x, y, w, h, angleDeg, z, textureIndex, false, parallaxSpeed);
                this.colorArray = hexToRgb(color);
                this.isStatic = isStatic;
                this.deadly = false;
                this.passThrough = false;
                this.jumpBoost = 0;
                this.teleportTarget = null;
                this.teleportDelay = 0;
                this.lastDirection = 1;
                this.dashTimer = 0;
                this.isDashing = false;
                this.diagonalDash = false;
                this.oldDashTimer = 0;
                this.jumpPressed = false;
                this.airJumpCooldown = 0;
                this.airJumpCooldownMax = config.airJumpCooldown;
                this.currentTeleporter = null;
                this.teleporterAccum = 0;
                this.justLanded = false;
                this.landedEntity = null;
                this.isDying = false;
                this.godMode = false;
                this.infiniteJump = false;
                this.noclip = false;
                if (isStatic) this.updateAABB();
            }
            update(dt, world) {
                if (this.isStatic) return;
                if (this.isDying && !this.godMode) {
                    this.vel.set(0, 0);
                    return;
                }
                const dashStarted = this.dashTimer > 0 && this.oldDashTimer <= 0;
                if (this.airJumpCooldown > 0 && !this.infiniteJump) {
                    this.airJumpCooldown -= dt;
                    if (this.airJumpCooldown < 0) this.airJumpCooldown = 0;
                }
                this.oldOnGround = this.onGround;
                this.onGround = false;
                this.justLanded = false;
                this.landedEntity = null;
                let input_speed;
                let g_vec_x = 0;
                let g_vec_y = 0;
                if (this.dashTimer > 0) {
                    this.dashTimer -= dt;
                    this.isDashing = true;
                    input_speed = 0;
                    g_vec_y = 0;
                    if (dashStarted && world.keys[config.jumpKey]) {
                        this.diagonalDash = true;
                    }
                } else {
                    this.isDashing = false;
                    this.diagonalDash = false;
                    input_speed = world.keys[config.leftKey] ? -config.playerSpeed : world.keys[config.rightKey] ? config.playerSpeed : 0;
                    if (!this.godMode) g_vec_y = config.gravity * dt;
                }
                const up_x = 0;
                const up_y = -1;
                if (this.oldOnGround && !this.noclip) {
                    const tangent_x = -this.groundNormal.y;
                    const tangent_y = this.groundNormal.x;
                    const normalComp = this.vel.x * this.groundNormal.x + this.vel.y * this.groundNormal.y;
                    this.vel.x = tangent_x * input_speed + this.groundNormal.x * normalComp;
                    this.vel.y = tangent_y * input_speed + this.groundNormal.y * normalComp;
                } else {
                    this.vel.x = input_speed;
                }
                if (this.isDashing) {
                    const angle = Math.PI / 4;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    if (this.diagonalDash) {
                        this.vel.x = this.lastDirection * config.dashSpeed * cos;
                        this.vel.y = -config.dashSpeed * sin;
                    } else {
                        this.vel.x = this.lastDirection * config.dashSpeed;
                        this.vel.y = 0;
                    }
                }
                this.vel.x += g_vec_x;
                this.vel.y += g_vec_y;
                const disp_x = this.vel.x * dt;
                const disp_y = this.vel.y * dt;
                let numSteps = Math.max(1, Math.ceil(Math.hypot(disp_x, disp_y) / 0.5));
                const sub_disp_x = disp_x / numSteps;
                const sub_disp_y = disp_y / numSteps;
                let currentPosX = this.pos.x;
                let currentPosY = this.pos.y;
                const beta = 0.5;
                for (let step = 0; step < numSteps; step++) {
                    let testPosX = currentPosX + sub_disp_x;
                    let testPosY = currentPosY + sub_disp_y;
                    if (this.noclip) {
                        currentPosX = testPosX;
                        currentPosY = testPosY;
                        continue;
                    }
                    for (let i = 0; i < 10; i++) {
                        let deadlyCollision = false;
                        let collisions = [];
                        let testAABB = this.shape.getAABB(testPosX, testPosY);
                        for (const other of world.getNearby(testPosX, testPosY)) {
                            if (!other.shape || other === this || other.isDecor) continue;
                            const otherAABB = other.aabb;
                            if (!aabbOverlap(testAABB, otherAABB)) continue;
                            const res = Polygon.overlap(this.shape, testPosX, testPosY, other.shape, other.pos.x, other.pos.y);
                            if (res) {
                                if (other.teleportTarget && this === world.player) {
                                } else if (other.deadly && this === world.player && !this.godMode) {
                                    deadlyCollision = true;
                                } else if (other.passThrough && this === world.player) {
                                } else {
                                    let axis = res.axis;
                                    const d_x = testPosX - other.pos.x;
                                    const d_y = testPosY - other.pos.y;
                                    const dLen = Math.hypot(d_x, d_y);
                                    let dir_x = 0;
                                    let dir_y = -1;
                                    if (dLen > 1e-6) {
                                        dir_x = d_x / dLen;
                                        dir_y = d_y / dLen;
                                    }
                                    const dirDotAxis = dir_x * axis.x + dir_y * axis.y;
                                    let push_x = axis.x;
                                    let push_y = axis.y;
                                    if (dirDotAxis < 0) {
                                        push_x = -push_x;
                                        push_y = -push_y;
                                    }
                                    collisions.push({ push_x, push_y, overlap: res.overlap, other });
                                }
                            }
                        }
                        if (deadlyCollision) {
                            if (this.godMode) {
                                break;
                            }
                            this.isDying = true;
                            this.vel.set(0, 0);
                            const fadeDuration = config.fadeDuration;
                            const mostlyDarkPercentage = config.mostlyDarkPercentage;
                            fadeOverlay.style.transition = `opacity ${fadeDuration}s ease-out`;
                            fadeOverlay.style.opacity = '1';
                            setTimeout(() => {
                                this.pos.set(world.currentRespawnPos.x, world.currentRespawnPos.y);
                                this.updateAABB();
                                this.vel.set(0, 0);
                                this.onGround = false;
                                setTimeout(() => {
                                    fadeOverlay.style.transition = `opacity ${fadeDuration}s ease-in`;
                                    fadeOverlay.style.opacity = '0';
                                    setTimeout(() => {
                                        this.isDying = false;
                                        world.saveProgress().catch(console.error);
                                    }, fadeDuration * 1000);
                                }, fadeDuration * (1 - mostlyDarkPercentage) * 1000);
                            }, fadeDuration * mostlyDarkPercentage * 1000);
                            break;
                        }
                        if (collisions.length === 0) break;
                        collisions.sort((a, b) => b.overlap - a.overlap);
                        let has_ground = false;
                        let maxGroundOverlap = -Infinity;
                        let bestGround = null;
                        let ground_normal_x = 0;
                        let ground_normal_y = 0;
                        const was_on_ground = this.onGround;
                        for (const col of collisions) {
                            const push_dist = beta * col.overlap;
                            testPosX += col.push_x * push_dist;
                            testPosY += col.push_y * push_dist;
                            const vn = this.vel.x * col.push_x + this.vel.y * col.push_y;
                            if (vn < 0) {
                                this.vel.x -= col.push_x * vn;
                                this.vel.y -= col.push_y * vn;
                            }
                            const upward = col.push_x * up_x + col.push_y * up_y;
                            if (upward > 0.01) {
                                has_ground = true;
                                if (col.overlap > maxGroundOverlap) {
                                    maxGroundOverlap = col.overlap;
                                    bestGround = col.other;
                                    ground_normal_x = col.push_x;
                                    ground_normal_y = col.push_y;
                                }
                            }
                        }
                        this.onGround = has_ground;
                        if (has_ground && !was_on_ground) {
                            this.justLanded = true;
                            this.landedEntity = bestGround;
                            this.groundNormal.set(ground_normal_x, ground_normal_y);
                        }
                        let remainingCollisions = [];
                        testAABB = this.shape.getAABB(testPosX, testPosY);
                        for (const other of world.getNearby(testPosX, testPosY)) {
                            if (!other.shape || other === this || other.isDecor) continue;
                            const otherAABB = other.aabb;
                            if (!aabbOverlap(testAABB, otherAABB)) continue;
                            const res = Polygon.overlap(this.shape, testPosX, testPosY, other.shape, other.pos.x, other.pos.y);
                            if (res) {
                                if (other.teleportTarget && this === world.player) {
                                } else if (other.deadly && this === world.player) {
                                } else if (other.passThrough && this === world.player) {
                                } else {
                                    let axis = res.axis;
                                    const d_x = testPosX - other.pos.x;
                                    const d_y = testPosY - other.pos.y;
                                    const dLen = Math.hypot(d_x, d_y);
                                    let dir_x = 0;
                                    let dir_y = -1;
                                    if (dLen > 1e-6) {
                                        dir_x = d_x / dLen;
                                        dir_y = d_y / dLen;
                                    }
                                    const dirDotAxis = dir_x * axis.x + dir_y * axis.y;
                                    let push_x = axis.x;
                                    let push_y = axis.y;
                                    if (dirDotAxis < 0) {
                                        push_x = -push_x;
                                        push_y = -push_y;
                                    }
                                    remainingCollisions.push({ push_x, push_y, overlap: res.overlap, other });
                                }
                            }
                        }
                        if (remainingCollisions.length > 0) {
                            remainingCollisions.sort((a, b) => a.overlap - b.overlap);
                            const col = remainingCollisions[0];
                            const push_dist = col.overlap;
                            testPosX += col.push_x * push_dist;
                            testPosY += col.push_y * push_dist;
                        }
                    }
                    currentPosX = testPosX;
                    currentPosY = testPosY;
                }
                this.pos.x = currentPosX;
                this.pos.y = currentPosY;
                this.updateAABB();
                if (this.justLanded && this.landedEntity && this.landedEntity.jumpBoost > 0) {
                    this.vel.y = -this.landedEntity.jumpBoost;
                    this.airJumpCooldown = 0;
                    this.onGround = false;
                }
                if (this.onGround && !this.oldOnGround) {
                    this.airJumpCooldown = 0;
                }
                const jumpThisFrame = world.keys[config.jumpKey] && !this.jumpPressed;
                this.jumpPressed = world.keys[config.jumpKey];
                if (jumpThisFrame) {
                    let doJump = false;
                    if (this.oldOnGround || this.infiniteJump) {
                        doJump = true;
                    } else if (this.airJumpCooldown <= 0) {
                        doJump = true;
                        this.airJumpCooldown = this.airJumpCooldownMax;
                    }
                    if (doJump) {
                        if (this.isDashing) {
                            this.diagonalDash = true;
                            const angle = Math.PI / 4;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            this.vel.x = this.lastDirection * config.dashSpeed * cos;
                            this.vel.y = -config.dashSpeed * sin;
                        } else {
                            this.vel.y = -config.jumpHeight;
                            this.vel.x = input_speed;
                        }
                        this.onGround = false;
                    }
                }
                if (this.onGround && !this.isDashing && !this.noclip) {
                    const tangent_x = -this.groundNormal.y;
                    const tangent_y = this.groundNormal.x;
                    this.vel.x = tangent_x * input_speed;
                    this.vel.y = tangent_y * input_speed;
                    const proj = this.vel.x * up_x + this.vel.y * up_y;
                    if (proj > 0) {
                        this.vel.x -= up_x * proj;
                        this.vel.y -= up_y * proj;
                    }
                    const g_dot_t = g_vec_x * tangent_x + g_vec_y * tangent_y;
                    this.pos.x -= tangent_x * g_dot_t * dt;
                    this.pos.y -= tangent_y * g_dot_t * dt;
                    this.groundAngle = Math.acos(Math.max(-1, Math.min(1, this.groundNormal.dot({x: up_x, y: up_y})))) * 180 / Math.PI;
                }
                if (!this.isDashing && input_speed !== 0) {
                    this.lastDirection = input_speed > 0 ? 1 : -1;
                }
                this.oldDashTimer = this.dashTimer;
            }
        }

        class Chest extends Entity {
            constructor(x, y, w, h, angleDeg, items, z, detectionRadius = config.chestDetectionRadius) {
                super(x, y, w, h, angleDeg, "#8B4513", true, z, 0);
                this.items = items || new Array(config.maxChestSlots).fill(null);
                this.opened = false;
                this.detectionRadius = detectionRadius;
                this.state = 'closed';
                this.currentVideo = null;
                this.closedImageId = 0;
                this.openImageId = 1;
                this.openAnimId = 3;
                this.closeAnimId = 4;
            }
        }

        class RespawnBox extends Entity {
            constructor(x, y, w, h, angleDeg, z, detectionRadius = config.respawnDetectionRadius, passThrough = false, respawnX = x, respawnY = y) {
                super(x, y, w, h, angleDeg, "#FFD700", true, z, 0);
                this.detectionRadius = detectionRadius;
                this.passThrough = passThrough;
                this.respawnPos = new Vec2(respawnX, respawnY);
                this.active = false;
                this.colorArray = hexToRgb("#FFD700");
            }
            setActive(active) {
                this.active = active;
                this.colorArray = active ? hexToRgb("#00FF00") : hexToRgb("#FFD700");
            }
        }

        class World {
            constructor(gl) {
                this.gl = gl;
                this.statics = [];
                this.dynamics = [];
                this.decors = [];
                this.chests = [];
                this.respawnBoxes = [];
                this.keys = {};
                this.cellSize = 200;
                this.spatialHash = new Map();
                this.player = null;
                this.playerStartPos = new Vec2(0, 0);
                this.currentRespawnPos = new Vec2(0, 0);
                this.allEntities = [];
                this.inventory = new Array(config.maxPlayerSlots).fill(null);
                this.nearbyChest = null;
                this.nearbyRespawnBox = null;
                this.batchPositionBuffer = gl.createBuffer();
                this.batchIndexBuffer = gl.createBuffer();
                this.debugLineBuffer = gl.createBuffer();
                this.vao = gl.createVertexArray();
                this.debugVao = gl.createVertexArray();
                this.maxQuads = 1024;
                this.maxVerts = this.maxQuads * 4;
                this.maxIndices = this.maxQuads * 6;
                this.vertData = new Float32Array(this.maxVerts * 8);
                this.indexData = new Uint16Array(this.maxIndices);
                this.debugVertData = new Float32Array(8192);
                this.videoTextures = [];
                this.uboMatrices = null;
                this.lastSaveTime = 0;
                this.db = null;

                this.reusableVec = new Vec2();
                this.reusablePoints = [];
                this.reusableAABB = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
                this.reusableProj = { min: 0, max: 0 };
                this.reusableAxes = [];
                this.reusableTempVec = new Vec2();
                this.reusableSubDisp = new Vec2();
                this.reusableTestPos = new Vec2();
                this.reusableDir = new Vec2();
                this.reusableTangent = new Vec2();
                this.reusableNormalComp = 0;
                this.reusableDisp = new Vec2();
                this.reusableVelLen = 0;
                this.reusableScale = 0;
                this.reusableProjUp = 0;
                this.reusableGVecDot = 0;
                this.reusableInterpPos = new Vec2();
                this.reusableOffset = new Vec2();
                this.reusableRenderPos = new Vec2();
                this.reusableDebugPos = new Vec2();
                this.reusableInterpVel = new Vec2();
                this.reusableTexCoords = new Float32Array(8); 
                this.reusableFixedTex = new Float32Array([0, 1, 1, 1, 1, 0, 0, 0]); 
                this.reusableStandardTex = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]); 
                this.reusableCol = new Float32Array(4);
                this.reusablePointsBuf = new Float32Array(8); 
                this.reusableLineArray = new Float32Array(16);
                this.reusableVelArrowStart = new Float32Array(4);
                this.reusableVelArrowEnd = new Float32Array(4);
                this.reusableDebugVertChunk = new Float32Array(128); 
                this.reusableVertDataChunk = new Float32Array(512); 
                this.reusableIndexDataChunk = new Uint16Array(256); 
                this.reusableBatch = {indexStart: 0, numElements: 0, texIndex: -1};
                this.reusableVisibleAABB = {minX: 0, minY: 0, maxX: 0, maxY: 0 };
            }
            async initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('GameSave', 1);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('progress')) {
                            db.createObjectStore('progress', { keyPath: 'id' });
                        }
                    };
                });
            }
            async saveProgress() {
                if (!this.db) return;
                const data = {
                    position: { x: this.player.pos.x, y: this.player.pos.y },
                    inventory: this.inventory.map(item => (typeof item === 'string' && item !== 'undefined') ? item : null),
                    respawnPos: { x: this.currentRespawnPos.x, y: this.currentRespawnPos.y },
                    lastUpdate: Date.now()
                };
                const tx = this.db.transaction('progress', 'readwrite');
                const store = tx.objectStore('progress');
                store.put({ id: 'current', ...data });
            }
            async loadProgress() {
                if (!this.db) return null;
                const tx = this.db.transaction('progress', 'readonly');
                const store = tx.objectStore('progress');
                const req = store.get('current');
                return new Promise((resolve, reject) => {
                    req.onsuccess = () => {
                        const saved = req.result;
                        if (saved) {
                            saved.inventory = saved.inventory.map(item => (typeof item === 'string' && item !== 'undefined') ? item : null);
                        }
                        resolve(saved || null);
                    };
                    req.onerror = reject;
                });
            }
            async loadMap(data, textures) {
                if (data.playerStart) {
                    const w = data.playerStart.w || 50;
                    const h = data.playerStart.h || 100;
                    const playerShape = new Polygon([
                        {x: -w/2, y: -h/2}, {x: w/2, y: -h/2},
                        {x: w/2, y: h/2}, {x: -w/2, y: h/2}
                    ]);
                    this.playerStartPos.set(data.playerStart.x || 0, data.playerStart.y || 0);
                    this.currentRespawnPos = this.playerStartPos.clone();
                    this.player = new Entity(data.playerStart.x || 0, data.playerStart.y || 0, w, h, data.playerStart.angle || 0, "#4af", false, data.playerStart.zIndex || 1);
                    this.player.shape = playerShape;
                    this.add(this.player);
                    this.allEntities.push(this.player);
                }
                for (const plat of data.platforms || []) {
                    let color = "#555";
                    if (plat.type === "wall") color = "#666";
                    else if (plat.type === "deadly") color = "#f00";
                    else if (plat.type === "teleporter") color = "#00f";
                    else if (plat.type === "jumpPad") color = "#0f0";
                    else if (plat.type === "chest") {
                        const detectionRadius = plat.detectionRadius || config.chestDetectionRadius;
                        const chestItems = new Array(config.maxChestSlots).fill(null);
                        plat.items.slice(0, config.maxChestSlots).forEach((item, idx) => {
                            chestItems[idx] = item;
                        });
                        const chest = new Chest(plat.x || 0, plat.y || 0, plat.w || 80, plat.h || 80, plat.angle || 0, chestItems, plat.zIndex || 0, detectionRadius);
                        this.add(chest);
                        this.chests.push(chest);
                        this.allEntities.push(chest);
                        continue;
                    } else if (plat.type === "respawn") {
                        const detectionRadius = plat.detectionRadius || config.respawnDetectionRadius;
                        const passThrough = plat.passThrough || false;
                        const respawnX = plat.respawnX !== undefined ? plat.respawnX : (plat.x || 0);
                        const respawnY = plat.respawnY !== undefined ? plat.respawnY : (plat.y || 0);
                        const respawnBox = new RespawnBox(plat.x || 0, plat.y || 0, plat.w || 60, plat.h || 60, plat.angle || 0, plat.zIndex || 0, detectionRadius, passThrough, respawnX, respawnY);
                        respawnBox.passThrough = passThrough;
                        this.add(respawnBox);
                        this.respawnBoxes.push(respawnBox);
                        this.allEntities.push(respawnBox);
                        continue;
                    }
                    const e = new Entity(plat.x || 0, plat.y || 0, plat.w || 100, plat.h || 20, plat.angle || 0, color, true, plat.zIndex || 0, plat.textureId !== null ? plat.textureId : -1);
                    if (plat.type === "deadly") e.deadly = true;
                    if (plat.passThrough) e.passThrough = true;
                    if (plat.type === "teleporter") {
                        e.teleportTarget = new Vec2(plat.targetX || 0, plat.targetY || 0);
                        e.teleportDelay = plat.teleportDelay || 0;
                    }
                    if (plat.type === "jumpPad") {
                        e.jumpBoost = plat.jumpBoost || 800;
                    }
                    this.add(e);
                    this.allEntities.push(e);
                }
                for (const d of data.decor || []) {
                    const dd = new BaseShape(
                        d.x || 0,
                        d.y || 0,
                        d.w || 100,
                        d.h || 100,
                        d.angle || 0,
                        d.zIndex || 0,
                        d.textureId !== null ? d.textureId : -1,
                        true,
                        d.parallaxSpeed || 0.7
                    );
                    this.decors.push(dd);
                    this.allEntities.push(dd);
                }
                this.chests.forEach(chest => {
                    chest.state = 'closed';
                    chest.textureIndex = chest.closedImageId;
                });
                this.allEntities.sort((a, b) => a.z - b.z);
                this.rebuildSpatialHash();

                const saved = await this.loadProgress();
                if (saved) {
                    this.player.pos.set(saved.position.x, saved.position.y);
                    this.inventory = [...saved.inventory];
                    this.currentRespawnPos.set(saved.respawnPos.x, saved.respawnPos.y);
                    this.respawnBoxes.forEach(box => box.setActive(false));
                    this.respawnBoxes.forEach(box => {
                        if (Math.abs(box.respawnPos.x - this.currentRespawnPos.x) < 10 && Math.abs(box.respawnPos.y - this.currentRespawnPos.y) < 10) {
                            box.setActive(true);
                        }
                    });
                    this.updateInventoryUI();
                }
            }
            add(e) {
                if (e.isDecor) this.decors.push(e);
                else if (e.isStatic) this.statics.push(e);
                else this.dynamics.push(e);
            }
            getHash(posX, posY) {
                return `${Math.floor(posX / this.cellSize)},${Math.floor(posY / this.cellSize)}`;
            }
            rebuildSpatialHash() {
                this.spatialHash.clear();
                const allStaticLike = [...this.statics, ...this.decors, ...this.chests, ...this.respawnBoxes];
                for (const e of allStaticLike) {
                    const aabb = e.aabb;
                    const expand = e.isDecor ? 150 : 50;
                    const minX = Math.floor((aabb.minX - expand) / this.cellSize);
                    const maxX = Math.floor((aabb.maxX + expand) / this.cellSize);
                    const minY = Math.floor((aabb.minY - expand) / this.cellSize);
                    const maxY = Math.floor((aabb.maxY + expand) / this.cellSize);
                    for (let x = minX; x <= maxX; x++) {
                        for (let y = minY; y <= maxY; y++) {
                            const h = `${x},${y}`;
                            if (!this.spatialHash.has(h)) this.spatialHash.set(h, []);
                            this.spatialHash.get(h).push(e);
                        }
                    }
                }
            }
            getNearby(posX, posY) {
                const nearby = new Set(this.dynamics);
                const cx = Math.floor(posX / this.cellSize), cy = Math.floor(posY / this.cellSize);
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const h = `${cx + dx},${cy + dy}`;
                        if (this.spatialHash.has(h)) {
                            this.spatialHash.get(h).forEach(e => {
                                if (!e.isDecor) nearby.add(e);
                            });
                        }
                    }
                }
                return Array.from(nearby);
            }
            checkNearbyChest() {
                this.nearbyChest = null;
                let closestChest = null;
                let minDist = Infinity;
                const playerPos = this.player.pos;
                for (const chest of this.chests) {
                    const distVec = chest.pos.sub(playerPos.clone());
                    const dist = distVec.len();
                    if (dist < chest.detectionRadius && dist < minDist) {
                        minDist = dist;
                        closestChest = chest;
                    }
                }
                this.nearbyChest = closestChest;
            }
            checkNearbyRespawnBox() {
                this.nearbyRespawnBox = null;
                let closestBox = null;
                let minDist = Infinity;
                const playerPos = this.player.pos;
                for (const box of this.respawnBoxes) {
                    const distVec = box.pos.sub(playerPos.clone());
                    const dist = distVec.len();
                    if (dist < box.detectionRadius && dist < minDist) {
                        minDist = dist;
                        closestBox = box;
                    }
                }
                this.nearbyRespawnBox = closestBox;
            }
            setRespawnAtBox(box) {
                if (!box) return;
                this.respawnBoxes.forEach(b => b.setActive(false));
                box.setActive(true);
                this.currentRespawnPos = box.respawnPos.clone();
                this.saveProgress().catch(console.error);
            }
            openChestUI(chest, textures) {
                if (!chest) return;
                if (chest.state === 'open' || chest.state === 'opening') {
                } else if (chest.state === 'closed') {
                    if (chest.currentVideo) {
                        chest.currentVideo.pause();
                        chest.currentVideo.onended = null;
                        chest.currentVideo = null;
                    }
                    chest.state = 'opening';
                    chest.textureIndex = chest.openAnimId;
                    const openTexObj = textures[chest.openAnimId];
                    if (openTexObj && openTexObj.video) {
                        try {
                            openTexObj.video.currentTime = 0;
                            openTexObj.video.loop = false;
                            openTexObj.video.play().catch(e => {
                                console.log('Open video play failed:', e);
                                chest.state = 'open';
                                chest.textureIndex = chest.openImageId;
                                chest.currentVideo = null;
                            });
                            chest.currentVideo = openTexObj.video;
                            openTexObj.video.onended = () => {
                                chest.state = 'open';
                                chest.textureIndex = chest.openImageId;
                                chest.currentVideo = null;
                            };
                        } catch (err) {
                            console.error('Error starting open animation:', err);
                            chest.state = 'open';
                            chest.textureIndex = chest.openImageId;
                            chest.currentVideo = null;
                        }
                    } else {
                        chest.state = 'open';
                        chest.textureIndex = chest.openImageId;
                        chest.currentVideo = null;
                    }
                }
                currentOpenChest = chest;
                populateChestUI();
                chestUI.style.display = 'block';
                chestUI.style.opacity = '1';
            }
            updateInventoryUI() {
                updateSlots('inventoryGrid', this.inventory, 'player');
                updateSlots('playerGridInChest', this.inventory, 'player');
            }
            getVisible(camX, camY, width, height) {
                const pad = 20;
                this.reusableVisibleAABB.minX = camX - pad;
                this.reusableVisibleAABB.maxX = camX + width + pad;
                this.reusableVisibleAABB.minY = camY - pad;
                this.reusableVisibleAABB.maxY = camY + height + pad;
                const visible = [];
                for (const e of this.allEntities) {
                    const aabb = e.aabb;
                    let checkMinX = aabb.minX;
                    let checkMaxX = aabb.maxX;
                    let checkMinY = aabb.minY;
                    let checkMaxY = aabb.maxY;
                    if (e.isDecor) {
                        const offsetX = camX * (1 - e.parallaxSpeed);
                        const offsetY = camY * (1 - e.parallaxSpeed);
                        checkMinX += offsetX;
                        checkMaxX += offsetX;
                        checkMinY += offsetY;
                        checkMaxY += offsetY;
                    }
                    if (checkMaxX >= this.reusableVisibleAABB.minX && checkMinX <= this.reusableVisibleAABB.maxX && checkMaxY >= this.reusableVisibleAABB.minY && checkMinY <= this.reusableVisibleAABB.maxY) {
                        visible.push(e);
                    }
                }
                if (!visible.includes(this.player)) visible.push(this.player); 
                return visible;
            }
            update(dt) {
                for (const e of this.dynamics) {
                    e.update(dt, this);
                }

                if (this.player) {
                    let currentTele = null;
                    const playerAABB = this.player.aabb;
                    for (const other of this.statics) {
                        if (other.teleportTarget && aabbOverlap(playerAABB, other.aabb)) {
                            currentTele = other;
                            break;
                        }
                    }
                    if (currentTele) {
                        if (currentTele.teleportDelay === 0) {

                            this.player.pos.set(currentTele.teleportTarget.x, currentTele.teleportTarget.y);
                            this.player.vel.set(0, 0);
                            this.player.onGround = false;
                            this.player.currentTeleporter = null;
                            this.player.teleporterAccum = 0;
                            this.player.updateAABB();
                        } else {
                            if (this.player.currentTeleporter !== currentTele) {
                                this.player.currentTeleporter = currentTele;
                                this.player.teleporterAccum = 0;
                            }
                            this.player.teleporterAccum += dt;
                            if (this.player.teleporterAccum >= currentTele.teleportDelay) {
                                this.player.pos.set(currentTele.teleportTarget.x, currentTele.teleportTarget.y);
                                this.player.vel.set(0, 0);
                                this.player.onGround = false;
                                this.player.currentTeleporter = null;
                                this.player.teleporterAccum = 0;
                                this.player.updateAABB();
                            }
                        }
                    } else {
                        this.player.currentTeleporter = null;
                        this.player.teleporterAccum = 0;
                    }
                    this.checkNearbyChest();
                    this.checkNearbyRespawnBox();
                }
                const now = performance.now();
                if (now - this.lastSaveTime > config.autoSaveInterval) {
                    this.saveProgress().catch(console.error);
                    this.lastSaveTime = now;
                }
            }
            getInterpolatedPosition(entity, alpha) {
                this.reusableInterpPos.x = entity.pos.x;
                this.reusableInterpPos.y = entity.pos.y;
                return this.reusableInterpPos;
            }
            getInterpolatedVel(entity, alpha) {
                return entity.vel ? entity.vel.clone() : new Vec2(0, 0);
            }
            updateVideoTextures() {
                const gl = this.gl;
                for (const texObj of this.videoTextures) {
                    if (texObj && texObj.video && texObj.isReady && !texObj.video.paused && !texObj.video.ended && texObj.video.currentTime !== texObj.lastTime) {
                        gl.bindTexture(gl.TEXTURE_2D, texObj.glTex);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texObj.video);
                        texObj.lastTime = texObj.video.currentTime;
                    }
                }
            }
            draw(debug, camX, camY, frameCount, textures, renderAlpha, width, height) {
                const gl = this.gl;
                this.updateVideoTextures();
                getProjViewMatrix(width, height, camX, camY, projviewMatrix, false);
                if (this.uboMatrices) {
                    gl.bindBuffer(gl.UNIFORM_BUFFER, this.uboMatrices);
                    gl.bufferSubData(gl.UNIFORM_BUFFER, 0, projviewMatrix);
                }
                const visible = this.getVisible(camX, camY, width, height);

                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                let vertIdx = 0;
                let indexIdx = 0;
                let currentBatch = {indexStart: 0, numElements: 0, texIndex: -1};
                let batches = [];
                const whiteColor = new Float32Array([1, 1, 1, 1]);
                for (const e of visible) {
                    const interpPos = this.getInterpolatedPosition(e, renderAlpha);
                    let renderPosX = interpPos.x;
                    let renderPosY = interpPos.y;
                    if (e.isDecor) {
                        const offsetX = camX * (1 - e.parallaxSpeed);
                        const offsetY = camY * (1 - e.parallaxSpeed);
                        renderPosX += offsetX;
                        renderPosY += offsetY;
                    }
                    let thisTex = e.textureIndex ?? -1;
                    if (e instanceof Chest) {
                        if (e.state === 'closed') {
                            thisTex = e.closedImageId;
                        } else if (e.state === 'open') {
                            thisTex = e.openImageId;
                        } else if (e.state === 'opening') {
                            thisTex = e.openAnimId;
                        } else if (e.state === 'closing') {
                            thisTex = e.closeAnimId;
                        }
                        e.textureIndex = thisTex;
                    }
                    let effectiveTex = -1;
                    let isVideoTexture = false;
                    if (thisTex >= 0) {
                        const texObj = textures[thisTex];
                        let texReady = isTextureReady(texObj);
                        let hasDims = e.width != null && e.height != null;
                        if (texReady && (e.isDecor || hasDims)) {
                            effectiveTex = thisTex;
                            isVideoTexture = texObj && texObj.video !== undefined;
                        } else {
                            console.warn('Texture not ready for entity:', e.id || 'unknown');
                        }
                    }
                    let col = effectiveTex >= 0 ? whiteColor : e.colorArray;
                    const baseVert = vertIdx / 8;
                    const texCoords = this.reusableFixedTex;
                    for (let j = 0; j < 4; j++) {
                        const lp = e.shape.points[j];
                        const px = lp.x + renderPosX;
                        const py = lp.y + renderPosY;
                        const tx = texCoords[j * 2], ty = texCoords[j * 2 + 1];
                        this.vertData[vertIdx++] = px;
                        this.vertData[vertIdx++] = py;
                        this.vertData[vertIdx++] = tx;
                        this.vertData[vertIdx++] = ty;
                        this.vertData[vertIdx++] = col[0];
                        this.vertData[vertIdx++] = col[1];
                        this.vertData[vertIdx++] = col[2];
                        this.vertData[vertIdx++] = col[3];
                    }
                    if (currentBatch.numElements > 0 && effectiveTex !== currentBatch.texIndex) {
                        batches.push({...currentBatch});
                        currentBatch = {indexStart: indexIdx, numElements: 0, texIndex: effectiveTex};
                    } else if (currentBatch.numElements === 0) {
                        currentBatch = {indexStart: indexIdx, numElements: 0, texIndex: effectiveTex};
                    }
                    currentBatch.numElements += 6;
                    const base = baseVert;
                    this.indexData[indexIdx++] = base + 0;
                    this.indexData[indexIdx++] = base + 1;
                    this.indexData[indexIdx++] = base + 2;
                    this.indexData[indexIdx++] = base + 0;
                    this.indexData[indexIdx++] = base + 2;
                    this.indexData[indexIdx++] = base + 3;
                }
                if (currentBatch.numElements > 0) batches.push({...currentBatch});

                gl.bindBuffer(gl.ARRAY_BUFFER, this.batchPositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertData.subarray(0, vertIdx), gl.DYNAMIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.batchIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData.subarray(0, indexIdx), gl.DYNAMIC_DRAW);
                gl.bindVertexArray(this.vao);
                for (const b of batches) {
                    if (b.texIndex >= 0) {
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, glTextures[b.texIndex]);
                        gl.uniform1i(useTextureLoc, 1);
                    } else {
                        gl.uniform1i(useTextureLoc, 0);
                    }
                    gl.drawElements(gl.TRIANGLES, b.numElements, gl.UNSIGNED_SHORT, b.indexStart * 2);
                }
                if (debug) {
                    let debugVertIdx = 0;
                    for (const e of visible) {
                        const interpPos = this.getInterpolatedPosition(e, renderAlpha);
                        let debugPosX = interpPos.x;
                        let debugPosY = interpPos.y;
                        if (e.isDecor) {
                            const offsetX = camX * (1 - e.parallaxSpeed);
                            const offsetY = camY * (1 - e.parallaxSpeed);
                            debugPosX += offsetX;
                            debugPosY += offsetY;
                        }
                        const interpVel = this.getInterpolatedVel(e, renderAlpha);
                        if (e.isDecor) {
                            debugVertIdx = e.appendDebugLines(this.debugVertData, cyanColor, debugPosX, debugPosY, null, null, debugVertIdx, this);
                        } else {
                            debugVertIdx = e.appendDebugLines(this.debugVertData, redColor, debugPosX, debugPosY, interpVel, greenColor, debugVertIdx, this);
                        }
                    }
                    if (debugVertIdx > 0) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.debugLineBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, this.debugVertData.subarray(0, debugVertIdx), gl.DYNAMIC_DRAW);
                        gl.bindVertexArray(this.debugVao);
                        gl.uniform1i(useTextureLoc, 0);
                        gl.drawArrays(gl.LINES, 0, debugVertIdx / 8);
                    }
                }
            }
        }

        function createItemDiv(item, slotIdx, invType) {
            if (!item || typeof item !== 'string' || item === 'undefined') return null;
            const div = document.createElement('div');
            div.className = 'item';
            div.draggable = true;
            div.dataset.item = item;
            div.dataset.inventoryType = invType;
            div.dataset.slotIndex = slotIdx.toString();
            const img = document.createElement('img');
            const preloaded = itemImages[item];
            if (preloaded && preloaded.complete) {
                img.src = preloaded.src;
            } else {
                img.src = `https://placehold.co/32x32/0000FF/FFFFFF?text=${item.charAt(0).toUpperCase()}`;
                img.onerror = () => { img.src = 'https://placehold.co/32x32/FF0000/FFFFFF?text=?'; };
            }
            img.alt = item;
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = item.charAt(0).toUpperCase() + item.slice(1).toLowerCase();
            div.appendChild(img);
            div.appendChild(tooltip);
            div.addEventListener('dragstart', (e) => {
                const currentItem = e.currentTarget.dataset.item;
                const sourceInv = e.currentTarget.dataset.inventoryType;
                const sourceSlot = parseInt(e.currentTarget.dataset.slotIndex);
                e.dataTransfer.setData('text/plain', currentItem);
                e.dataTransfer.setData('sourceInventory', sourceInv);
                e.dataTransfer.setData('sourceSlot', sourceSlot.toString());
                e.dataTransfer.effectAllowed = 'move';
            });
            div.addEventListener('dragend', (e) => {
                console.log('Drag ended for item:', e.currentTarget.dataset.item);
            });
            return div;
        }

        function updateSlots(gridId, itemsArray, invType) {
            const grid = document.getElementById(gridId);
            if (!grid) return;
            const cleanItems = itemsArray.map(it => (typeof it === 'string' && it !== 'undefined') ? it : null);
            for (let i = 0; i < cleanItems.length; i++) {
                const slot = grid.children[i];
                if (!slot) continue;
                const item = cleanItems[i];
                let itemDiv = slot.querySelector('.item');
                if (item && !itemDiv) {
                    const newDiv = createItemDiv(item, i, invType);
                    if (newDiv) {
                        slot.appendChild(newDiv);
                        slot.classList.add('has-item');
                    }
                } else if (!item && itemDiv) {
                    itemDiv.remove();
                    slot.classList.remove('has-item');
                } else if (item && itemDiv) {
                    itemDiv.dataset.item = item;
                    itemDiv.dataset.inventoryType = invType;
                    itemDiv.dataset.slotIndex = i.toString();
                    const tooltip = itemDiv.querySelector('.tooltip');
                    tooltip.textContent = item.charAt(0).toUpperCase() + item.slice(1).toLowerCase();
                    const img = itemDiv.querySelector('img');
                    const preloaded = itemImages[item];
                    if (preloaded && preloaded.complete) {
                        img.src = preloaded.src;
                    } else {
                        img.src = `https://placehold.co/32x32/0000FF/FFFFFF?text=${item.charAt(0).toUpperCase()}`;
                    }
                }
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const item = e.dataTransfer.getData('text/plain');
            if (!item || item === 'undefined') return;

            const sourceInv = e.dataTransfer.getData('sourceInventory');
            const sourceSlotStr = e.dataTransfer.getData('sourceSlot');
            const sourceSlot = parseInt(sourceSlotStr);
            const targetInv = e.currentTarget.dataset.inventory;
            const targetSlot = parseInt(e.currentTarget.dataset.slot);

            const sourceMax = sourceInv === 'player' ? config.maxPlayerSlots : config.maxChestSlots;
            if (isNaN(sourceSlot) || sourceSlot < 0 || sourceSlot >= sourceMax ||
                isNaN(targetSlot) || targetSlot < 0 || targetSlot >= (targetInv === 'player' ? config.maxPlayerSlots : config.maxChestSlots)) {
                console.error('Invalid drop: sourceSlot=', sourceSlot, 'targetSlot=', targetSlot, 'item=', item);
                return;
            }

            console.log('Valid drop:', { item, sourceInv, sourceSlot, targetInv, targetSlot });

            if (sourceInv === targetInv) {
                if (sourceInv === 'player') {
                    const temp = world.inventory[sourceSlot];
                    world.inventory[sourceSlot] = world.inventory[targetSlot];
                    world.inventory[targetSlot] = temp || null;
                } else if (sourceInv === 'chest' && currentOpenChest) {
                    const temp = currentOpenChest.items[sourceSlot];
                    currentOpenChest.items[sourceSlot] = currentOpenChest.items[targetSlot];
                    currentOpenChest.items[targetSlot] = temp || null;
                }
            } else {
                if (targetInv === 'player' && (world.inventory[targetSlot] === null || world.inventory[targetSlot] === undefined)) {
                    world.inventory[targetSlot] = item;
                    if (sourceInv === 'chest' && currentOpenChest) {
                        currentOpenChest.items[sourceSlot] = null;
                    }
                } else if (targetInv === 'chest' && currentOpenChest && (currentOpenChest.items[targetSlot] === null || currentOpenChest.items[targetSlot] === undefined)) {
                    currentOpenChest.items[targetSlot] = item;
                    if (sourceInv === 'player') {
                        world.inventory[sourceSlot] = null;
                    }
                } else {
                    console.log('Drop ignored: target not empty');
                    return;
                }
            }

            if (sourceInv === 'player' || targetInv === 'player') {
                world.inventory = world.inventory.map(it => it === undefined ? null : it);
            }
            if (currentOpenChest && (sourceInv === 'chest' || targetInv === 'chest')) {
                currentOpenChest.items = currentOpenChest.items.map(it => it === undefined ? null : it);
            }

            world.updateInventoryUI();
            if (currentOpenChest) {
                updateSlots('chestGrid', currentOpenChest.items, 'chest');
            }
            world.saveProgress().catch(console.error);
        }

        function populateGrid(gridId, itemsArray, numSlots, invType) {
            const grid = document.getElementById(gridId);
            if (!grid) return;
            grid.innerHTML = '';
            const gridClass = invType === 'chest' ? 'grid-chest' : 'grid-inventory';
            grid.className = gridClass;
            for (let i = 0; i < numSlots; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.dataset.slot = i;
                slot.dataset.inventory = invType;
                slot.addEventListener('dragover', (e) => e.preventDefault());
                slot.addEventListener('drop', handleDrop);
                grid.appendChild(slot);
            }
        }

        function initUIGrids() {
            populateGrid('inventoryGrid', new Array(config.maxPlayerSlots).fill(null), config.maxPlayerSlots, 'player');
            populateGrid('playerGridInChest', new Array(config.maxPlayerSlots).fill(null), config.maxPlayerSlots, 'player');
            populateGrid('chestGrid', new Array(config.maxChestSlots).fill(null), config.maxChestSlots, 'chest');
        }

        function populateChestUI() {
            if (!currentOpenChest) return;
            updateSlots('chestGrid', currentOpenChest.items, 'chest');
            updateSlots('playerGridInChest', world.inventory, 'player');
        }

        function waitForTextures(textures) {
            return Promise.all(textures.map(texObj => {
                if (texObj instanceof HTMLImageElement) {
                    if (texObj.complete && texObj.naturalWidth > 0) return Promise.resolve();
                    return new Promise((resolve, reject) => {
                        texObj.onload = () => resolve();
                        texObj.onerror = reject;
                    });
                } else if (texObj && texObj.video) {
                    return new Promise((resolve, reject) => {
                        const onReady = () => {
                            texObj.isReady = true;
                            resolve();
                        };
                        texObj.video.addEventListener('canplay', onReady, {once: true});
                        texObj.video.addEventListener('error', reject, {once: true});
                        if (texObj.video.readyState >= 2) onReady();
                    });
                }
                return Promise.resolve();
            }));
        }

        const canvas = document.getElementById("game");
        const fadeOverlay = document.getElementById("fadeOverlay");
        const gl = canvas.getContext("webgl2", { alpha: true, desynchronized: true, powerPreference: "high-performance" });
        if (!gl) {
            alert("WebGL2 not supported");
        }
        const debugDiv = document.getElementById("debug");
        const inventoryDiv = document.getElementById("inventory");
        const closeInventoryBtn = document.getElementById("closeInventory");
        const chestUI = document.getElementById("chestUI");
        const closeChestBtn = document.getElementById("closeChest");
        let currentOpenChest = null;
        const program = createProgram(gl, vsSource, fsSource);
        if (!program) {
            alert("Shader program failed");
            throw new Error("Failed to create program");
        }
        gl.useProgram(program);
        const textureLoc = gl.getUniformLocation(program, "u_texture");
        const useTextureLoc = gl.getUniformLocation(program, "u_useTexture");
        gl.uniform1i(textureLoc, 0);

        const matricesBlockIndex = gl.getUniformBlockIndex(program, "Matrices");
        let uboMatrices = null;
        if (matricesBlockIndex !== gl.INVALID_INDEX) {
            gl.uniformBlockBinding(program, matricesBlockIndex, 0);
            uboMatrices = gl.createBuffer();
            gl.bindBuffer(gl.UNIFORM_BUFFER, uboMatrices);
            gl.bufferData(gl.UNIFORM_BUFFER, 48, gl.DYNAMIC_DRAW);
            gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboMatrices);
        } else {
            console.error("Uniform block 'Matrices' not found");
        }

        const cyanColor = new Float32Array([0, 1, 1, 1]);
        const redColor = hexToRgb("#f00");
        const greenColor = new Float32Array([0, 1, 0, 1]);
        const whiteColor = new Float32Array([1, 1, 1, 1]);
        const world = new World(gl);
        world.uboMatrices = uboMatrices;

        gl.bindVertexArray(world.vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, world.batchPositionBuffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 32, 0);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 8);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 32, 16);
        gl.enableVertexAttribArray(2);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, world.batchIndexBuffer);
        gl.bindVertexArray(null);

        gl.bindVertexArray(world.debugVao);
        gl.bindBuffer(gl.ARRAY_BUFFER, world.debugLineBuffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 32, 0);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 8);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 32, 16);
        gl.enableVertexAttribArray(2);
        gl.bindVertexArray(null);

        const textures = [];
        const glTextures = [];
        mapData.textures.forEach((url, i) => {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([128, 128, 128, 255]));
            let textureObj;
            if (url.match(/\.(webm|mp4)$/i)) {
                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                video.src = url;
                video.loop = false;
                video.muted = true;
                video.preload = 'auto';
                video.playbackRate = 1;
                textureObj = { video, isReady: false, glTex: tex, lastTime: 0 };
                world.videoTextures.push(textureObj);
                video.addEventListener('canplay', () => {
                    if (!textureObj.isReady) {
                        textureObj.isReady = true;
                        video.play().catch(e => console.log('Autoplay prevented:', e));
                    }
                });
                video.addEventListener('error', (e) => {
                    console.error('Video load error:', e);
                    textureObj.isReady = false;
                });
            } else {
                textureObj = new Image();
                textureObj.crossOrigin = "anonymous";
                textureObj.src = url;
                textureObj.onload = () => {
                    gl.bindTexture(gl.TEXTURE_2D, tex);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureObj);
                };
                textureObj.onerror = () => {
                    console.error('Image load error for:', url);
                    textureObj.src = 'https://placehold.co/80x80/808080/FFFFFF?text=Err';
                };
            }
            textures.push(textureObj);
            glTextures.push(tex);
        });

        initUIGrids();

        closeChestBtn.addEventListener('click', () => {
            if (currentOpenChest) {
                const chest = currentOpenChest;
                if (chest.state === 'open' || chest.state === 'opening') {
                    if (chest.currentVideo) {
                        chest.currentVideo.pause();
                        chest.currentVideo.onended = null;
                        chest.currentVideo = null;
                    }
                    chest.state = 'closing';
                    chest.textureIndex = chest.closeAnimId;
                    const closeTexObj = textures[chest.closeAnimId];
                    if (closeTexObj && closeTexObj.video) {
                        try {
                            closeTexObj.video.currentTime = 0;
                            closeTexObj.video.loop = false;
                            closeTexObj.video.play().catch(e => {
                                console.log('Close video play failed:', e);
                                chest.state = 'closed';
                                chest.textureIndex = chest.closedImageId;
                                chest.currentVideo = null;
                            });
                            chest.currentVideo = closeTexObj.video;
                            closeTexObj.video.onended = () => {
                                chest.state = 'closed';
                                chest.textureIndex = chest.closedImageId;
                                chest.currentVideo = null;
                            };
                        } catch (err) {
                            console.error('Error starting close animation:', err);
                            chest.state = 'closed';
                            chest.textureIndex = chest.closedImageId;
                            chest.currentVideo = null;
                        }
                    } else {
                        chest.state = 'closed';
                        chest.textureIndex = chest.closedImageId;
                        chest.currentVideo = null;
                    }
                }
                chestUI.style.display = 'none';
                currentOpenChest = null;
                world.saveProgress().catch(console.error);
            }
        });

        async function clearSave() {
            if (!world.db) return;
            try {
                const tx = world.db.transaction('progress', 'readwrite');
                const store = tx.objectStore('progress');
                await new Promise((res, rej) => {
                    const req = store.delete('current');
                    req.onsuccess = res;
                    req.onerror = rej;
                });
                world.player.pos.set(world.playerStartPos.x, world.playerStartPos.y);
                world.player.vel.set(0, 0);
                world.player.updateAABB();
                world.inventory.fill(null);
                world.updateInventoryUI();
                world.currentRespawnPos = world.playerStartPos.clone();
                world.respawnBoxes.forEach(box => box.setActive(false));
                if (inventoryOpen) {
                    inventoryOpen = false;
                    inventoryDiv.style.display = 'none';
                }
                if (currentOpenChest) {
                    closeChestBtn.click();
                    currentOpenChest = null;
                }
                console.log('Save cleared');
            } catch (e) {
                console.error('Clear failed', e);
            }
        }

        debugDiv.addEventListener('click', (e) => {
            if (e.target.id === 'clearSave') clearSave();
        });

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        document.addEventListener('contextmenu', e => e.preventDefault());

        let debugMode = false;
        let inventoryOpen = false;
        window.addEventListener("keydown", async (e) => {
            const keyCode = e.code;
            if (keyCode === config.debugKey) {
                debugMode = !debugMode;
            }
            if (config.ctrlForClear && e.ctrlKey && keyCode === config.clearStorageKey) {
                e.preventDefault();
                clearSave();
            }
            if (keyCode === config.godModeKey && world.player) {
                world.player.godMode = !world.player.godMode;
                console.log('God Mode:', world.player.godMode);
            }
            if (keyCode === config.infiniteJumpKey && world.player) {
                world.player.infiniteJump = !world.player.infiniteJump;
                console.log('Infinite Jump:', world.player.infiniteJump);
            }
            if (keyCode === config.noclipKey && world.player) {
                world.player.noclip = !world.player.noclip;
                console.log('Noclip:', world.player.noclip);
            }
            const wasPressed = world.keys[keyCode];
            world.keys[keyCode] = true;
            if (!wasPressed) {
                if (config.dashKeys.includes(keyCode)) {
                    if (world.player.dashTimer <= 0) {
                        world.player.dashTimer = config.dashDuration;
                    }
                }
                if (keyCode === config.chestKey && world.nearbyChest) {
                    world.openChestUI(world.nearbyChest, textures);
                }
                if (keyCode === config.respawnKey && world.nearbyRespawnBox) {
                    world.setRespawnAtBox(world.nearbyRespawnBox);
                }
                if (keyCode === config.inventoryKey) {
                    inventoryOpen = !inventoryOpen;
                    inventoryDiv.style.display = inventoryOpen ? 'block' : 'none';
                    if (inventoryOpen) world.updateInventoryUI();
                    else world.saveProgress().catch(console.error);
                }
            }
            if (keyCode === config.jumpKey) e.preventDefault();
        });
        window.addEventListener("keyup", e => world.keys[e.code] = false);

        closeInventoryBtn.addEventListener('click', () => {
            inventoryOpen = false;
            inventoryDiv.style.display = 'none';
            world.saveProgress().catch(console.error);
        });

        world.updateInventoryUI = () => {
            updateSlots('inventoryGrid', world.inventory, 'player');
            updateSlots('playerGridInChest', world.inventory, 'player');
        };

        async function initializeGame() {
            await world.initDB();
            await waitForTextures(textures);
            await world.loadMap(mapData, textures);
            world.updateInventoryUI();
        }
        initializeGame().catch(console.error);

        let lastTime = performance.now(), frameCount = 0, lastFPSTime = lastTime, fps = 60;
        let lastDebugTime = lastTime;
        let camX = 0, camY = 0;
        const cameraSmoothingRate = config.cameraSmoothing * 60;
        function loop(currentTime) {
            frameCount++;
            if (currentTime - lastFPSTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (currentTime - lastFPSTime));
                frameCount = 0;
                lastFPSTime = currentTime;
            }

            const delta = Math.min((currentTime - lastTime) / 1000, 1/30);
            lastTime = currentTime;

            world.update(delta);
            const targetCamX = world.player ? world.player.pos.x - canvas.width / 2 : camX;
            const targetCamY = world.player ? world.player.pos.y - canvas.height / 2 : camY;
            camX += (targetCamX - camX) * cameraSmoothingRate * delta;
            camY += (targetCamY - camY) * cameraSmoothingRate * delta;

            if (world.player) {
                world.draw(debugMode, camX, camY, frameCount, textures, 0, canvas.width, canvas.height);
                if (currentTime - lastDebugTime >= 100 && debugMode) {
                    const activeKeys = Object.keys(world.keys).filter(k => world.keys[k]).join(", ") || "None";
                    const interpPos = world.getInterpolatedPosition(world.player, 0);
                    const chestInfo = world.nearbyChest ? `${world.nearbyChest.id} (${world.nearbyChest.state})` : 'No chest';
                    const respawnInfo = world.nearbyRespawnBox ? `${world.nearbyRespawnBox.id} (${world.nearbyRespawnBox.active ? 'Active' : 'Inactive'})` : 'No respawn box';
                    const cheatsInfo = `God: ${world.player.godMode}, InfJump: ${world.player.infiniteJump}, Noclip: ${world.player.noclip}`;
                    debugDiv.innerHTML = `
                        <button id="clearSave">Clear Storage (Ctrl+Backspace)</button>
                        Player Debug<br>
                        pos: (${interpPos.x.toFixed(2)}, ${interpPos.y.toFixed(2)})<br>
                        vel: (${world.player.vel.x.toFixed(2)}, ${world.player.vel.y.toFixed(2)})<br>
                        onGround: ${world.player.onGround}<br>
                        groundAngle: ${world.player.groundAngle.toFixed(1)}<br>
                        z: ${world.player.z}<br>
                        dashing: ${world.player.isDashing}<br>
                        airJumpCooldown: ${world.player.airJumpCooldown.toFixed(2)}<br>
                        keys: ${activeKeys}<br>
                        fps: ${fps}<br>
                        ${chestInfo}<br>
                        ${respawnInfo}<br>
                        ${cheatsInfo}
                    `;
                    lastDebugTime = currentTime;
                }
            }
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>
</html>
