<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/assets/images/favicon/000000.png" media="(prefers-color-scheme: light)">
    <link rel="icon" href="/assets/images/favicon/ffffff.png" media="(prefers-color-scheme: dark)">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <title>Game Engine</title>
    <style>*{box-sizing:border-box;margin:0;padding:0}body{overflow:hidden;background:#0a0a0a;color:#b0d0ff;font-family:'Orbitron','Courier New',monospace;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}canvas{background:linear-gradient(135deg,#1a1a1a 0%,#2d2d2d 100%);display:block;width:100vw;height:100vh}#fadeOverlay{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000;opacity:0;z-index:10000;pointer-events:none}#loadingSpinner{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:50px;height:50px;border:5px solid rgba(176,208,255,0.3);border-top:5px solid #b0d0ff;border-radius:50%;animation:spin 1s linear infinite;z-index:10001;display:block}@keyframes spin{0%{transform:translate(-50%,-50%) rotate(0deg)}100%{transform:translate(-50%,-50%) rotate(360deg)}}#debug{position:fixed;top:20px;right:20px;background:rgba(0,0,0,0.4);padding:12px;border:1px dashed #b0d0ff;border-radius:8px;width:260px;font-size:11px;line-height:1.1;box-shadow:0 4px 15px rgba(0,0,0,0.1);backdrop-filter:blur(8px);user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;transition:all 0.3s ease}#debug:hover{box-shadow:0 0 20px rgba(176,208,255,0.3);border-color:#ffffff}#debug button{display:block;width:100%;padding:8px;background:linear-gradient(145deg,rgba(255,0,0,0.3),rgba(255,0,0,0.1));color:#ff6b6b;border:none;border-radius:0 0 8px 8px;cursor:pointer;font-family:inherit;font-size:12px;transition:all 0.2s;margin-bottom:12px}#debug button:hover{background:linear-gradient(145deg,rgba(255,0,0,0.5),rgba(255,0,0,0.2));color:white}#inventory{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0.9);width:450px;height:350px;background:linear-gradient(145deg,rgba(10,10,10,0.95),rgba(20,20,20,0.95));border:2px solid #b0d0ff;border-radius:16px;padding:24px;color:#b0d0ff;font-family:'Orbitron',monospace;font-size:14px;z-index:1000;display:none;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,0.3),0 0 15px rgba(176,208,255,0.05);animation:uiSlideIn 0.2s cubic-bezier(0.25,0.46,0.45,0.94);will-change:transform}@keyframes uiSlideIn{from{opacity:0;transform:translate(-50%,-50%) scale(0.9)}to{opacity:1;transform:translate(-50%,-50%) scale(1)}}#inventory h2{margin-bottom:16px;text-align:center;font-weight:700;font-size:18px;background:linear-gradient(90deg,#b0d0ff,#ffffff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;text-shadow:0 0 10px rgba(176,208,255,0.5)}#inventoryGrid{margin:16px 0;padding:12px;background:rgba(176,208,255,0.05);border-radius:12px;border:1px solid rgba(176,208,255,0.1)}#chestUI{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:550px;background:linear-gradient(145deg,rgba(10,10,10,0.95),rgba(20,20,20,0.95));border:2px solid #b0d0ff;border-radius:16px;padding:24px;color:#b0d0ff;font-family:'Orbitron',monospace;font-size:14px;z-index:1000;display:none;overflow-y:auto;box-shadow:0 10px 30px rgba(0,0,0,0.3),0 0 15px rgba(176,208,255,0.05);will-change:transform}#chestUI h2{margin-bottom:16px;text-align:center;font-weight:700;font-size:18px;background:linear-gradient(90deg,#b0d0ff,#ffffff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;text-shadow:0 0 10px rgba(176,208,255,0.5)}#chestSection,#playerSection{margin-bottom:24px;display:flex;flex-direction:column;background:rgba(176,208,255,0.05);border-radius:12px;padding:16px;border:1px solid rgba(176,208,255,0.1)}#chestSection h3,#playerSection h3{margin-bottom:8px;font-weight:600;font-size:14px;color:#ffffff}.grid-inventory{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin:12px 0}.grid-chest{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin:12px 0}.slot{width:48px;height:48px;border:2px solid rgba(176,208,255,0.3);display:flex;align-items:center;justify-content:center;background:linear-gradient(145deg,rgba(255,255,255,0.05),rgba(255,255,255,0.02));border-radius:8px;cursor:pointer;transition:all 0.2s ease;position:relative;overflow:hidden}.slot::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(176,208,255,0.1),transparent);transition:left 0.5s}.slot:hover::before{left:100%}.slot:hover{border-color:#b0d0ff;box-shadow:0 0 15px rgba(176,208,255,0.3);transform:scale(1.05)}.slot.has-item{border-color:#ffffff;box-shadow:inset 0 0 10px rgba(176,208,255,0.2)}.item{display:flex;align-items:center;cursor:grab;transition:transform 0.2s ease;z-index:10}.item:hover{transform:scale(1.1)}.item:active{cursor:grabbing}.item img{width:36px;height:36px;border-radius:6px;box-shadow:0 4px 8px rgba(0,0,0,0.3);filter:drop-shadow(0 0 5px rgba(176,208,255,0.5))}#closeInventory,#closeChest{position:absolute;top:12px;right:12px;background:linear-gradient(145deg,rgba(255,0,0,0.2),rgba(255,0,0,0.1));border:1px solid rgba(255,0,0,0.5);border-radius:50%;width:24px;height:24px;color:#ff6b6b;font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.2s ease}#closeInventory:hover,#closeChest:hover{background:linear-gradient(145deg,rgba(255,0,0,0.4),rgba(255,0,0,0.2));color:#ffffff;transform:scale(1.1);box-shadow:0 0 10px rgba(255,0,0,0.5)}.tooltip{position:absolute;bottom:100%;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.9);color:#b0d0ff;padding:6px 10px;border-radius:6px;font-size:12px;white-space:nowrap;opacity:0;pointer-events:none;transition:opacity 0.2s ease;z-index:20;backdrop-filter:blur(10px)}.slot:hover .tooltip{opacity:1}</style>
</head>
<body>
    <div id="loadingSpinner"></div>
    <canvas id="game"></canvas>
    <div id="fadeOverlay"></div>
    <div id="debug"></div>
    <div id="inventory">
        <button id="closeInventory">&times;</button>
        <h2>Inventory</h2>
        <div id="inventoryGrid"></div>
    </div>
    <div id="chestUI">
        <button id="closeChest">&times;</button>
        <h2>Chest Interactions</h2>
        <div id="chestSection">
            <h3>Chest Contents</h3>
            <div id="chestGrid" class="grid-chest"></div>
        </div>
        <div id="playerSection">
            <h3>Your Inventory</h3>
            <div id="playerGridInChest" class="grid-inventory"></div>
        </div>
    </div>
    <script>
        const config = {
            gravity: 900,
            playerSpeed: 200,
            jumpHeight: 600,
            airJumpCooldown: 1.5,
            dashDuration: 0.2,
            dashSpeed: 800,
            cameraSmoothing: 0.12,
            maxPlayerSlots: 12,
            maxChestSlots: 9,
            chestDetectionRadius: 100,
            respawnDetectionRadius: 1200,
            fadeDuration: 1,
            mostlyDarkPercentage: 0.8,
            autoSaveInterval: 10000,
            debugKey: "KeyD",
            inventoryKey: "KeyI",
            chestKey: "KeyE",
            respawnKey: "KeyR",
            dashKeys: ["ShiftLeft", "ShiftRight"],
            jumpKey: "Space",
            leftKey: "ArrowLeft",
            rightKey: "ArrowRight",
            clearStorageKey: "Backspace",
            ctrlForClear: true,
            godModeKey: "KeyG",
            infiniteJumpKey: "KeyJ",
            noclipKey: "KeyN",
            maxPhysicsSubSteps: 10,
            maxPhysicsStepsPerFrame: 20,
            cellSize: 400,
            maxVisibleEntities: 3000,
            saveThrottle: 500,
            collisionEpsilon: 0.1
        };
        const mapData = {"playerStart":{"x":0,"y":0,"w":50,"h":100,"zIndex":1,"angle":0},"textures":["https://hyperrushnet.github.io/the-fallen-kingdom/assets/textures/static/2025_10_29_0zb_Kleki.png","https://hyperrushnet.github.io/the-fallen-kingdom/assets/textures/static/2025_10_31_10r_Kleki.png","https://upload.wikimedia.org/wikipedia/commons/c/cb/Balsa_Wood_Texture.jpg","https://upload.wikimedia.org/wikipedia/commons/0/09/Artificial_wood.jpg","https://hyperrushnet.github.io/the-fallen-kingdom/assets/textures/animated/rickroll.webm","https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/Siam_lilacpoint.jpg/250px-Siam_lilacpoint.jpg"],"platforms":[{"id":"jgWo6uTND6pu-Os4J6efGYCzb","type":"platform","x":210,"y":100,"w":1200,"h":100,"angle":0,"texture":0,"zIndex":1},{"id":"kkjpb16uNZiC-wXbrlAZlZh6G","type":"platform","x":750,"y":-360,"w":100,"h":200,"angle":0,"texture":null,"zIndex":2},{"id":"8j6gnj4GmL6Z-yO60LctfFFzb","type":"platform","x":635,"y":-843,"w":400,"h":100,"angle":30,"texture":null,"zIndex":3},{"id":"edCMMNq3n6xB-pQMRIUBnzSQ0","type":"platform","x":900,"y":-210,"w":200,"h":100,"angle":0,"texture":null,"zIndex":4},{"id":"3rQKxqosrA06-8dkJiryN0Bbm","type":"platform","x":1077,"y":-241,"w":200,"h":100,"angle":-20,"texture":null,"zIndex":5},{"id":"X2Qnky1oVNud-IjZmQYypmDHg","type":"platform","x":1211,"y":-281,"w":100,"h":100,"angle":-10,"texture":null,"zIndex":6},{"id":"2KGvRRd1pYqF-lf6mZxwt59dc","type":"platform","x":1302,"y":-289,"w":100,"h":100,"angle":0,"texture":null,"zIndex":7},{"id":"oWxYgmS6AQWg-kyNXNHFKVwAI","type":"platform","x":1392,"y":-281,"w":100,"h":100,"angle":10,"texture":null,"zIndex":8},{"id":"8peAJm7lGCkV-kzrYFYGaCTDC","type":"platform","x":1526,"y":-240,"w":200,"h":100,"angle":20,"texture":null,"zIndex":9},{"id":"9vCbybOEpKba-kxu7XvSfB8SD","type":"platform","x":1410,"y":100,"w":1200,"h":100,"angle":0,"texture":null,"zIndex":1},{"id":"MS1PZMAEiRFM-dZFkoEtwGk7j","type":"platform","x":1250,"y":-360,"w":900,"h":200,"angle":0,"texture":null,"zIndex":11},{"id":"mB9AGahnURyG-SRwduaagJUTa","type":"platform","x":1491,"y":-510,"w":780,"h":100,"angle":0,"texture":null,"zIndex":12},{"id":"4mSqoDGYUcVg-uVvKKDYiEFyL","type":"platform","x":860,"y":-781,"w":200,"h":100,"angle":-20,"texture":null,"zIndex":13},{"id":"0vTEKctsJJgh-bojJAgRYlkSz","type":"platform","x":1093,"y":-839,"w":300,"h":100,"angle":-10,"texture":null,"zIndex":14},{"id":"CmBavJ0hZhFq-GrwUXjNqhTpr","type":"platform","x":1311,"y":-909,"w":200,"h":100,"angle":-30,"texture":null,"zIndex":15},{"id":"VqLONgs03hiY-ogv3zTN5M3dK","type":"platform","x":786,"y":-245,"w":141,"h":100,"angle":45,"texture":null,"zIndex":16},{"id":"Vb8HWAKBdL6Z-aIoE71xlQDgI","type":"platform","x":1650,"y":-210,"w":100,"h":100,"angle":0,"texture":null,"zIndex":17},{"id":"84t3a75ooIRX-T1OnrwMWNA6B","type":"platform","x":1529,"y":-979,"w":300,"h":100,"angle":-10,"texture":null,"zIndex":18},{"id":"gE7XXXicjEat-mnS07sjDfPvx","type":"platform","x":1739,"y":-913,"w":300,"h":100,"angle":45,"texture":null,"zIndex":19},{"id":"wR44RJanvFEX-xjzmUm1QIC83","type":"platform","x":1831,"y":-701,"w":100,"h":283,"angle":0,"texture":null,"zIndex":20},{"id":"9RsFfEXShyPx-L3bz8ljUsu0C","type":"platform","x":2310,"y":50,"w":600,"h":200,"angle":0,"texture":null,"zIndex":1},{"id":"wFUMitBwRH8N-jaQEV6NVDoea","type":"platform","x":1795,"y":-394,"w":450,"h":235,"angle":-40,"texture":null,"zIndex":22},{"id":"IAJZ6SZzR4YH-bq4lnwKOYhsj","type":"platform","x":1969,"y":-515,"w":355,"h":175,"angle":-20,"texture":null,"zIndex":23},{"id":"h8UAI1ADfe9H-R4jmVGaQc9xO","type":"platform","x":2295,"y":-605,"w":355,"h":175,"angle":-10,"texture":null,"zIndex":24},{"id":"rZaZix5aGw88-qwNz0CJUpQKs","type":"platform","x":3441,"y":-186,"w":100,"h":20,"angle":0,"texture":1,"zIndex":27},{"id":"zlUUglmdDa54-WEb8AuvqA7xS","type":"platform","x":3771,"y":-237,"w":100,"h":20,"angle":0,"texture":1,"zIndex":28},{"id":"pTqWy92PbcBF-Pwa8dvWqg7M9","type":"platform","x":2910,"y":-42,"w":100,"h":20,"angle":0,"texture":1,"zIndex":29},{"id":"A3ckQ4o67yQp-xqTd68CPc0Vx","type":"platform","x":3199,"y":-52,"w":100,"h":20,"angle":0,"texture":1,"zIndex":30},{"id":"GWX8BWSXmc7L-d30Ee41JSOpy","type":"platform","x":3984,"y":-417,"w":100,"h":20,"angle":0,"texture":1,"zIndex":31},{"id":"F3cbLQKZGswe-OzeWvsmhx3KC","type":"platform","x":3673,"y":-574,"w":100,"h":20,"angle":0,"texture":1,"zIndex":32},{"id":"jURZ7N1idbLU-ilSWg1t84xuZ","type":"deadly","x":2910,"y":-22,"w":98,"h":20,"angle":0,"texture":null,"zIndex":33},{"id":"hwOm68RaIRHX-zEXB3Ze04DaI","type":"deadly","x":3199,"y":-32,"w":98,"h":20,"angle":0,"texture":null,"zIndex":34},{"id":"zzmsdIG86uol-ifMTnU8xQMB1","type":"deadly","x":3441,"y":-166,"w":98,"h":20,"angle":0,"texture":null,"zIndex":35},{"id":"872NIw92j9aD-hA8iQGKGtXbU","type":"deadly","x":3771,"y":-217,"w":98,"h":20,"angle":0,"texture":null,"zIndex":36},{"id":"BlhZ9dgvWdWB-kiHylVXZiObj","type":"deadly","x":3984,"y":-397,"w":98,"h":20,"angle":0,"texture":null,"zIndex":37},{"id":"z39vM1L7cE5Q-bB9RBVbfTk8a","type":"deadly","x":3673,"y":-554,"w":98,"h":20,"angle":0,"texture":null,"zIndex":38},{"id":"raAYBYWQSgvh-2ULmY9IOfiNv","type":"platform","x":3385,"y":450,"w":2750,"h":600,"angle":0,"texture":null,"zIndex":39},{"id":"p8jDcXstfhOM-QSNUJnBykSV3","type":"platform","x":4460,"y":50,"w":600,"h":200,"angle":0,"texture":null,"zIndex":40},{"id":"v0WiMvC6M2qK-kDjUXzqeANwX","type":"platform","x":4650,"y":-370,"w":800,"h":400,"angle":0,"texture":null,"zIndex":41},{"id":"uCFZiV6yv4UN-SadspmUsg5FV","type":"platform","x":3957,"y":-682,"w":100,"h":20,"angle":0,"texture":1,"zIndex":42},{"id":"W3GH8M6LJkLs-TZBvsjZntFjg","type":"deadly","x":3957,"y":-662,"w":98,"h":20,"angle":0,"texture":null,"zIndex":43},{"id":"W0fXvWWTxMol-OMpY660ni3d1","type":"platform","x":4150,"y":-1030,"w":600,"h":200,"angle":-10,"texture":null,"zIndex":44},{"id":"UVRO79gn60Fa-qR4McfpfUNuv","type":"platform","x":4648,"y":-1006,"w":721,"h":200,"angle":7,"texture":null,"zIndex":45},{"id":"1BUqI8Ofi6ms-oRamBygx0D9l","type":"platform","x":4200,"y":-420,"w":100,"h":300,"angle":0,"texture":null,"zIndex":46},{"id":"6gehgTx3BD6O-xXi9vvMSMLBI","type":"platform","x":4228,"y":-250,"w":145,"h":80,"angle":45,"texture":null,"zIndex":47},{"id":"pkpDsWpzctKL-5OwQigDTbIma","type":"platform","x":3551,"y":-1070,"w":721,"h":200,"angle":15,"texture":null,"zIndex":48},{"id":"3LmKr3UGZEbo-oZqx3tKCAMDs","type":"platform","x":2952,"y":-1109,"w":600,"h":200,"angle":-10,"texture":null,"zIndex":49},{"id":"eoyRw3WubzR1-DbMIf038kjjL","type":"platform","x":2576,"y":-855,"w":600,"h":200,"angle":-55,"texture":null,"zIndex":50},{"id":"7KIgFCDRwdF8-U0yUPGrWyEqm","type":"platform","x":4366,"y":-639,"w":433,"h":138,"angle":0,"texture":null,"zIndex":53},{"id":"VOvckp2nyAe5-Q8U76TEKoQeO","type":"deadly","x":3385,"y":140,"w":1550,"h":20,"angle":0,"texture":null,"zIndex":54},{"id":"udUfT3MNj0Cq-KJ7Zsh70Ue5q","type":"platform","x":1308,"y":-88,"w":220,"h":20,"angle":0,"texture":null,"zIndex":57},{"id":"SGG8pcYQm6mQ-KelDCAx3MBhP","type":"chest","x":1309,"y":-135,"w":75,"h":75,"angle":0,"texture":null,"zIndex":1,"detectionRadius":100,"items":["resin"],"closedTextureUrl":"https://upload.wikimedia.org/wikipedia/commons/c/cb/Balsa_Wood_Texture.jpg","openTextureUrl":"https://upload.wikimedia.org/wikipedia/commons/0/09/Artificial_wood.jpg","openingTextureUrl":"https://hyperrushnet.github.io/the-fallen-kingdom/assets/textures/animated/rickroll.webm","closingTextureUrl":"https://hyperrushnet.github.io/the-fallen-kingdom/assets/textures/animated/rickroll.webm","closedTextureId":2,"openTextureId":3,"openingTextureId":4,"closingTextureId":4},{"id":"1QDwJg388Lnv-bRNjkmuWhFaJ","type":"platform","x":2156,"y":-739,"w":700,"h":300,"angle":0,"texture":null,"zIndex":59},{"id":"grUfrpf3npIq-vvdKdShPsT0r","type":"platform","x":2174,"y":-1035,"w":948,"h":300,"angle":0,"texture":null,"zIndex":60},{"id":"PUWunsdRlN0O-JKgeIBhYmDtE","type":"platform","x":4810,"y":350,"w":100,"h":800,"angle":0,"texture":null,"zIndex":1},{"id":"bUCHEPHsDCZW-Ox8b1I5c4cng","type":"platform","x":5010,"y":350,"w":100,"h":800,"angle":0,"texture":null,"zIndex":62},{"id":"f3m3R5o2BQzW-fI3gFRtTA3ER","type":"respawn","x":1731,"y":-610,"w":100,"h":100,"angle":0,"texture":null,"zIndex":0,"detectionRadius":100,"passThrough":true,"respawnX":1731,"respawnY":-610,"inactiveTextureUrl":"https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/Siam_lilacpoint.jpg/250px-Siam_lilacpoint.jpg","activeTextureUrl":"https://hyperrushnet.github.io/the-fallen-kingdom/assets/textures/animated/rickroll.webm","inactiveTextureId":5,"activeTextureId":4},{"id":"s4ftRYK69unh-IKn2TTHVOxnO","type":"platform","x":4737,"y":742,"w":225,"h":100,"angle":-20,"texture":null,"zIndex":63},{"id":"rN7172iSnntt-GLPMwjrY0lfi","type":"platform","x":4690,"y":1120,"w":1000,"h":20,"angle":0,"texture":null,"zIndex":64},{"id":"zI1dgj8I8BWA-6uDB6qk0FfSt","type":"platform","x":4909,"y":1051,"w":100,"h":120,"angle":0,"texture":null,"zIndex":65},{"id":"aoRvamxwYmdf-mxZJkk6XQuSJ","type":"platform","x":4653,"y":1050,"w":100,"h":120,"angle":0,"texture":null,"zIndex":66},{"id":"HN2pjwU9h3pR-zDc5QMtfn1Cl","type":"deadly","x":4781,"y":1100,"w":156,"h":20,"angle":0,"texture":null,"zIndex":67},{"id":"ncegTFgLA2ie-UIS0Jz3UxrTa","type":"platform","x":5009,"y":1060,"w":100,"h":101,"angle":0,"texture":null,"zIndex":68},{"id":"YuOloEFFHQcJ-lKIRAOclyWAg","type":"platform","x":5239,"y":894,"w":99,"h":472,"angle":0,"texture":null,"zIndex":71},{"id":"Hb9Cl8lLcBc1-9G31QRE5ybJ1","type":"deadly","x":5124,"y":1100,"w":131,"h":20,"angle":0,"texture":null,"zIndex":72},{"id":"KfWQ2cWax8XM-1SrsbkWwcYhU","type":"platform","x":4509,"y":772,"w":225,"h":100,"angle":-20,"texture":null,"zIndex":73},{"id":"XVDyG5oeWfyK-MXRKrj6BNOYm","type":"deadly","x":4525,"y":1100,"w":156,"h":20,"angle":0,"texture":null,"zIndex":74},{"id":"S3jcz6H5Kdi3-QTt9oIlsSaI1","type":"platform","x":4433,"y":1070,"w":100,"h":80,"angle":0,"texture":null,"zIndex":75},{"id":"nHTuuzFr2lg5-eJf0lmyAmTUy","type":"platform","x":510,"y":646,"w":3000,"h":20,"angle":0,"texture":null,"zIndex":76},{"id":"K0RHA1sXBDd2-lvt0XylyamGb","type":"platform","x":607,"y":503,"w":100,"h":20,"angle":0,"texture":null,"zIndex":77},{"id":"w3PyjShRKPBT-JN7NYdICS750","type":"platform","x":627,"y":523,"w":100,"h":20,"angle":0,"texture":null,"zIndex":78},{"id":"Jgm9XilaZgJW-iVv1ipBYmkI5","type":"platform","x":647,"y":543,"w":100,"h":20,"angle":0,"texture":null,"zIndex":79},{"id":"KhDCogl2q45H-ysbKNagRswS0","type":"platform","x":667,"y":563,"w":100,"h":20,"angle":0,"texture":null,"zIndex":80},{"id":"nfn4IDi9xfT0-sw3rQWm77HfL","type":"platform","x":687,"y":583,"w":100,"h":20,"angle":0,"texture":null,"zIndex":81},{"id":"dU8HuZCUYBdV-qbiebGFg3VzX","type":"platform","x":707,"y":603,"w":100,"h":20,"angle":0,"texture":null,"zIndex":82},{"id":"xSV9F4soFJpL-6ZlsZJKqrmXD","type":"platform","x":727,"y":623,"w":100,"h":20,"angle":0,"texture":null,"zIndex":83},{"id":"ccesEYNTRBSq-0yiYROMwdIbw","type":"platform","x":747,"y":643,"w":100,"h":20,"angle":0,"texture":null,"zIndex":84},{"id":"WWyPOejMYeLh-1A7ST9mPeLLr","type":"platform","x":767,"y":663,"w":100,"h":20,"angle":0,"texture":null,"zIndex":85}],"decor":[{"id":"HOJZq7kFaugY-LxBMwFAE7Nd0","x":1408,"y":-168,"w":150,"h":20,"angle":90,"texture":null,"zIndex":55,"parallaxSpeed":1},{"id":"HsNHzCP3C4Dt-1K9hrQ34VdzX","x":1208,"y":-168,"w":150,"h":20,"angle":90,"texture":null,"zIndex":56,"parallaxSpeed":1}]};
        const allItems = new Set();
        mapData.platforms.forEach(plat => {
            if (plat.type === "chest" && plat.items) {
                plat.items.forEach(item => allItems.add(item));
            }
        });
        const itemImages = {};
        Array.from(allItems).forEach(item => {
            const img = new Image();
            img.src = `https://placehold.co/32x32/0000FF/FFFFFF?text=${item.charAt(0).toUpperCase()}`;
            itemImages[item] = img;
        });
        class Vec2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            add(v) {
                return new Vec2(this.x + v.x, this.y + v.y);
            }
            sub(v) {
                return new Vec2(this.x - v.x, this.y - v.y);
            }
            scale(s) {
                return new Vec2(this.x * s, this.y * s);
            }
            dot(v) {
                return this.x * v.x + this.y * v.y;
            }
            perp() {
                return new Vec2(-this.y, this.x);
            }
            len() {
                return Math.hypot(this.x, this.y);
            }
            lenSq() {
                return this.x * this.x + this.y * this.y;
            }
            norm() {
                const l = this.len();
                return l ? this.scale(1 / l) : new Vec2();
            }
            clone() {
                return new Vec2(this.x, this.y);
            }
            set(x, y) {
                this.x = x;
                this.y = y;
                return this;
            }
        }
        function aabbOverlap(a, b) {
            return a.maxX >= b.minX && a.minX <= b.maxX && a.maxY >= b.minY && a.minY <= b.maxY;
        }
        class Polygon {
            constructor(points) {
                this.points = points.map(p => new Vec2(p.x, p.y));
                this.axes = this.getAxes();
            }
            getAxes() {
                const axes = [];
                for (let i = 0; i < this.points.length; i++) {
                    const edge = this.points[(i + 1) % this.points.length].sub(this.points[i]);
                    const axis = edge.perp().norm();
                    if (axis.len() > 0) axes.push(axis);
                }
                return axes;
            }
            getAABB(posX, posY) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of this.points) {
                    const px = p.x + posX;
                    const py = p.y + posY;
                    minX = Math.min(minX, px);
                    minY = Math.min(minY, py);
                    maxX = Math.max(maxX, px);
                    maxY = Math.max(maxY, py);
                }
                return { minX, minY, maxX, maxY };
            }
            project(axis, posX, posY, proj) {
                proj.min = Infinity;
                proj.max = -Infinity;
                for (const p of this.points) {
                    const px = p.x + posX;
                    const py = p.y + posY;
                    const projVal = px * axis.x + py * axis.y;
                    proj.min = Math.min(proj.min, projVal);
                    proj.max = Math.max(proj.max, projVal);
                }
            }
            static overlap(A, posAX, posAY, B, posBX, posBY, projA, projB) {
                const axes = [...A.axes, ...B.axes];
                let overlap = Infinity, smallestAxis = null;
                for (const axis of axes) {
                    if (axis.lenSq() < 1e-6) continue;
                    A.project(axis, posAX, posAY, projA);
                    B.project(axis, posBX, posBY, projB);
                    const o = Math.min(projA.max, projB.max) - Math.max(projA.min, projB.min);
                    if (o < 1e-6) return null;
                    if (o < overlap) {
                        overlap = o;
                        smallestAxis = axis;
                    }
                }
                if (!smallestAxis) return null;
                const dX = posAX - posBX;
                const dY = posAY - posBY;
                const dLen = Math.hypot(dX, dY);
                let dirX = 0, dirY = -1;
                if (dLen > 1e-6) {
                    dirX = dX / dLen;
                    dirY = dY / dLen;
                }
                let axisX = smallestAxis.x;
                let axisY = smallestAxis.y;
                const dirDotAxis = dirX * axisX + dirY * axisY;
                if (dirDotAxis < 0) {
                    axisX = -axisX;
                    axisY = -axisY;
                }
                return { axis: { x: axisX, y: axisY }, overlap };
            }
        }
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return new Float32Array([r, g, b, 1]);
        }
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        function createProgram(gl, vsource, fsource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsource);
            if (!vs) return null;
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsource);
            if (!fs) return null;
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }
        const projviewMatrix = new Float32Array(12);
        function getProjViewMatrix(width, height, camX, camY, matrix, isUI = false) {
            if (isUI) {
                matrix[0] = 2 / width; matrix[1] = 0; matrix[2] = 0; matrix[3] = 0;
                matrix[4] = 0; matrix[5] = -2 / height; matrix[6] = 0; matrix[7] = 0;
                matrix[8] = -1; matrix[9] = 1; matrix[10] = 1; matrix[11] = 0;
            } else {
                matrix[0] = 2 / width; matrix[1] = 0; matrix[2] = 0; matrix[3] = 0;
                matrix[4] = 0; matrix[5] = -2 / height; matrix[6] = 0; matrix[7] = 0;
                matrix[8] = -1 - 2 * camX / width; matrix[9] = 1 + 2 * camY / height;
                matrix[10] = 1; matrix[11] = 0;
            }
            return matrix;
        }
        const vsSource = `#version 300 es
precision mediump float;
layout(std140) uniform Matrices {
    mat3 u_matrix;
};
layout(location = 0) in vec2 a_position;
layout(location = 1) in vec2 a_texcoord;
layout(location = 2) in vec4 a_color;
out vec2 v_texcoord;
out vec4 v_color;
void main() {
    gl_Position = vec4((u_matrix * vec3(a_position, 1.0)).xy, 0.0, 1.0);
    v_texcoord = a_texcoord;
    v_color = a_color;
}`;
        const fsSource = `#version 300 es
precision mediump float;
in vec2 v_texcoord;
in vec4 v_color;
uniform sampler2D u_texture;
uniform bool u_useTexture;
out vec4 fragColor;
void main() {
    if (u_useTexture) {
        fragColor = texture(u_texture, v_texcoord) * v_color;
    } else {
        fragColor = v_color;
    }
}`;
        function isTextureReady(texObj) {
            if (!texObj) return false;
            if (texObj && texObj.ready) return true;
            if (texObj instanceof HTMLImageElement) {
                return texObj.complete && texObj.naturalWidth > 0;
            }
            return false;
        }
        class BaseShape {
            constructor(x, y, w, h, angleDeg, z, textureIndex, isDecor = false, parallaxSpeed = 0.7) {
                this.pos = new Vec2(x, y);
                this.width = w;
                this.height = h;
                this.angle = angleDeg * Math.PI / 180;
                this.z = z || 0;
                this.textureIndex = textureIndex;
                this.isDecor = isDecor;
                this.parallaxSpeed = parallaxSpeed;
                const hw = w / 2, hh = h / 2;
                const cos = Math.cos(this.angle), sin = Math.sin(this.angle);
                this.localPoints = [
                    new Vec2(-hw * cos - hh * sin, -hw * sin + hh * cos),
                    new Vec2(hw * cos - hh * sin, hw * sin + hh * cos),
                    new Vec2(hw * cos + hh * sin, hw * sin - hh * cos),
                    new Vec2(-hw * cos + hh * sin, -hw * sin - hh * cos)
                ];
                this.shape = new Polygon(this.localPoints);
                this.updateAABB();
                this.lineArray = new Float32Array(16);
                this.colorArray = hexToRgb("#4af");
                if (!isDecor) {
                    this.vel = new Vec2(0, 0);
                    this.onGround = false;
                    this.groundNormal = new Vec2(0, -1);
                    this.oldOnGround = false;
                    this.groundAngle = 0;
                }
            }
            updateAABB() {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                const posX = this.pos.x;
                const posY = this.pos.y;
                for (const p of this.localPoints) {
                    const px = p.x + posX;
                    const py = p.y + posY;
                    minX = Math.min(minX, px);
                    minY = Math.min(minY, py);
                    maxX = Math.max(maxX, px);
                    maxY = Math.max(maxY, py);
                }
                this.aabb = { minX, minY, maxX, maxY };
            }
            updateLineArray(posX, posY) {
                const la = this.lineArray;
                for (let i = 0; i < 4; i++) {
                    const curr = this.localPoints[i];
                    const next = this.localPoints[(i + 1) % 4];
                    const cx = curr.x + posX;
                    const cy = curr.y + posY;
                    const nx = next.x + posX;
                    const ny = next.y + posY;
                    const base = i * 4;
                    la[base + 0] = cx;
                    la[base + 1] = cy;
                    la[base + 2] = nx;
                    la[base + 3] = ny;
                }
            }
            appendDebugLines(arr, lineColor, posX, posY, vel = null, velColor = null, startIdx = 0, world) {
                this.updateLineArray(posX, posY);
                const la = this.lineArray;
                let idx = startIdx;
                for (let k = 0; k < 8; k++) {
                    const i = k * 2;
                    arr[idx++] = la[i];
                    arr[idx++] = la[i + 1];
                    arr[idx++] = 0;
                    arr[idx++] = 0;
                    arr[idx++] = lineColor[0];
                    arr[idx++] = lineColor[1];
                    arr[idx++] = lineColor[2];
                    arr[idx++] = lineColor[3];
                }
                if (vel && vel.len() > 0) {
                    const scale = 0.1;
                    arr[idx++] = posX;
                    arr[idx++] = posY;
                    arr[idx++] = 0;
                    arr[idx++] = 0;
                    arr[idx++] = velColor[0];
                    arr[idx++] = velColor[1];
                    arr[idx++] = velColor[2];
                    arr[idx++] = velColor[3];
                    arr[idx++] = posX + vel.x * scale;
                    arr[idx++] = posY + vel.y * scale;
                    arr[idx++] = 0;
                    arr[idx++] = 0;
                    arr[idx++] = velColor[0];
                    arr[idx++] = velColor[1];
                    arr[idx++] = velColor[2];
                    arr[idx++] = velColor[3];
                }
                return idx;
            }
        }
        class Entity extends BaseShape {
            constructor(x, y, w, h, angleDeg, color, isStatic = false, z, textureIndex, parallaxSpeed) {
                super(x, y, w, h, angleDeg, z, textureIndex, false, parallaxSpeed);
                this.colorArray = hexToRgb(color);
                this.isStatic = isStatic;
                this.deadly = false;
                this.passThrough = false;
                this.jumpBoost = 0;
                this.teleportTarget = null;
                this.teleportDelay = 0;
                this.lastDirection = 1;
                this.dashTimer = 0;
                this.isDashing = false;
                this.diagonalDash = false;
                this.oldDashTimer = 0;
                this.jumpPressed = false;
                this.airJumpCooldown = 0;
                this.airJumpCooldownMax = config.airJumpCooldown;
                this.currentTeleporter = null;
                this.teleporterAccum = 0;
                this.justLanded = false;
                this.landedEntity = null;
                this.isDying = false;
                this.godMode = false;
                this.infiniteJump = false;
                this.noclip = false;
                if (isStatic) this.updateAABB();
            }
            update(dt, world) {
                if (this.isStatic) return;
                if (this.isDying && !this.godMode) {
                    this.vel.set(0, 0);
                    return;
                }
                const dashStarted = this.dashTimer > 0 && this.oldDashTimer <= 0;
                if (this.airJumpCooldown > 0 && !this.infiniteJump) {
                    this.airJumpCooldown -= dt;
                    if (this.airJumpCooldown < 0) this.airJumpCooldown = 0;
                }
                this.oldOnGround = this.onGround;
                this.onGround = false;
                this.justLanded = false;
                this.landedEntity = null;
                let input_speed;
                let g_vec_x = 0;
                let g_vec_y = 0;
                if (this.dashTimer > 0) {
                    this.dashTimer -= dt;
                    this.isDashing = true;
                    input_speed = 0;
                    g_vec_y = 0;
                    if (dashStarted && world.keys[config.jumpKey]) {
                        this.diagonalDash = true;
                    }
                } else {
                    this.isDashing = false;
                    this.diagonalDash = false;
                    input_speed = world.keys[config.leftKey] ? -config.playerSpeed : world.keys[config.rightKey] ? config.playerSpeed : 0;
                    if (!this.godMode) g_vec_y = config.gravity * dt;
                }
                const up_x = 0;
                const up_y = -1;
                if (this.oldOnGround && !this.noclip) {
                    const tangent_x = -this.groundNormal.y;
                    const tangent_y = this.groundNormal.x;
                    const normalComp = this.vel.x * this.groundNormal.x + this.vel.y * this.groundNormal.y;
                    this.vel.x = tangent_x * input_speed + this.groundNormal.x * normalComp;
                    this.vel.y = tangent_y * input_speed + this.groundNormal.y * normalComp;
                } else {
                    this.vel.x = input_speed;
                }
                if (this.isDashing) {
                    const angle = Math.PI / 4;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    if (this.diagonalDash) {
                        this.vel.x = this.lastDirection * config.dashSpeed * cos;
                        this.vel.y = -config.dashSpeed * sin;
                    } else {
                        this.vel.x = this.lastDirection * config.dashSpeed;
                        this.vel.y = 0;
                    }
                }
                this.vel.x += g_vec_x;
                this.vel.y += g_vec_y;
                const disp_x = this.vel.x * dt;
                const disp_y = this.vel.y * dt;
                let numSteps = Math.max(1, Math.ceil(Math.hypot(disp_x, disp_y) / 0.5));
                numSteps = Math.min(config.maxPhysicsSubSteps, numSteps);
                const sub_disp_x = disp_x / numSteps;
                const sub_disp_y = disp_y / numSteps;
                let currentPosX = this.pos.x;
                let currentPosY = this.pos.y;
                const beta = 0.5;
                const epsilon = config.collisionEpsilon;
                const projA = {min: 0, max: 0};
                const projB = {min: 0, max: 0};
                let has_ground = false;
                let maxGroundOverlap = -Infinity;
                let bestGround = null;
                let ground_normal_x = 0;
                let ground_normal_y = 0;
                for (let step = 0; step < numSteps; step++) {
                    let testPosX = currentPosX + sub_disp_x;
                    let testPosY = currentPosY + sub_disp_y;
                    if (this.noclip) {
                        currentPosX = testPosX;
                        currentPosY = testPosY;
                        continue;
                    }
                    for (let i = 0; i < 2; i++) {
                        let deadlyCollision = false;
                        let collisions = [];
                        let testAABB = this.shape.getAABB(testPosX, testPosY);
                        for (const other of world.getNearby(testPosX, testPosY)) {
                            if (!other.shape || other === this || other.isDecor) continue;
                            const otherAABB = other.aabb;
                            if (!aabbOverlap(testAABB, otherAABB)) continue;
                            const res = Polygon.overlap(this.shape, testPosX, testPosY, other.shape, other.pos.x, other.pos.y, projA, projB);
                            if (res) {
                                if (other.teleportTarget && this === world.player) {}
                                else if (other.deadly && this === world.player && !this.godMode) {
                                    deadlyCollision = true;
                                } else if (other.passThrough && this === world.player) {}
                                else {
                                    let axis = res.axis;
                                    const d_x = testPosX - other.pos.x;
                                    const d_y = testPosY - other.pos.y;
                                    const dLen = Math.hypot(d_x, d_y);
                                    let dir_x = 0;
                                    let dir_y = -1;
                                    if (dLen > 1e-6) {
                                        dir_x = d_x / dLen;
                                        dir_y = d_y / dLen;
                                    }
                                    const dirDotAxis = dir_x * axis.x + dir_y * axis.y;
                                    let push_x = axis.x;
                                    let push_y = axis.y;
                                    if (dirDotAxis < 0) {
                                        push_x = -push_x;
                                        push_y = -push_y;
                                    }
                                    collisions.push({ push_x, push_y, overlap: res.overlap, other });
                                }
                            }
                        }
                        if (deadlyCollision) {
                            if (this.godMode) {
                                break;
                            }
                            shakeScreen(30);
                            this.isDying = true;
                            this.vel.set(0, 0);
                            const fadeDuration = config.fadeDuration;
                            const mostlyDarkPercentage = config.mostlyDarkPercentage;
                            fadeOverlay.style.transition = `opacity ${fadeDuration}s ease-out`;
                            fadeOverlay.style.opacity = '1';
                            setTimeout(() => {
                                this.pos.set(world.currentRespawnPos.x, world.currentRespawnPos.y);
                                this.updateAABB();
                                this.vel.set(0, 0);
                                this.onGround = false;
                                setTimeout(() => {
                                    fadeOverlay.style.transition = `opacity ${fadeDuration}s ease-in`;
                                    fadeOverlay.style.opacity = '0';
                                    setTimeout(() => {
                                        this.isDying = false;
                                        world.scheduleSave();
                                    }, fadeDuration * 1000);
                                }, fadeDuration * (1 - mostlyDarkPercentage) * 1000);
                            }, fadeDuration * mostlyDarkPercentage * 1000);
                            break;
                        }
                        let deepCollisions = collisions.filter(c => c.overlap >= epsilon);
                        const groupedDeep = new Map();
                        for (const col of deepCollisions) {
                            const key = `${col.push_x.toFixed(4)},${col.push_y.toFixed(4)}`;
                            if (!groupedDeep.has(key)) {
                                groupedDeep.set(key, {push_x: col.push_x, push_y: col.push_y, maxOverlap: -Infinity, bestOther: null});
                            }
                            const g = groupedDeep.get(key);
                            if (col.overlap > g.maxOverlap) {
                                g.maxOverlap = col.overlap;
                                g.bestOther = col.other;
                            }
                        }
                        for (const [key, g] of groupedDeep) {
                            const upward = g.push_x * up_x + g.push_y * up_y;
                            if (upward > 0.01) {
                                has_ground = true;
                                if (g.maxOverlap > maxGroundOverlap) {
                                    maxGroundOverlap = g.maxOverlap;
                                    bestGround = g.bestOther;
                                    ground_normal_x = g.push_x;
                                    ground_normal_y = g.push_y;
                                }
                            }
                            const push_dist = beta * g.maxOverlap;
                            testPosX += g.push_x * push_dist;
                            testPosY += g.push_y * push_dist;
                            const vn = this.vel.x * g.push_x + this.vel.y * g.push_y;
                            if (vn < 0) {
                                this.vel.x -= g.push_x * vn;
                                this.vel.y -= g.push_y * vn;
                            }
                        }
                        let remainingCollisions = [];
                        testAABB = this.shape.getAABB(testPosX, testPosY);
                        for (const other of world.getNearby(testPosX, testPosY)) {
                            if (!other.shape || other === this || other.isDecor) continue;
                            const otherAABB = other.aabb;
                            if (!aabbOverlap(testAABB, otherAABB)) continue;
                            const res = Polygon.overlap(this.shape, testPosX, testPosY, other.shape, other.pos.x, other.pos.y, projA, projB);
                            if (res) {
                                if (other.teleportTarget && this === world.player) {}
                                else if (other.deadly && this === world.player) {}
                                else if (other.passThrough && this === world.player) {}
                                else {
                                    let axis = res.axis;
                                    const d_x = testPosX - other.pos.x;
                                    const d_y = testPosY - other.pos.y;
                                    const dLen = Math.hypot(d_x, d_y);
                                    let dir_x = 0;
                                    let dir_y = -1;
                                    if (dLen > 1e-6) {
                                        dir_x = d_x / dLen;
                                        dir_y = d_y / dLen;
                                    }
                                    const dirDotAxis = dir_x * axis.x + dir_y * axis.y;
                                    let push_x = axis.x;
                                    let push_y = axis.y;
                                    if (dirDotAxis < 0) {
                                        push_x = -push_x;
                                        push_y = -push_y;
                                    }
                                    remainingCollisions.push({ push_x, push_y, overlap: res.overlap, other });
                                }
                            }
                        }
                        let deepRemaining = remainingCollisions.filter(c => c.overlap >= epsilon);
                        const groupedRemaining = new Map();
                        for (const col of deepRemaining) {
                            const key = `${col.push_x.toFixed(4)},${col.push_y.toFixed(4)}`;
                            if (!groupedRemaining.has(key)) {
                                groupedRemaining.set(key, {push_x: col.push_x, push_y: col.push_y, maxOverlap: -Infinity, bestOther: null});
                            }
                            const g = groupedRemaining.get(key);
                            if (col.overlap > g.maxOverlap) {
                                g.maxOverlap = col.overlap;
                                g.bestOther = col.other;
                            }
                        }
                        for (const [key, g] of groupedRemaining) {
                            const upward = g.push_x * up_x + g.push_y * up_y;
                            if (upward > 0.01) {
                                has_ground = true;
                                if (g.maxOverlap > maxGroundOverlap) {
                                    maxGroundOverlap = g.maxOverlap;
                                    bestGround = g.bestOther;
                                    ground_normal_x = g.push_x;
                                    ground_normal_y = g.push_y;
                                }
                            }
                            const push_dist = g.maxOverlap;
                            testPosX += g.push_x * push_dist;
                            testPosY += g.push_y * push_dist;
                        }
                    }
                    currentPosX = testPosX;
                    currentPosY = testPosY;
                }
                this.pos.x = currentPosX;
                this.pos.y = currentPosY;
                this.updateAABB();
                this.onGround = has_ground;
                if (has_ground && !this.oldOnGround) {
                    this.justLanded = true;
                    this.landedEntity = bestGround;
                    this.groundNormal.set(ground_normal_x, ground_normal_y);
                }
                if (this.justLanded && this.landedEntity && this.landedEntity.jumpBoost > 0) {
                    this.vel.y = -this.landedEntity.jumpBoost;
                    this.airJumpCooldown = 0;
                    this.onGround = false;
                }
                if (this.onGround && !this.oldOnGround) {
                    this.airJumpCooldown = 0;
                }
                const jumpThisFrame = world.keys[config.jumpKey] && !this.jumpPressed;
                this.jumpPressed = world.keys[config.jumpKey];
                if (jumpThisFrame) {
                    let doJump = false;
                    if (this.oldOnGround || this.infiniteJump) {
                        doJump = true;
                    } else if (this.airJumpCooldown <= 0) {
                        doJump = true;
                        this.airJumpCooldown = this.airJumpCooldownMax;
                    }
                    if (doJump) {
                        if (this.isDashing) {
                            this.diagonalDash = true;
                            const angle = Math.PI / 4;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            this.vel.x = this.lastDirection * config.dashSpeed * cos;
                            this.vel.y = -config.dashSpeed * sin;
                        } else {
                            this.vel.y = -config.jumpHeight;
                            this.vel.x = input_speed;
                        }
                        this.onGround = false;
                    }
                }
                if (this.onGround && !this.isDashing && !this.noclip) {
                    const tangent_x = -this.groundNormal.y;
                    const tangent_y = this.groundNormal.x;
                    this.vel.x = tangent_x * input_speed;
                    this.vel.y = tangent_y * input_speed;
                    const proj = this.vel.dot(this.groundNormal);
                    if (proj < 0) {
                        this.vel = this.vel.sub(this.groundNormal.scale(proj));
                    }
                    const g_dot_t = g_vec_x * tangent_x + g_vec_y * tangent_y;
                    this.pos.x -= tangent_x * g_dot_t;
                    this.pos.y -= tangent_y * g_dot_t;
                    this.groundAngle = Math.acos(Math.max(-1, Math.min(1, this.groundNormal.dot({x: up_x, y: up_y})))) * 180 / Math.PI;
                }
                if (!this.isDashing && input_speed !== 0) {
                    this.lastDirection = input_speed > 0 ? 1 : -1;
                }
                this.oldDashTimer = this.dashTimer;
            }
        }
        class Chest extends Entity {
            constructor(x, y, w, h, angleDeg, items, z, detectionRadius = config.chestDetectionRadius, closedTex = 0, openTex = 1, openingTex = 2, closingTex = 3) {
                super(x, y, w, h, angleDeg, "#8B4513", true, z, closedTex);
                this.items = items || new Array(config.maxChestSlots).fill(null);
                this.opened = false;
                this.detectionRadius = detectionRadius;
                this.state = 'closed';
                this.isAnimating = false;
                this.animationTime = 0;
                this.animationBaseId = -1;
                this.animationType = '';
                this.targetState = '';
                this.targetTexId = -1;
                this.closedTextureId = closedTex;
                this.openTextureId = openTex;
                this.openingTextureId = openingTex;
                this.closingTextureId = closingTex;
                this.textureIndex = this.closedTextureId;
                this.id = '';
            }
        }
        class RespawnBox extends Entity {
            constructor(x, y, w, h, angleDeg, z, detectionRadius = config.respawnDetectionRadius, passThrough = false, respawnX = x, respawnY = y, inactiveTex = -1, activeTex = -1) {
                super(x, y, w, h, angleDeg, "#FFD700", true, z, inactiveTex);
                this.detectionRadius = detectionRadius;
                this.passThrough = passThrough;
                this.respawnPos = new Vec2(respawnX, respawnY);
                this.active = false;
                this.isAnimating = false;
                this.animationTime = 0;
                this.animationBaseId = -1;
                this.animationType = '';
                this.targetTexId = -1;
                this.inactiveTextureId = inactiveTex;
                this.activeTextureId = activeTex;
                this.textureIndex = this.inactiveTextureId;
                this.id = '';
            }
            setActive(active) {
                this.active = active;
                if (active) {
                    this.animationBaseId = this.activeTextureId;
                    const animData = animationData[this.animationBaseId];
                    if (animData) {
                        this.isAnimating = true;
                        this.animationType = 'loop';
                        this.animationTime = 0;
                        this.textureIndex = this.animationBaseId;
                    } else {
                        this.isAnimating = false;
                        this.textureIndex = this.animationBaseId;
                    }
                } else {
                    this.isAnimating = false;
                    this.textureIndex = this.inactiveTextureId;
                    this.animationTime = 0;
                }
            }
        }
        async function extractFrames(videoUrl, gl) {
            const video = document.createElement('video');
            video.crossOrigin = 'anonymous';
            video.src = videoUrl;
            video.muted = true;
            video.preload = 'auto';
            await new Promise((resolve, reject) => {
                video.onloadedmetadata = () => resolve();
                video.onerror = reject;
            });
            const duration = video.duration;
            let numFrames = 1;
            let frameRate = 10;
            if (isFinite(duration) && duration > 0) {
                numFrames = Math.min(60, Math.ceil(duration * frameRate));
            }
            const frames = [];
            let videoWidth = video.videoWidth || 256;
            let videoHeight = video.videoHeight || 256;
            for (let f = 0; f < numFrames; f++) {
                video.currentTime = f / frameRate;
                await new Promise(resolve => {
                    video.onseeked = resolve;
                });
                const canvas = document.createElement('canvas');
                canvas.width = videoWidth;
                canvas.height = videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const tex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
                frames.push({ ready: true, glTex: tex });
                canvas.remove();
            }
            video.remove();
            return frames;
        }
        const animationData = {};
        class World {
            constructor(gl) {
                this.gl = gl;
                this.statics = [];
                this.dynamics = [];
                this.decors = [];
                this.chests = [];
                this.respawnBoxes = [];
                this.keys = {};
                this.cellSize = config.cellSize;
                this.spatialHash = new Map();
                this.player = null;
                this.playerStartPos = new Vec2(0, 0);
                this.currentRespawnPos = new Vec2(0, 0);
                this.allEntities = [];
                this.inventory = new Array(config.maxPlayerSlots).fill(null);
                this.nearbyChest = null;
                this.nearbyRespawnBox = null;
                this.batchPositionBuffer = gl.createBuffer();
                this.batchIndexBuffer = gl.createBuffer();
                this.debugLineBuffer = gl.createBuffer();
                this.vao = gl.createVertexArray();
                this.debugVao = gl.createVertexArray();
                this.maxQuads = 4096;
                this.maxVerts = this.maxQuads * 4;
                this.maxIndices = this.maxQuads * 6;
                this.vertData = new Float32Array(this.maxVerts * 8);
                this.indexData = new Uint16Array(this.maxIndices);
                this.debugVertData = new Float32Array(1024);
                this.uboMatrices = null;
                this.lastSaveTime = 0;
                this.savePending = false;
                this.nearbyCache = [];
                this.projA = {min: 0, max: 0};
                this.projB = {min: 0, max: 0};
                this.reusableVec = new Vec2();
                this.reusableTestPos = new Vec2();
                this.reusableDir = new Vec2();
                this.reusableTangent = new Vec2();
                this.reusableNormalComp = 0;
                this.reusableDisp = new Vec2();
                this.reusableVelLen = 0;
                this.reusableScale = 0;
                this.reusableProjUp = 0;
                this.reusableGVecDot = 0;
                this.reusableInterpPos = new Vec2();
                this.reusableOffset = new Vec2();
                this.reusableRenderPos = new Vec2();
                this.reusableDebugPos = new Vec2();
                this.reusableInterpVel = new Vec2();
                this.reusableTexCoords = new Float32Array(8);
                this.reusableFixedTex = new Float32Array([0, 1, 1, 1, 1, 0, 0, 0]);
                this.reusableStandardTex = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
                this.reusableCol = new Float32Array(4);
                this.reusablePointsBuf = new Float32Array(8);
                this.reusableLineArray = new Float32Array(16);
                this.reusableVelArrowStart = new Float32Array(4);
                this.reusableVelArrowEnd = new Float32Array(4);
                this.reusableVertDataChunk = new Float32Array(512);
                this.reusableIndexDataChunk = new Uint16Array(256);
                this.reusableBatch = {indexStart: 0, numElements: 0, texIndex: -1};
                this.reusableVisibleAABB = {minX: 0, minY: 0, maxX: 0, maxY: 0 };
                this.prevPlayerPos = new Vec2();
            }
            scheduleSave() {
                if (this.savePending) return;
                this.savePending = true;
                setTimeout(() => {
                    this.saveProgress();
                    this.savePending = false;
                }, 0);
            }
            saveProgress() {
                const data = {
                    position: { x: this.player.pos.x, y: this.player.pos.y },
                    inventory: this.inventory.map(item => (typeof item === 'string' && item !== 'undefined') ? item : null).filter(Boolean),
                    respawnPos: { x: this.currentRespawnPos.x, y: this.currentRespawnPos.y },
                    chests: this.chests.map(c => ({ id: c.id, items: c.items.map(item => (typeof item === 'string' && item !== 'undefined') ? item : null).filter(Boolean) })),
                    lastUpdate: Date.now()
                };
                try {
                    localStorage.setItem('gameSave', JSON.stringify(data));
                } catch (e) {}
            }
            loadProgress() {
                try {
                    const json = localStorage.getItem('gameSave');
                    if (!json) return null;
                    const saved = JSON.parse(json);
                    if (saved.inventory) {
                        saved.inventory = saved.inventory.map(item => item || null);
                    }
                    if (saved.chests) {
                        saved.chests.forEach(schest => {
                            const chest = this.chests.find(c => c.id === schest.id);
                            if (chest) {
                                chest.items = schest.items.map(item => item || null);
                            }
                        });
                    }
                    return saved || null;
                } catch (e) {
                    return null;
                }
            }
            async loadMap(data, textures) {
                if (data.playerStart) {
                    const w = data.playerStart.w || 50;
                    const h = data.playerStart.h || 100;
                    const playerShape = new Polygon([
                        { x: -w/2, y: -h/2 },
                        { x: w/2, y: -h/2 },
                        { x: w/2, y: h/2 },
                        { x: -w/2, y: h/2 }
                    ]);
                    this.playerStartPos.set(data.playerStart.x || 0, data.playerStart.y || 0);
                    this.currentRespawnPos.set(this.playerStartPos.x, this.playerStartPos.y);
                    this.player = new Entity(data.playerStart.x || 0, data.playerStart.y || 0, w, h, data.playerStart.angle || 0, "#4af", false, data.playerStart.zIndex || 1);
                    this.player.shape = playerShape;
                    this.add(this.player);
                    this.allEntities.push(this.player);
                }
                const platforms = data.platforms || [];
                for (const plat of platforms) {
                    let color = "#555";
                    if (plat.type === "wall") color = "#666";
                    else if (plat.type === "deadly") color = "#f00";
                    else if (plat.type === "teleporter") color = "#00f";
                    else if (plat.type === "jumpPad") color = "#0f0";
                    else if (plat.type === "chest") {
                        const detectionRadius = plat.detectionRadius || config.chestDetectionRadius;
                        const closedTex = plat.closedTextureId !== undefined ? plat.closedTextureId : 0;
                        const openTex = plat.openTextureId !== undefined ? plat.openTextureId : 1;
                        const openingTex = plat.openingTextureId !== undefined ? plat.openingTextureId : 2;
                        const closingTex = plat.closingTextureId !== undefined ? plat.closingTextureId : 3;
                        const chestItems = new Array(config.maxChestSlots).fill(null);
                        if (plat.items) {
                            plat.items.slice(0, config.maxChestSlots).forEach((item, idx) => {
                                chestItems[idx] = item;
                            });
                        }
                        const chest = new Chest(plat.x || 0, plat.y || 0, plat.w || 80, plat.h || 80, plat.angle || 0, chestItems, plat.zIndex || 0, detectionRadius, closedTex, openTex, openingTex, closingTex);
                        chest.id = plat.id;
                        this.add(chest);
                        this.chests.push(chest);
                        this.allEntities.push(chest);
                        continue;
                    } else if (plat.type === "respawn") {
                        const detectionRadius = plat.detectionRadius || config.respawnDetectionRadius;
                        const passThrough = plat.passThrough || false;
                        const respawnX = plat.respawnX !== undefined ? plat.respawnX : (plat.x || 0);
                        const respawnY = plat.respawnY !== undefined ? plat.respawnY : (plat.y || 0);
                        const inactiveTex = plat.inactiveTextureId !== undefined ? plat.inactiveTextureId : -1;
                        const activeTex = plat.activeTextureId !== undefined ? plat.activeTextureId : -1;
                        const respawnBox = new RespawnBox(plat.x || 0, plat.y || 0, plat.w || 60, plat.h || 60, plat.angle || 0, plat.zIndex || 0, detectionRadius, passThrough, respawnX, respawnY, inactiveTex, activeTex);
                        respawnBox.id = plat.id;
                        respawnBox.passThrough = passThrough;
                        this.add(respawnBox);
                        this.respawnBoxes.push(respawnBox);
                        this.allEntities.push(respawnBox);
                        continue;
                    }
                    const e = new Entity(plat.x || 0, plat.y || 0, plat.w || 100, plat.h || 20, plat.angle || 0, color, true, plat.zIndex || 0, plat.texture !== null ? plat.texture : -1);
                    if (plat.type === "deadly") e.deadly = true;
                    if (plat.passThrough) e.passThrough = true;
                    if (plat.type === "teleporter") {
                        e.teleportTarget = new Vec2(plat.targetX || 0, plat.targetY || 0);
                        e.teleportDelay = plat.teleportDelay || 0;
                    }
                    if (plat.type === "jumpPad") {
                        e.jumpBoost = plat.jumpBoost || 800;
                    }
                    this.add(e);
                    this.allEntities.push(e);
                }
                for (const d of data.decor || []) {
                    const dd = new BaseShape(d.x || 0, d.y || 0, d.w || 100, d.h || 100, d.angle || 0, d.zIndex || 0, d.texture !== null ? d.texture : -1, true, d.parallaxSpeed || 0.7);
                    this.decors.push(dd);
                    this.allEntities.push(dd);
                }
                this.chests.forEach(chest => {
                    chest.state = 'closed';
                    chest.textureIndex = chest.closedTextureId;
                });
                this.allEntities.sort((a, b) => a.z - b.z);
                this.rebuildSpatialHash();
                const saved = await this.loadProgress();
                if (saved) {
                    this.player.pos.set(saved.position.x, saved.position.y);
                    this.inventory = [...saved.inventory];
                    this.currentRespawnPos.set(saved.respawnPos.x, saved.respawnPos.y);
                    this.respawnBoxes.forEach(box => box.setActive(false));
                    this.respawnBoxes.forEach(box => {
                        if (Math.abs(box.respawnPos.x - this.currentRespawnPos.x) < 10 && Math.abs(box.respawnPos.y - this.currentRespawnPos.y) < 10) {
                            box.setActive(true);
                        }
                    });
                    this.updateInventoryUI();
                }
            }
            add(e) {
                if (e.isDecor) this.decors.push(e);
                else if (e.isStatic) this.statics.push(e);
                else this.dynamics.push(e);
            }
            getHash(posX, posY) {
                return `${Math.floor(posX / this.cellSize)},${Math.floor(posY / this.cellSize)}`;
            }
            rebuildSpatialHash() {
                this.spatialHash.clear();
                const allStaticLike = [...this.statics, ...this.decors, ...this.chests, ...this.respawnBoxes];
                for (const e of allStaticLike) {
                    const aabb = e.aabb;
                    const expand = e.isDecor ? 150 : 50;
                    const minX = Math.floor((aabb.minX - expand) / this.cellSize);
                    const maxX = Math.floor((aabb.maxX + expand) / this.cellSize);
                    const minY = Math.floor((aabb.minY - expand) / this.cellSize);
                    const maxY = Math.floor((aabb.maxY + expand) / this.cellSize);
                    for (let x = minX; x <= maxX; x++) {
                        for (let y = minY; y <= maxY; y++) {
                            const h = `${x},${y}`;
                            if (!this.spatialHash.has(h)) this.spatialHash.set(h, []);
                            this.spatialHash.get(h).push(e);
                        }
                    }
                }
            }
            getNearby(posX, posY) {
                this.nearbyCache.length = 0;
                this.nearbyCache.push(...this.dynamics);
                const cx = Math.floor(posX / this.cellSize), cy = Math.floor(posY / this.cellSize);
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const h = `${cx + dx},${cy + dy}`;
                        if (this.spatialHash.has(h)) {
                            this.spatialHash.get(h).forEach(e => {
                                if (!e.isDecor) this.nearbyCache.push(e);
                            });
                        }
                    }
                }
                return this.nearbyCache;
            }
            checkNearbyChest() {
                this.nearbyChest = null;
                let closestChest = null;
                let minDist = Infinity;
                const px = this.player.pos.x;
                const py = this.player.pos.y;
                for (const chest of this.chests) {
                    const dx = chest.pos.x - px;
                    const dy = chest.pos.y - py;
                    const dist = Math.hypot(dx, dy);
                    if (dist < chest.detectionRadius && dist < minDist) {
                        minDist = dist;
                        closestChest = chest;
                    }
                }
                this.nearbyChest = closestChest;
            }
            checkNearbyRespawnBox() {
                this.nearbyRespawnBox = null;
                let closestBox = null;
                let minDist = Infinity;
                const px = this.player.pos.x;
                const py = this.player.pos.y;
                for (const box of this.respawnBoxes) {
                    const dx = box.pos.x - px;
                    const dy = box.pos.y - py;
                    const dist = Math.hypot(dx, dy);
                    if (dist < box.detectionRadius && dist < minDist) {
                        minDist = dist;
                        closestBox = box;
                    }
                }
                this.nearbyRespawnBox = closestBox;
            }
            setRespawnAtBox(box) {
                if (!box) return;
                this.respawnBoxes.forEach(b => {
                    if (b !== box) {
                        b.setActive(false);
                    }
                });
                box.setActive(true);
                this.currentRespawnPos.set(box.respawnPos.x, box.respawnPos.y);
                this.scheduleSave();
            }
            openChestUI(chest, textures) {
                if (!chest) return;
                if (chest.state === 'open' || chest.state === 'opening') {}
                else if (chest.state === 'closed') {
                    const animData = animationData[chest.openingTextureId];
                    if (animData) {
                        chest.state = 'opening';
                        chest.isAnimating = true;
                        chest.animationTime = 0;
                        chest.animationBaseId = chest.openingTextureId;
                        chest.animationType = 'oneshot';
                        chest.targetState = 'open';
                        chest.targetTexId = chest.openTextureId;
                    } else {
                        chest.state = 'open';
                        chest.textureIndex = chest.openTextureId;
                        chest.isAnimating = false;
                    }
                }
                currentOpenChest = chest;
                populateChestUI();
                chestUI.style.display = 'block';
                chestUI.style.opacity = '1';
            }
            updateInventoryUI() {
                updateSlots('inventoryGrid', this.inventory, 'player');
                updateSlots('playerGridInChest', this.inventory, 'player');
            }
            getVisible(camX, camY, width, height) {
                const pad = 20;
                this.reusableVisibleAABB.minX = camX - pad;
                this.reusableVisibleAABB.maxX = camX + width + pad;
                this.reusableVisibleAABB.minY = camY - pad;
                this.reusableVisibleAABB.maxY = camY + height + pad;
                const visible = [];
                for (const e of this.allEntities) {
                    const aabb = e.aabb;
                    let checkMinX = aabb.minX;
                    let checkMaxX = aabb.maxX;
                    let checkMinY = aabb.minY;
                    let checkMaxY = aabb.maxY;
                    if (e.isDecor) {
                        const offsetX = camX * (1 - e.parallaxSpeed);
                        const offsetY = camY * (1 - e.parallaxSpeed);
                        checkMinX += offsetX;
                        checkMaxX += offsetX;
                        checkMinY += offsetY;
                        checkMaxY += offsetY;
                    }
                    if (checkMaxX >= this.reusableVisibleAABB.minX && checkMinX <= this.reusableVisibleAABB.maxX && checkMaxY >= this.reusableVisibleAABB.minY && checkMinY <= this.reusableVisibleAABB.maxY) {
                        visible.push(e);
                        if (visible.length >= config.maxVisibleEntities) break;
                    }
                }
                if (!visible.includes(this.player)) visible.push(this.player);
                return visible;
            }
            getInterpolatedPosition(entity, alpha) {
                if (alpha <= 0 || entity !== this.player) {
                    this.reusableInterpPos.set(entity.pos.x, entity.pos.y);
                    return this.reusableInterpPos;
                }
                const dx = entity.pos.x - this.prevPlayerPos.x;
                const dy = entity.pos.y - this.prevPlayerPos.y;
                this.reusableInterpPos.set(this.prevPlayerPos.x + dx * alpha, this.prevPlayerPos.y + dy * alpha);
                return this.reusableInterpPos;
            }
            getInterpolatedVel(entity, alpha) {
                if (entity.vel) {
                    this.reusableInterpVel.set(entity.vel.x, entity.vel.y);
                    return this.reusableInterpVel;
                } else {
                    this.reusableInterpVel.set(0, 0);
                    return this.reusableInterpVel;
                }
            }
            update(dt) {
                for (const e of this.dynamics) {
                    e.update(dt, this);
                }
                this.chests.forEach(chest => {
                    if (chest.isAnimating) {
                        chest.animationTime += dt;
                        const animData = animationData[chest.animationBaseId];
                        if (animData) {
                            const frameRate = animData.frameRate;
                            let currentFrame;
                            if (chest.animationType === 'loop') {
                                currentFrame = Math.floor(chest.animationTime * frameRate) % animData.numFrames;
                            } else {
                                currentFrame = Math.min(Math.floor(chest.animationTime * frameRate), animData.numFrames - 1);
                                if (currentFrame >= animData.numFrames - 1) {
                                    chest.isAnimating = false;
                                    chest.state = chest.targetState;
                                    chest.textureIndex = chest.targetTexId;
                                    chest.animationTime = 0;
                                }
                            }
                            if (chest.isAnimating) {
                                chest.textureIndex = chest.animationBaseId + currentFrame;
                            }
                        } else {
                            chest.isAnimating = false;
                            chest.state = chest.targetState;
                            chest.textureIndex = chest.targetTexId;
                            chest.animationTime = 0;
                        }
                    }
                });
                this.respawnBoxes.forEach(box => {
                    if (box.isAnimating) {
                        box.animationTime += dt;
                        const animData = animationData[box.animationBaseId];
                        if (animData) {
                            const frameRate = animData.frameRate;
                            const currentFrame = Math.floor(box.animationTime * frameRate) % animData.numFrames;
                            box.textureIndex = box.animationBaseId + currentFrame;
                        }
                    }
                });
                if (this.player) {
                    let currentTele = null;
                    const playerAABB = this.player.aabb;
                    for (const other of this.statics) {
                        if (other.teleportTarget && aabbOverlap(playerAABB, other.aabb)) {
                            currentTele = other;
                            break;
                        }
                    }
                    if (currentTele) {
                        if (currentTele.teleportDelay === 0) {
                            this.player.pos.set(currentTele.teleportTarget.x, currentTele.teleportTarget.y);
                            this.player.vel.set(0, 0);
                            this.player.onGround = false;
                            this.player.currentTeleporter = null;
                            this.player.teleporterAccum = 0;
                            this.player.updateAABB();
                        } else {
                            if (this.player.currentTeleporter !== currentTele) {
                                this.player.currentTeleporter = currentTele;
                                this.player.teleporterAccum = 0;
                            }
                            this.player.teleporterAccum += dt;
                            if (this.player.teleporterAccum >= currentTele.teleportDelay) {
                                this.player.pos.set(currentTele.teleportTarget.x, currentTele.teleportTarget.y);
                                this.player.vel.set(0, 0);
                                this.player.onGround = false;
                                this.player.currentTeleporter = null;
                                this.player.teleporterAccum = 0;
                                this.player.updateAABB();
                            }
                        }
                    } else {
                        this.player.currentTeleporter = null;
                        this.player.teleporterAccum = 0;
                    }
                    this.checkNearbyChest();
                    this.checkNearbyRespawnBox();
                }
                const now = performance.now();
                if (now - this.lastSaveTime > config.saveThrottle) {
                    this.scheduleSave();
                    this.lastSaveTime = now;
                }
            }
            draw(debug, camX, camY, frameCount, textures, renderAlpha, width, height) {
                const gl = this.gl;
                getProjViewMatrix(width, height, camX, camY, projviewMatrix, false);
                if (this.uboMatrices) {
                    gl.bindBuffer(gl.UNIFORM_BUFFER, this.uboMatrices);
                    gl.bufferSubData(gl.UNIFORM_BUFFER, 0, projviewMatrix);
                }
                let visible = this.getVisible(camX, camY, width, height);
                visible.sort((a, b) => a.z - b.z);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                let vertIdx = 0;
                let indexIdx = 0;
                let currentBatch = {indexStart: 0, numElements: 0, texIndex: -1};
                let batches = [];
                const whiteColor = new Float32Array([1, 1, 1, 1]);
                for (const e of visible) {
                    const interpPos = this.getInterpolatedPosition(e, renderAlpha);
                    let renderPosX = interpPos.x;
                    let renderPosY = interpPos.y;
                    if (e.isDecor) {
                        const offsetX = camX * (1 - e.parallaxSpeed);
                        const offsetY = camY * (1 - e.parallaxSpeed);
                        renderPosX += offsetX;
                        renderPosY += offsetY;
                    }
                    let thisTex = e.textureIndex ?? -1;
                    let effectiveTex = -1;
                    let isVideoTexture = false;
                    if (thisTex >= 0) {
                        const texObj = textures[thisTex];
                        let texReady = isTextureReady(texObj);
                        let hasDims = e.width != null && e.height != null;
                        if (texReady && (e.isDecor || hasDims)) {
                            effectiveTex = thisTex;
                        }
                    }
                    let col = effectiveTex >= 0 ? whiteColor : e.colorArray;
                    const baseVert = vertIdx / 8;
                    const texCoords = this.reusableFixedTex;
                    for (let j = 0; j < 4; j++) {
                        const lp = e.shape.points[j];
                        const px = lp.x + renderPosX;
                        const py = lp.y + renderPosY;
                        const tx = texCoords[j * 2], ty = texCoords[j * 2 + 1];
                        this.vertData[vertIdx++] = px;
                        this.vertData[vertIdx++] = py;
                        this.vertData[vertIdx++] = tx;
                        this.vertData[vertIdx++] = ty;
                        this.vertData[vertIdx++] = col[0];
                        this.vertData[vertIdx++] = col[1];
                        this.vertData[vertIdx++] = col[2];
                        this.vertData[vertIdx++] = col[3];
                    }
                    if (currentBatch.numElements > 0 && effectiveTex !== currentBatch.texIndex) {
                        batches.push({...currentBatch});
                        currentBatch = {indexStart: indexIdx, numElements: 0, texIndex: effectiveTex};
                    } else if (currentBatch.numElements === 0) {
                        currentBatch = {indexStart: indexIdx, numElements: 0, texIndex: effectiveTex};
                    }
                    currentBatch.numElements += 6;
                    const base = baseVert;
                    this.indexData[indexIdx++] = base + 0;
                    this.indexData[indexIdx++] = base + 1;
                    this.indexData[indexIdx++] = base + 2;
                    this.indexData[indexIdx++] = base + 0;
                    this.indexData[indexIdx++] = base + 2;
                    this.indexData[indexIdx++] = base + 3;
                }
                if (currentBatch.numElements > 0) batches.push({...currentBatch});
                gl.bindBuffer(gl.ARRAY_BUFFER, this.batchPositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertData.subarray(0, vertIdx), gl.DYNAMIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.batchIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData.subarray(0, indexIdx), gl.DYNAMIC_DRAW);
                gl.bindVertexArray(this.vao);
                for (const b of batches) {
                    if (b.texIndex >= 0) {
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, glTextures[b.texIndex]);
                        gl.uniform1i(useTextureLoc, 1);
                    } else {
                        gl.uniform1i(useTextureLoc, 0);
                    }
                    gl.drawElements(gl.TRIANGLES, b.numElements, gl.UNSIGNED_SHORT, b.indexStart * 2);
                }
                if (debug && this.player) {
                    let debugVertIdx = 0;
                    const interpPos = this.getInterpolatedPosition(this.player, renderAlpha);
                    let debugPosX = interpPos.x;
                    let debugPosY = interpPos.y;
                    const interpVel = this.getInterpolatedVel(this.player, renderAlpha);
                    debugVertIdx = this.player.appendDebugLines(this.debugVertData, redColor, debugPosX, debugPosY, interpVel, greenColor, debugVertIdx, this);
                    if (debugVertIdx > 0) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.debugLineBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, this.debugVertData.subarray(0, debugVertIdx), gl.DYNAMIC_DRAW);
                        gl.bindVertexArray(this.debugVao);
                        gl.uniform1i(useTextureLoc, 0);
                        gl.drawArrays(gl.LINES, 0, debugVertIdx / 8);
                    }
                }
            }
        }
        function createItemDiv(item, slotIdx, invType) {
            if (!item || typeof item !== 'string' || item === 'undefined') return null;
            const div = document.createElement('div');
            div.className = 'item';
            div.draggable = true;
            div.dataset.item = item;
            div.dataset.inventoryType = invType;
            div.dataset.slotIndex = slotIdx.toString();
            const img = document.createElement('img');
            const preloaded = itemImages[item];
            if (preloaded && preloaded.complete) {
                img.src = preloaded.src;
            } else {
                img.src = `https://placehold.co/32x32/0000FF/FFFFFF?text=${item.charAt(0).toUpperCase()}`;
                img.onerror = () => {
                    img.src = 'https://placehold.co/32x32/FF0000/FFFFFF?text=?';
                };
            }
            img.alt = item;
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = item.charAt(0).toUpperCase() + item.slice(1).toLowerCase();
            div.appendChild(img);
            div.appendChild(tooltip);
            div.addEventListener('dragstart', (e) => {
                const currentItem = e.currentTarget.dataset.item;
                const sourceInv = e.currentTarget.dataset.inventoryType;
                const sourceSlot = parseInt(e.currentTarget.dataset.slotIndex);
                e.dataTransfer.setData('text/plain', currentItem);
                e.dataTransfer.setData('sourceInventory', sourceInv);
                e.dataTransfer.setData('sourceSlot', sourceSlot.toString());
                e.dataTransfer.effectAllowed = 'move';
            });
            div.addEventListener('dragend', (e) => {});
            return div;
        }
        function updateSlots(gridId, itemsArray, invType) {
            const grid = document.getElementById(gridId);
            if (!grid) return;
            const cleanItems = itemsArray.map(it => (typeof it === 'string' && it !== 'undefined') ? it : null);
            for (let i = 0; i < cleanItems.length; i++) {
                const slot = grid.children[i];
                if (!slot) continue;
                const item = cleanItems[i];
                let itemDiv = slot.querySelector('.item');
                if (item && !itemDiv) {
                    const newDiv = createItemDiv(item, i, invType);
                    if (newDiv) {
                        slot.appendChild(newDiv);
                        slot.classList.add('has-item');
                    }
                } else if (!item && itemDiv) {
                    itemDiv.remove();
                    slot.classList.remove('has-item');
                } else if (item && itemDiv) {
                    itemDiv.dataset.item = item;
                    itemDiv.dataset.inventoryType = invType;
                    itemDiv.dataset.slotIndex = i.toString();
                    const tooltip = itemDiv.querySelector('.tooltip');
                    tooltip.textContent = item.charAt(0).toUpperCase() + item.slice(1).toLowerCase();
                    const img = itemDiv.querySelector('img');
                    const preloaded = itemImages[item];
                    if (preloaded && preloaded.complete) {
                        img.src = preloaded.src;
                    } else {
                        img.src = `https://placehold.co/32x32/0000FF/FFFFFF?text=${item.charAt(0).toUpperCase()}`;
                    }
                }
            }
        }
        function handleDrop(e) {
            e.preventDefault();
            const item = e.dataTransfer.getData('text/plain');
            if (!item || item === 'undefined') return;
            const sourceInv = e.dataTransfer.getData('sourceInventory');
            const sourceSlotStr = e.dataTransfer.getData('sourceSlot');
            const sourceSlot = parseInt(sourceSlotStr);
            const targetInv = e.currentTarget.dataset.inventory;
            const targetSlot = parseInt(e.currentTarget.dataset.slot);
            const sourceMax = sourceInv === 'player' ? config.maxPlayerSlots : config.maxChestSlots;
            if (isNaN(sourceSlot) || sourceSlot < 0 || sourceSlot >= sourceMax || isNaN(targetSlot) || targetSlot < 0 || targetSlot >= (targetInv === 'player' ? config.maxPlayerSlots : config.maxChestSlots)) {
                return;
            }
            if (sourceInv === targetInv) {
                if (sourceInv === 'player') {
                    const temp = world.inventory[sourceSlot];
                    world.inventory[sourceSlot] = world.inventory[targetSlot];
                    world.inventory[targetSlot] = temp || null;
                } else if (sourceInv === 'chest' && currentOpenChest) {
                    const temp = currentOpenChest.items[sourceSlot];
                    currentOpenChest.items[sourceSlot] = currentOpenChest.items[targetSlot];
                    currentOpenChest.items[targetSlot] = temp || null;
                }
            } else {
                if (targetInv === 'player' && (world.inventory[targetSlot] === null || world.inventory[targetSlot] === undefined)) {
                    world.inventory[targetSlot] = item;
                    if (sourceInv === 'chest' && currentOpenChest) {
                        currentOpenChest.items[sourceSlot] = null;
                    }
                } else if (targetInv === 'chest' && currentOpenChest && (currentOpenChest.items[targetSlot] === null || currentOpenChest.items[targetSlot] === undefined)) {
                    currentOpenChest.items[targetSlot] = item;
                    if (sourceInv === 'player') {
                        world.inventory[sourceSlot] = null;
                    }
                } else {
                    return;
                }
            }
            if (sourceInv === 'player' || targetInv === 'player') {
                world.inventory = world.inventory.map(it => it === undefined ? null : it);
            }
            if (currentOpenChest && (sourceInv === 'chest' || targetInv === 'chest')) {
                currentOpenChest.items = currentOpenChest.items.map(it => it === undefined ? null : it);
            }
            world.updateInventoryUI();
            if (currentOpenChest) {
                updateSlots('chestGrid', currentOpenChest.items, 'chest');
            }
            world.scheduleSave();
        }
        function populateGrid(gridId, itemsArray, numSlots, invType) {
            const grid = document.getElementById(gridId);
            if (!grid) return;
            grid.innerHTML = '';
            const gridClass = invType === 'chest' ? 'grid-chest' : 'grid-inventory';
            grid.className = gridClass;
            for (let i = 0; i < numSlots; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.dataset.slot = i;
                slot.dataset.inventory = invType;
                slot.addEventListener('dragover', (e) => e.preventDefault());
                slot.addEventListener('drop', handleDrop);
                grid.appendChild(slot);
            }
        }
        function initUIGrids() {
            populateGrid('inventoryGrid', new Array(config.maxPlayerSlots).fill(null), config.maxPlayerSlots, 'player');
            populateGrid('playerGridInChest', new Array(config.maxPlayerSlots).fill(null), config.maxPlayerSlots, 'player');
            populateGrid('chestGrid', new Array(config.maxChestSlots).fill(null), config.maxChestSlots, 'chest');
        }
        function populateChestUI() {
            if (!currentOpenChest) return;
            updateSlots('chestGrid', currentOpenChest.items, 'chest');
            updateSlots('playerGridInChest', world.inventory, 'player');
        }
        function waitForTextures(textures) {
            return Promise.all(textures.map((texObj) => {
                if (texObj && texObj.ready) {
                    return Promise.resolve();
                } else if (texObj instanceof HTMLImageElement) {
                    if (texObj.complete && texObj.naturalWidth > 0) return Promise.resolve();
                    return new Promise((resolve, reject) => {
                        texObj.onload = () => resolve();
                        texObj.onerror = reject;
                    });
                }
                return Promise.resolve();
            }));
        }
        const canvas = document.getElementById("game");
        const fadeOverlay = document.getElementById("fadeOverlay");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const gl = canvas.getContext("webgl2", { alpha: true, powerPreference: "high-performance" });
        if (!gl) {
            alert("WebGL2 not supported");
        }
        const debugDiv = document.getElementById("debug");
        const inventoryDiv = document.getElementById("inventory");
        const closeInventoryBtn = document.getElementById("closeInventory");
        const chestUI = document.getElementById("chestUI");
        const closeChestBtn = document.getElementById("closeChest");
        let currentOpenChest = null;
        const program = createProgram(gl, vsSource, fsSource);
        if (!program) {
            alert("Shader program failed");
            throw new Error("Failed to create program");
        }
        gl.useProgram(program);
        const textureLoc = gl.getUniformLocation(program, "u_texture");
        const useTextureLoc = gl.getUniformLocation(program, "u_useTexture");
        gl.uniform1i(textureLoc, 0);
        const matricesBlockIndex = gl.getUniformBlockIndex(program, "Matrices");
        let uboMatrices = null;
        if (matricesBlockIndex !== gl.INVALID_INDEX) {
            gl.uniformBlockBinding(program, matricesBlockIndex, 0);
            uboMatrices = gl.createBuffer();
            gl.bindBuffer(gl.UNIFORM_BUFFER, uboMatrices);
            gl.bufferData(gl.UNIFORM_BUFFER, 48, gl.DYNAMIC_DRAW);
            gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboMatrices);
        }
        const cyanColor = new Float32Array([0, 1, 1, 1]);
        const redColor = hexToRgb("#f00");
        const greenColor = new Float32Array([0, 1, 0, 1]);
        const whiteColor = new Float32Array([1, 1, 1, 1]);
        const world = new World(gl);
        world.uboMatrices = uboMatrices;
        gl.bindVertexArray(world.vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, world.batchPositionBuffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 32, 0);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 8);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 32, 16);
        gl.enableVertexAttribArray(2);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, world.batchIndexBuffer);
        gl.bindVertexArray(null);
        gl.bindVertexArray(world.debugVao);
        gl.bindBuffer(gl.ARRAY_BUFFER, world.debugLineBuffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 32, 0);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 8);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 32, 16);
        gl.enableVertexAttribArray(2);
        gl.bindVertexArray(null);
        const textures = [];
        const glTextures = [];
        const videoIndices = [];
        mapData.textures.forEach((url, i) => {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([128, 128, 128, 255]));
            let textureObj;
            if (url.match(/\.(webm|mp4)$/i)) {
                videoIndices.push(i);
                textureObj = { video: null, isReady: false, glTex: tex };
            } else {
                textureObj = new Image();
                textureObj.crossOrigin = "anonymous";
                textureObj.src = url;
                textureObj.onerror = () => {
                    textureObj.src = 'https://placehold.co/80x80/808080/FFFFFF?text=Err';
                };
            }
            textures.push(textureObj);
            glTextures.push(tex);
        });
        initUIGrids();
        closeChestBtn.addEventListener('click', () => {
            if (currentOpenChest) {
                const chest = currentOpenChest;
                if (chest.state === 'open') {
                    const animData = animationData[chest.closingTextureId];
                    if (animData) {
                        chest.state = 'closing';
                        chest.isAnimating = true;
                        chest.animationTime = 0;
                        chest.animationBaseId = chest.closingTextureId;
                        chest.animationType = 'oneshot';
                        chest.targetState = 'closed';
                        chest.targetTexId = chest.closedTextureId;
                    } else {
                        chest.state = 'closed';
                        chest.textureIndex = chest.closedTextureId;
                        chest.isAnimating = false;
                    }
                }
                chestUI.style.display = 'none';
                currentOpenChest = null;
                world.scheduleSave();
            }
        });
        async function clearSave() {
            try {
                localStorage.removeItem('gameSave');
                world.player.pos.set(world.playerStartPos.x, world.playerStartPos.y);
                world.player.vel.set(0, 0);
                world.player.updateAABB();
                world.inventory.fill(null);
                world.updateInventoryUI();
                world.currentRespawnPos.set(world.playerStartPos.x, world.playerStartPos.y);
                world.respawnBoxes.forEach(box => box.setActive(false));
                const initialChestsData = mapData.platforms.filter(plat => plat.type === "chest").map(plat => ({
                    id: plat.id,
                    items: (plat.items || []).slice(0, config.maxChestSlots).concat(new Array(Math.max(0, config.maxChestSlots - (plat.items || []).length)).fill(null))
                }));
                world.chests.forEach(chest => {
                    const initial = initialChestsData.find(ic => ic.id === chest.id);
                    if (initial) {
                        chest.items = initial.items.slice();
                    }
                });
                if (inventoryOpen) {
                    inventoryOpen = false;
                    inventoryDiv.style.display = 'none';
                }
                if (currentOpenChest) {
                    closeChestBtn.click();
                    currentOpenChest = null;
                }
            } catch (e) {}
        }
        debugDiv.addEventListener('click', (e) => {
            if (e.target.id === 'clearSave') clearSave();
        });
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('contextmenu', e => e.preventDefault());
        let debugMode = false;
        let inventoryOpen = false;
        let gameReady = false;
        window.addEventListener("keydown", async (e) => {
            const keyCode = e.code;
            if (keyCode === config.debugKey) {
                debugMode = !debugMode;
            }
            if (config.ctrlForClear && e.ctrlKey && keyCode === config.clearStorageKey) {
                e.preventDefault();
                clearSave();
            }
            if (keyCode === config.godModeKey && world.player) {
                world.player.godMode = !world.player.godMode;
            }
            if (keyCode === config.infiniteJumpKey && world.player) {
                world.player.infiniteJump = !world.player.infiniteJump;
            }
            if (keyCode === config.noclipKey && world.player) {
                world.player.noclip = !world.player.noclip;
            }
            const wasPressed = world.keys[keyCode];
            world.keys[keyCode] = true;
            if (!wasPressed) {
                if (config.dashKeys.includes(keyCode)) {
                    if (world.player && world.player.dashTimer <= 0) {
                        world.player.dashTimer = config.dashDuration;
                    }
                }
                if (keyCode === config.chestKey && world.nearbyChest) {
                    world.openChestUI(world.nearbyChest, textures);
                }
                if (keyCode === config.respawnKey && world.nearbyRespawnBox) {
                    world.setRespawnAtBox(world.nearbyRespawnBox);
                }
                if (keyCode === config.inventoryKey) {
                    inventoryOpen = !inventoryOpen;
                    inventoryDiv.style.display = inventoryOpen ? 'block' : 'none';
                    if (inventoryOpen) world.updateInventoryUI();
                    else world.scheduleSave();
                }
            }
            if (keyCode === config.jumpKey) e.preventDefault();
        });
        window.addEventListener("keyup", e => world.keys[e.code] = false);
        closeInventoryBtn.addEventListener('click', () => {
            inventoryOpen = false;
            inventoryDiv.style.display = 'none';
            world.scheduleSave();
        });
        world.updateInventoryUI = () => {
            updateSlots('inventoryGrid', world.inventory, 'player');
            updateSlots('playerGridInChest', world.inventory, 'player');
        };
        async function initializeGame() {
            for (const vidIdx of videoIndices) {
                const url = mapData.textures[vidIdx];
                const frames = await extractFrames(url, gl);
                const numF = frames.length;
                animationData[vidIdx] = { numFrames: numF, frameRate: 10 };
                textures.splice(vidIdx, 1, ...frames.map(() => ({ ready: true })));
                glTextures.splice(vidIdx, 1, ...frames.map(f => f.glTex));
                const shift = numF - 1;
                for (const plat of mapData.platforms) {
                    const fields = ['closedTextureId', 'openTextureId', 'openingTextureId', 'closingTextureId', 'inactiveTextureId', 'activeTextureId', 'texture'];
                    for (const field of fields) {
                        if (plat[field] !== undefined && plat[field] > vidIdx) {
                            plat[field] += shift;
                        }
                    }
                }
            }
            await waitForTextures(textures);
            textures.forEach((texObj, i) => {
                const tex = glTextures[i];
                gl.bindTexture(gl.TEXTURE_2D, tex);
                if (texObj instanceof HTMLImageElement && texObj.complete) {
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texObj);
                }
            });
            await world.loadMap(mapData, textures);
            world.updateInventoryUI();
            gameReady = true;
            loadingSpinner.style.display = 'none';
        }
        initializeGame().catch(() => {});
        let shakeTime = 0;
        let shakeDuration = 0;
        let shakeIntensity = 0;
        function shakeScreen(intensity) {
            shakeIntensity = intensity;
            shakeDuration = 1.0;
            shakeTime = 0;
        }
        let lastTime = performance.now(), frameCount = 0, lastFPSTime = lastTime, fps = 60;
        let lastDebugTime = lastTime;
        let camX = 0, camY = 0;
        const cameraSmoothingRate = config.cameraSmoothing * 60;
        let accumulator = 0;
        const fixedDt = 1 / 60;
        function loop(currentTime) {
            frameCount++;
            if (currentTime - lastFPSTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (currentTime - lastFPSTime));
                frameCount = 0;
                lastFPSTime = currentTime;
            }
            const delta = Math.min((currentTime - lastTime) / 1000, 1 / 30);
            lastTime = currentTime;
            if (gameReady && world.player) {
                world.prevPlayerPos.set(world.player.pos.x, world.player.pos.y);
                accumulator += delta;
                let physicsSteps = 0;
                while (accumulator >= fixedDt && physicsSteps < config.maxPhysicsStepsPerFrame) {
                    world.update(fixedDt);
                    accumulator -= fixedDt;
                    physicsSteps++;
                }
                const alpha = accumulator / fixedDt;
                const targetCamX = world.getInterpolatedPosition(world.player, alpha).x - canvas.width / 2;
                const targetCamY = world.getInterpolatedPosition(world.player, alpha).y - canvas.height / 2;
                camX += (targetCamX - camX) * cameraSmoothingRate * delta;
                camY += (targetCamY - camY) * cameraSmoothingRate * delta;
                if (shakeTime < shakeDuration) {
                    shakeTime += delta;
                    const progress = shakeTime / shakeDuration;
                    const currentIntensity = shakeIntensity * (1 - progress);
                    let shakeOffsetX = (Math.random() - 0.5) * 5 * currentIntensity;
                    let shakeOffsetY = (Math.random() - 0.5) * 5 * currentIntensity;
                    const maxShake = 2500;
                    shakeOffsetX = Math.max(-maxShake, Math.min(maxShake, shakeOffsetX));
                    shakeOffsetY = Math.max(-maxShake, Math.min(maxShake, shakeOffsetY));
                    camX += shakeOffsetX;
                    camY += shakeOffsetY;
                    if (shakeTime >= shakeDuration) {
                        shakeTime = shakeDuration;
                        shakeIntensity = 0;
                    }
                }
                world.draw(debugMode, camX, camY, frameCount, textures, alpha, canvas.width, canvas.height);
                if (currentTime - lastDebugTime >= 500 && debugMode) {
                    const activeKeys = Object.keys(world.keys).filter(k => world.keys[k]).join(", ") || "None";
                    const interpPos = world.getInterpolatedPosition(world.player, alpha);
                    const chestInfo = world.nearbyChest ? `${world.nearbyChest.id} (${world.nearbyChest.state})` : 'No chest';
                    const respawnInfo = world.nearbyRespawnBox ? `${world.nearbyRespawnBox.id} (${world.nearbyRespawnBox.active ? 'Active' : 'Inactive'})` : 'No respawn box';
                    const cheatsInfo = `God: ${world.player.godMode}, InfJump: ${world.player.infiniteJump}, Noclip: ${world.player.noclip}`;
                    debugDiv.innerHTML = `<button id="clearSave">Clear Storage (Ctrl+Backspace)</button>Player Debug<br>pos: (${interpPos.x.toFixed(2)}, ${interpPos.y.toFixed(2)})<br>vel: (${world.player.vel.x.toFixed(2)}, ${world.player.vel.y.toFixed(2)})<br>onGround: ${world.player.onGround}<br>groundAngle: ${world.player.groundAngle.toFixed(1)}<br>z: ${world.player.z}<br>dashing: ${world.player.isDashing}<br>airJumpCooldown: ${world.player.airJumpCooldown.toFixed(2)}<br>keys: ${activeKeys}<br>fps: ${fps}<br>${chestInfo}<br>${respawnInfo}<br>${cheatsInfo}`;
                    lastDebugTime = currentTime;
                }
            } else {
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>
</html>
