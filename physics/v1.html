<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Game Engine - Debug Overlay</title>
<style>
  * { box-sizing: border-box; }
  body { 
    margin: 0; 
    overflow: hidden; 
    background: #0a0a0a; 
    color: #00ff41; 
    font-family: 'Courier New', monospace; 
  }
  canvas { 
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); 
    display: block; 
    width: 100vw; 
    height: 100vh; 
  }
  #debug {
    position: absolute; 
    top: 20px; 
    right: 20px;
    background: rgba(0, 0, 0, 0.85); 
    padding: 15px;
    border: 1px solid #00ff41; 
    border-radius: 8px;
    max-width: 280px; 
    font-size: 12px; 
    line-height: 1.4;
    box-shadow: 0 4px 20px rgba(0, 255, 65, 0.1);
    backdrop-filter: blur(10px);
  }
  #toggle {
    position: absolute; 
    left: 20px; 
    top: 20px; 
    z-index: 10; 
    background: linear-gradient(145deg, #1e1e1e, #2a2a2a); 
    color: #00ff41; 
    border: 1px solid #00ff41; 
    border-radius: 6px; 
    padding: 10px 16px; 
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 10px rgba(0, 255, 65, 0.2);
  }
  #toggle:hover {
    background: linear-gradient(145deg, #2a2a2a, #1e1e1e);
    box-shadow: 0 4px 15px rgba(0, 255, 65, 0.3);
    transform: translateY(-1px);
  }
  #sidebar {
    position: absolute; 
    left: 0; 
    top: 0; 
    width: 280px; 
    height: 100vh; 
    background: rgba(0, 0, 0, 0.92); 
    color: #00ff41; 
    padding: 20px; 
    border-right: 1px solid #00ff41; 
    font-family: inherit; 
    font-size: 13px;
    transform: translateX(-100%); 
    transition: transform 0.3s ease;
    overflow-y: auto; 
    box-shadow: 2px 0 20px rgba(0, 255, 65, 0.1);
    backdrop-filter: blur(10px);
  }
  #sidebar.open { transform: translateX(0); }
  #sidebar h3 { 
    margin: 0 0 20px 0; 
    color: #00ff41; 
    font-size: 18px;
    text-align: center;
    text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
  }
  #sidebar label { 
    display: flex; 
    justify-content: space-between; 
    align-items: center;
    margin: 15px 0; 
    padding: 8px;
    background: rgba(0, 255, 65, 0.05);
    border-radius: 4px;
    border: 1px solid rgba(0, 255, 65, 0.2);
    transition: all 0.2s ease;
  }
  #sidebar label:hover {
    background: rgba(0, 255, 65, 0.1);
    border-color: #00ff41;
  }
  #sidebar input[type="number"] { 
    width: 80px; 
    background: #1a1a1a; 
    color: #00ff41; 
    border: 1px solid #00ff41; 
    padding: 4px 6px; 
    border-radius: 3px;
    text-align: right;
    transition: border-color 0.2s ease;
  }
  #sidebar input[type="number"]:focus {
    outline: none;
    border-color: #00ff41;
    box-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
  }
  #sidebar input[type="checkbox"] { 
    margin-left: 10px; 
    accent-color: #00ff41;
    transform: scale(1.2);
  }
  #sidebar span {
    font-weight: bold;
    color: #66ff88;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<button id="toggle">Toggle Sidebar</button>
<div id="sidebar">
  <h3>Settings</h3>
  <label>Gravity: <input type="number" id="gravity" min="100" max="2000" value="900" step="10"> <span id="gval">900</span></label>
  <label>Player Speed: <input type="number" id="speed" min="50" max="1000000" value="200" step="10"> <span id="sval">200</span></label>
  <label>Jump Height: <input type="number" id="jump" min="100" max="800" value="400" step="10"> <span id="jval">400</span></label>
  <label>Debug: <input type="checkbox" id="debugToggle" checked> <span id="dtval">true</span></label>
  <label>Platforms (stacked): <input type="number" id="platforms" min="0" max="100000" value="0" step="1"> <span id="pval">0</span></label>
  <!-- Add more settings here as needed -->
</div>
<div id="debug"></div>
<script>
const mapData = {
  "textures": [
    "https://placehold.co/900x40/555555/FFFFFF/png",
    "https://placehold.co/250x40/ff0000/FFFFFF/png",
    "https://placehold.co/200x40/00ff00/FFFFFF/png"
  ],
  "player": {
    "x": 150,
    "y": 100,
    "z": 5
  },
  "entities": [
    {
      "type": "rect",
      "x": 450,
      "y": 580,
      "w": 900,
      "h": 40,
      "angle": 0,
      "color": "#555",
      "static": true,
      "z": 0,
      "textureIndex": 0
    },
    {
      "type": "rect",
      "x": 500,
      "y": 500,
      "w": 250,
      "h": 40,
      "angle": -30,
      "color": "#666",
      "static": true,
      "z": 0,
      "textureIndex": 1
    },
    {
      "type": "rect",
      "x": 400,
      "y": 300,
      "w": 200,
      "h": 40,
      "angle": 0,
      "color": "#800",
      "static": true,
      "z": 10,
      "textureIndex": 2
    }
    // Voeg meer entities toe aan de JSON voor extra levels or maps
  ]
};

// ======== VECTOR CLASS (Immutable operations) ========
class Vec2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
  sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
  scale(s) { return new Vec2(this.x * s, this.y * s); }
  dot(v) { return this.x * v.x + this.y * v.y; }
  perp() { return new Vec2(-this.y, this.x); }
  len() { return Math.hypot(this.x, this.y); }
  norm() {
    const l = this.len();
    return l ? this.scale(1 / l) : new Vec2();
  }
  clone() { return new Vec2(this.x, this.y); }
}

// ======== AABB OVERLAP HELPER ========
function aabbOverlap(a, b) {
  return a.maxX >= b.minX && a.minX <= b.maxX &&
         a.maxY >= b.minY && a.minY <= b.maxY;
}

// ======== POLYGON AND SAT COLLISION DETECTION ========
class Polygon {
  constructor(points) {
    this.points = points.map(p => new Vec2(p.x, p.y)); // Ensure Vec2
    this.axes = this.getAxes();
  }
  getAxes() {
    const axes = [];
    for (let i = 0; i < this.points.length; i++) {
      const p1 = this.points[i];
      const p2 = this.points[(i + 1) % this.points.length];
      const edge = p2.sub(p1);
      const axis = edge.perp().norm();
      if (axis.len() > 0) { // Avoid zero-length edges
        axes.push(axis);
      }
    }
    return axes;
  }
  getAABB(pos) {
    const pts = this.getTransformed(pos);
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const p of pts) {
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }
    return { minX, minY, maxX, maxY };
  }
  getTransformed(pos) {
    return this.points.map(p => p.add(pos));
  }
  project(axis, pos) {
    const pts = this.getTransformed(pos);
    let min = pts[0].dot(axis);
    let max = min;
    for (let i = 1; i < pts.length; i++) {
      const proj = pts[i].dot(axis);
      if (proj < min) min = proj;
      if (proj > max) max = proj;
    }
    return { min, max };
  }
  static overlap(A, posA, B, posB) {
    const axes = [...A.axes, ...B.axes];
    let overlap = Infinity;
    let smallestAxis = null;
    for (const axis of axes) {
      if (axis.len() === 0) continue; // Skip invalid axes
      const projA = A.project(axis, posA);
      const projB = B.project(axis, posB);
      const o = Math.min(projA.max, projB.max) - Math.max(projA.min, projB.min);
      if (o < 1e-9) return null; // Tighter epsilon for precision
      if (o < overlap) {
        overlap = o;
        smallestAxis = axis;
      }
    }
    if (smallestAxis === null) return null;
    // Basic flip for now; full orientation in resolution
    const d = posA.sub(posB);
    if (d.dot(smallestAxis) < 0) {
      smallestAxis = smallestAxis.scale(-1);
    }
    return { axis: smallestAxis, overlap };
  }
}

// ======== ENTITY CLASS (Physics and Movement) ========
class Entity {
  constructor(x, y, shape) {
    this.pos = new Vec2(x, y);
    this.vel = new Vec2(0, 0);
    this.shape = shape;
    this.color = "#4af";
    this.static = false;
    this.z = 0; // Z-index for rendering order
    this.width = null;
    this.height = null;
    this.angle = 0;
    this.textureIndex = null;
    this.aabb = this.static ? this.shape.getAABB(this.pos) : null;
    this.onGround = false;
    this.groundNormal = new Vec2(0, -1);
    this.groundAngle = 0;
    this.isTestPlatform = false;
  }
  update(dt, world) {
    if (this.static) return;

    const oldOnGround = this.onGround;
    this.onGround = false;

    const input_speed = world.keys["ArrowLeft"]
      ? -world.playerSpeed
      : world.keys["ArrowRight"]
      ? world.playerSpeed
      : 0;
    const horiz = new Vec2(input_speed, 0);
    const g_vec = new Vec2(0, world.gravity * dt);

    // Apply input using old ground info
    if (oldOnGround) {
      const tangent = this.groundNormal.perp().norm();
      const vt = horiz.dot(tangent);
      const vn = this.vel.dot(this.groundNormal);
      this.vel = tangent.scale(vt).add(this.groundNormal.scale(vn));
    } else {
      this.vel.x = horiz.x;
    }

    // Add gravity
    this.vel = this.vel.add(g_vec);

    // Substep position update to prevent tunneling
    const disp = this.vel.scale(dt);
    const maxSubLen = 5;
    let numSteps = Math.max(1, Math.ceil(disp.len() / maxSubLen));
    const subDisp = disp.scale(1 / numSteps);
    let currentPos = this.pos.clone();
    const up = new Vec2(0, -1);
    const maxIter = 10;
    for (let step = 0; step < numSteps; step++) {
      let testPos = currentPos.add(subDisp);
      let iterations = 0;
      let hasCollision = false;
      while (iterations < maxIter) {
        hasCollision = false;
        const testAABB = this.shape.getAABB(testPos);
        for (const other of world.getNearby(testPos)) {
          if (!other.shape || other === this) continue;
          const otherAABB = other.aabb || other.shape.getAABB(other.pos);
          if (!aabbOverlap(testAABB, otherAABB)) continue;
          let res = Polygon.overlap(this.shape, testPos, other.shape, other.pos);
          if (res) {
            hasCollision = true;
            // Orient axis properly for resolution
            let axis = res.axis.clone();
            const d = testPos.sub(other.pos);
            const d_len = d.len();
            let dir;
            if (d_len > 1e-6) {
              dir = d.norm();
            } else {
              const otherVel = other.vel ? other.vel.clone() : new Vec2(0, 0);
              const relVel = this.vel.sub(otherVel);
              dir = relVel.len() > 0 ? relVel.scale(-1).norm() : up.clone();
            }
            const proj = dir.dot(axis);
            if (proj < 0) {
              axis = axis.scale(-1);
            }
            // Now resolve with oriented axis
            testPos = testPos.add(axis.scale(res.overlap));
            const vn = this.vel.dot(axis);
            if (vn < 0) {
              this.vel = this.vel.sub(axis.scale(vn));
            }
            if (axis.dot(up) > 0.01) {
              this.onGround = true;
              this.groundNormal = axis.clone();
            }
          }
        }
        if (!hasCollision) break;
        iterations++;
      }
      currentPos = testPos;
    }
    this.pos = currentPos;

    // Post-collision adjustments
    if (this.onGround) {
      // Remove normal velocity component
      const vn = this.vel.dot(this.groundNormal);
      this.vel = this.vel.sub(this.groundNormal.scale(vn));

      // Set desired tangential velocity
      const tangent = this.groundNormal.perp().norm();
      const desired_vt = horiz.dot(tangent);
      this.vel = tangent.scale(desired_vt);

      // Correct position for gravity tangential component to prevent sliding
      const g_tang_scalar = g_vec.dot(tangent);
      this.pos = this.pos.sub(tangent.scale(g_tang_scalar * dt));

      // Calculate ground angle
      const vertical = new Vec2(0, -1);
      const cosTheta = this.groundNormal.dot(vertical);
      this.groundAngle = Math.acos(Math.max(-1, Math.min(1, cosTheta))) * 180 / Math.PI;
    } else {
      // Air control: only horizontal
      this.vel.x = horiz.x;
    }

    // Jump logic (along normal)
    if (world.keys["Space"] && oldOnGround) {
      const upDir = this.groundNormal;
      const target_v = upDir.scale(world.jumpHeight);
      this.vel = this.vel.add(target_v);
      this.onGround = false;
    }
  }

  draw(ctx, debug = false) {
    const pts = this.shape.getTransformed(this.pos);
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) {
      ctx.lineTo(pts[i].x, pts[i].y);
    }
    ctx.closePath();

    let drewSomething = false;
    if (this.textureIndex !== undefined && textures[this.textureIndex] && textures[this.textureIndex].complete && this.width && this.height) {
      ctx.save();
      ctx.translate(this.pos.x, this.pos.y);
      ctx.rotate(this.angle);
      ctx.drawImage(textures[this.textureIndex], -this.width / 2, -this.height / 2, this.width, this.height);
      ctx.restore();
      drewSomething = true;
    }
    if (!drewSomething) {
      ctx.fillStyle = this.color;
      ctx.fill();
    }

    if (debug && !this.isTestPlatform) {
      // Outline
      ctx.strokeStyle = "#f00";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x, pts[i].y);
      }
      ctx.closePath();
      ctx.stroke();
      // Velocity arrow
      ctx.strokeStyle = "#0f0";
      ctx.beginPath();
      ctx.moveTo(this.pos.x, this.pos.y);
      ctx.lineTo(
        this.pos.x + this.vel.x * 0.1,
        this.pos.y + this.vel.y * 0.1
      );
      ctx.stroke();
    }
  }
}

// ======== WORLD CLASS (Manages entities and state) ========
class World {
  constructor(ctx) {
    this.ctx = ctx;
    this.statics = [];
    this.dynamics = [];
    this.testPlatforms = [];
    this.gravity = 900;
    this.playerSpeed = 200;
    this.jumpHeight = 400;
    this.keys = {};
    this.cellSize = 200;
    this.spatialHash = new Map();
    this.player = null;
  }
  loadMap(data) {
    this.statics = [];
    this.dynamics = [];
    this.testPlatforms = [];
    for (const entData of data.entities || []) {
      let shape;
      if (entData.type === "rect") {
        shape = RotatedRect(entData.w || 100, entData.h || 20, entData.angle || 0);
      } else if (entData.type === "polygon") {
        shape = new Polygon(entData.points.map(p => new Vec2(p.x, p.y)));
      }
      if (shape) {
        const e = new Entity(entData.x || 0, entData.y || 0, shape);
        e.color = entData.color || "#4af";
        e.static = entData.static !== false;
        e.z = entData.z || 0;
        e.textureIndex = entData.textureIndex;
        if (entData.type === "rect") {
          e.width = entData.w || 100;
          e.height = entData.h || 20;
          e.angle = (entData.angle || 0) * Math.PI / 180;
        }
        if (entData.isTestPlatform) {
          e.isTestPlatform = true;
        }
        this.add(e);
        if (e.isTestPlatform) {
          this.testPlatforms.push(e);
        }
      }
    }
    if (data.player) {
      const playerShape = new Polygon([
        new Vec2(-20, -20),
        new Vec2(20, -20),
        new Vec2(20, 20),
        new Vec2(-20, 20)
      ]);
      this.player = new Entity(data.player.x || 150, data.player.y || 100, playerShape);
      this.player.z = data.player.z || 5;
      this.player.width = 40;
      this.player.height = 40;
      this.player.angle = 0;
      this.player.textureIndex = data.player.textureIndex;
      this.add(this.player);
    }
  }
  add(e) {
    if (e.static) {
      this.statics.push(e);
    } else {
      this.dynamics.push(e);
    }
  }
  getHash(pos) {
    const hx = Math.floor(pos.x / this.cellSize);
    const hy = Math.floor(pos.y / this.cellSize);
    return `${hx},${hy}`;
  }
  rebuildSpatialHash() {
    this.spatialHash.clear();
    const posToEntity = new Map();
    for (const e of this.statics) {
      if (e.shape) {
        if (e.isTestPlatform) {
          const tolerance = 10;
          const gx = Math.floor(e.pos.x / tolerance);
          const gy = Math.floor(e.pos.y / tolerance);
          const posKey = `${gx},${gy}`;
          if (!posToEntity.has(posKey)) {
            posToEntity.set(posKey, e);
          }
          const rep = posToEntity.get(posKey);
          const hash = this.getHash(rep.pos);
          if (!this.spatialHash.has(hash)) {
            this.spatialHash.set(hash, []);
          }
          if (!this.spatialHash.get(hash).includes(rep)) {
            this.spatialHash.get(hash).push(rep);
          }
        } else {
          const hash = this.getHash(e.pos);
          if (!this.spatialHash.has(hash)) {
            this.spatialHash.set(hash, []);
          }
          if (!this.spatialHash.get(hash).includes(e)) {
            this.spatialHash.get(hash).push(e);
          }
        }
      }
    }
  }
  getNearby(pos) {
    const nearby = new Set();
    const cx = Math.floor(pos.x / this.cellSize);
    const cy = Math.floor(pos.y / this.cellSize);
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = -2; dy <= 2; dy++) {
        const h = `${cx + dx},${cy + dy}`;
        if (this.spatialHash.has(h)) {
          this.spatialHash.get(h).forEach(e => nearby.add(e));
        }
      }
    }
    // Voeg andere dynamics toe als er meerdere zijn (nu alleen player, dus optioneel)
    this.dynamics.forEach(e => {
      if (e !== this.player) {  // Skip self (player) voor collision checks
        nearby.add(e);
      }
    });
    // Sort by y ascending (upper first for resolution priority)
    return Array.from(nearby).sort((a, b) => a.pos.y - b.pos.y);
  }
  getVisible(viewMinX, viewMinY, viewMaxX, viewMaxY) {
    const visible = new Set();
    const cxMin = Math.floor(viewMinX / this.cellSize) - 1;
    const cxMax = Math.floor((viewMaxX - 1) / this.cellSize) + 1;
    const cyMin = Math.floor(viewMinY / this.cellSize) - 1;
    const cyMax = Math.floor((viewMaxY - 1) / this.cellSize) + 1;
    for (let cx = cxMin; cx <= cxMax; cx++) {
      for (let cy = cyMin; cy <= cyMax; cy++) {
        const h = `${cx},${cy}`;
        if (this.spatialHash.has(h)) {
          this.spatialHash.get(h).forEach(e => visible.add(e));
        }
      }
    }
    this.dynamics.forEach(e => visible.add(e));
    return Array.from(visible);
  }
  update(dt) {
    for (const e of this.dynamics) {
      e.update(dt, this);
    }
  }
  draw(debug = false, camX, camY) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const viewMinX = camX;
    const viewMaxX = camX + width;
    const viewMinY = camY;
    const viewMaxY = camY + height;
    let visible = this.getVisible(viewMinX, viewMinY, viewMaxX, viewMaxY);
    // Sort by z-index for rendering order (lower z drawn first, behind)
    visible.sort((a, b) => a.z - b.z);
    for (const e of visible) {
      const aabb = e.aabb || e.shape.getAABB(e.pos);
      if (aabb.maxX < viewMinX || aabb.minX > viewMaxX ||
          aabb.maxY < viewMinY || aabb.minY > viewMaxY) continue;
      e.draw(this.ctx, debug);
    }
  }
}

// ======== HELPER: ROTATED RECTANGLE (Relative to center) ========
function RotatedRect(w, h, angleDeg) {
  const angle = angleDeg * Math.PI / 180;
  const hw = w / 2;
  const hh = h / 2;
  const corners = [
    new Vec2(-hw, -hh),
    new Vec2(hw, -hh),
    new Vec2(hw, hh),
    new Vec2(-hw, hh)
  ];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const rotated = corners.map(p =>
    new Vec2(
      p.x * cos - p.y * sin,
      p.x * sin + p.y * cos
    )
  );
  return new Polygon(rotated);
}

// ======== SETUP AND INITIALIZATION ========
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha: true });
const debugDiv = document.getElementById("debug");
const world = new World(ctx);

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const textures = [];
mapData.textures.forEach(url => {
  const img = new Image();
  img.src = url;
  textures.push(img);
});

let showDebug = true;

// FPS counter
let frameCount = 0;
let lastFPSTime = 0;
let fps = 0;

// Input handling
window.addEventListener("keydown", (e) => { 
  world.keys[e.code] = true; 
  if (e.code === "Space") e.preventDefault();
});
window.addEventListener("keyup", (e) => { world.keys[e.code] = false; });

// Load map from JSON
world.loadMap(mapData);
world.rebuildSpatialHash();

// Sidebar controls
const toggleBtn = document.getElementById("toggle");
const sidebar = document.getElementById("sidebar");
toggleBtn.addEventListener("click", () => {
  sidebar.classList.toggle("open");
});

// Gravity control
const gravityInput = document.getElementById("gravity");
const gval = document.getElementById("gval");
gravityInput.addEventListener("input", (e) => {
  world.gravity = parseFloat(e.target.value) || 900;
  gval.textContent = world.gravity.toFixed(0);
});

// Player speed control
const speedInput = document.getElementById("speed");
const sval = document.getElementById("sval");
speedInput.addEventListener("input", (e) => {
  world.playerSpeed = parseFloat(e.target.value) || 200;
  sval.textContent = world.playerSpeed.toFixed(0);
});

// Jump height control
const jumpInput = document.getElementById("jump");
const jval = document.getElementById("jval");
jumpInput.addEventListener("input", (e) => {
  world.jumpHeight = parseFloat(e.target.value) || 400;
  jval.textContent = world.jumpHeight.toFixed(0);
});

// Debug toggle
const debugToggle = document.getElementById("debugToggle");
const dtval = document.getElementById("dtval");
debugToggle.addEventListener("change", (e) => {
  showDebug = e.target.checked;
  dtval.textContent = showDebug ? "true" : "false";
});

// Platforms control (stress test: add stacked platforms with 1px offsets)
const platformsInput = document.getElementById("platforms");
const pval = document.getElementById("pval");
platformsInput.addEventListener("input", (e) => {
  const num = parseInt(e.target.value) || 0;
  // Remove existing test platforms
  world.testPlatforms = [];
  world.statics = world.statics.filter(e => !e.isTestPlatform);
  // Add new ones with 1px vertical offsets
  if (num > 0) {
    const testShape = RotatedRect(100, 20, 0);
    const testPosX = 100;
    const testPosY = 500;
    for (let i = 0; i < num; i++) {
      const dy = -i * 0.01;
      const testPos = new Vec2(testPosX, testPosY + dy);
      const testPlatform = new Entity(testPos.x, testPos.y, testShape);
      testPlatform.static = true;
      testPlatform.color = "#f00";
      testPlatform.isTestPlatform = true;
      testPlatform.z = 1; // Set z-index for test platforms
      testPlatform.width = 100;
      testPlatform.height = 20;
      testPlatform.angle = 0;
      testPlatform.textureIndex = 0; // Assign texture index 0 to test platforms
      world.add(testPlatform);
      world.testPlatforms.push(testPlatform);
    }
  }
  world.rebuildSpatialHash();
  pval.textContent = num;
});

// Initial update
platformsInput.dispatchEvent(new Event("input"));

// ======== MAIN LOOP ========
let lastTime = 0;
function loop(currentTime) {
  frameCount++;
  if (currentTime - lastFPSTime > 1000) {
    fps = Math.round(frameCount * 1000 / (currentTime - lastFPSTime));
    frameCount = 0;
    lastFPSTime = currentTime;
  }

  const dt = Math.min((currentTime - lastTime) / 1000, 1/30);
  lastTime = currentTime;

  world.update(dt);

  // Render
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  // Camera follows player freely (no clamping)
  const camX = world.player.pos.x - canvas.width / 2;
  const camY = world.player.pos.y - canvas.height / 2;
  ctx.translate(-camX, -camY);
  world.draw(showDebug, camX, camY);
  ctx.restore();

  // Debug overlay
  if (showDebug) {
    let keysText = "";
    if (world.keys["ArrowLeft"]) keysText += "Left ";
    if (world.keys["ArrowRight"]) keysText += "Right ";
    if (world.keys["Space"]) keysText += "Jump ";
    keysText = keysText.trim() || "None";

    debugDiv.innerHTML = `
      <b>Player Debug</b><br>
      pos: (${world.player.pos.x.toFixed(2)}, ${world.player.pos.y.toFixed(2)})<br>
      vel: (${world.player.vel.x.toFixed(2)}, ${world.player.vel.y.toFixed(2)})<br>
      onGround: ${world.player.onGround}<br>
      groundAngle: ${world.player.groundAngle.toFixed(1)}Â°<br>
      z: ${world.player.z}<br>
      keys: ${keysText}<br>
      test platforms: ${world.testPlatforms.length}<br>
      fps: ${fps}
    `;
  } else {
    debugDiv.innerHTML = "";
  }

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
