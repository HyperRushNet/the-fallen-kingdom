<!-- The Fallen Kingdom - Smooth Slopes Fix + Teleporters -->
<!-- 2025 - HyperRush Network - Do not use this code without permission -->

<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Platformer Runner - Smooth Slopes + Teleporters</title>
<style>
body { margin: 0; overflow: hidden; font-family: sans-serif; color: white; }
#background { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-color: #08003b }
canvas { display: block; background: transparent; }
#hud { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; font-size: 16px; z-index: 1; }
.ability { margin-bottom: 5px; }
.ready { color: #0f0; }
.cooldown { color: #f00; }
#loadingScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; }
#loadingBarContainer { width: 300px; height: 20px; background: #333; border: 1px solid #666; border-radius: 10px; overflow: hidden; }
#loadingBar { width: 0; height: 100%; background: #0f0; transition: width 0.3s ease; }
#loadingText { color: white; margin-top: 10px; font-size: 18px; }
#fpsMeter { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.5); color: #0f0; padding: 5px 10px; border-radius: 5px; font-family: monospace; z-index: 2; }
</style>
</head>
<body>
<div id="loadingScreen">
  <div id="loadingBarContainer"><div id="loadingBar"></div></div>
  <div id="loadingText">Laden... 0%</div>
</div>
<div id="background"></div>
<div id="hud">
  <div class="ability" id="dash">Dash (Shift): Ready</div>
  <div class="ability" id="airhop">Air Hop (Space): Ready</div>
  <div class="ability" id="sword">Sword (C): Ready</div>
  <div class="ability" id="slopeInfo">Slope: None (0°)</div>
</div>
<div id="fpsMeter">FPS: 0</div>
<canvas id="gameCanvas"></canvas>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
const CONFIG = {
  gravity: 1.2,
  player: { size: 50, speed: 5, runSpeed: 7, dashSpeed: 15, jumpVelocity: -15, airHopVelocity: -12, dashDuration: 100, dashCooldown: 2000, hopCooldown: 1500, collisionFilter: { category: 0x0001, mask: 0x0002 } },
  sword: { height: 25, swingDuration: 200, swingArc: Math.PI/2, offsetX: 35, offsetY: 0, collisionFilter: { category: 0x0008, mask: 0x0002 } },
  camera: { smoothFactor: 0.2, bgPanSpeed: 0.5 },
  culling: { physicsMargin: 200, renderMargin: 100 },
  rotationLimit: 1,
  teleporterCooldown: 1200 // 1.2 sec
};

const mapData = {
  playerStart:{x:200,y:200,w:50,h:50},
  textures:["https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRqj4qkVkvMEt8n6HYiTb2QKXmnbCtBortMaQ&s"],
  platforms:[
    {id:"4zCBJ1UXWinc-ZPOxtwHZXE0v",type:"platform",x:227,y:303,w:100,h:100,angle:0,textureId:0},
    {id:"u8hV65LeFjbf-WDOnPenCLpsJ",type:"platform",x:320,y:280,w:100,h:20,angle:20,textureId:0},
    {id:"I026KLEGyXwt-l8Al5gDTyWHq",type:"platform",x:413,y:296,w:100,h:20,angle:0,textureId:0},
    {id:"E1m9jCEqjIzb-3idu6HthDVGP",type:"platform",x:498,y:279,w:100,h:20,angle:-20,textureId:0},
    {id:"vKA6gx0kNnLK-UZe4Np0XQS11",type:"platform",x:591,y:303,w:100,h:100,angle:0,textureId:0}
  ],
  decor:[],
  teleporters:[
    {id:"tp1",x:350,y:250,w:40,h:40,linkedId:"tp2",texture:"https://placehold.co/40x40"},
    {id:"tp2",x:600,y:250,w:40,h:40,linkedId:"tp1",texture:"https://placehold.co/40x40"}
  ]
};

const swordRightUrl='https://hyperrushnet.github.io/v3concept/sword-image-game-no-bg.png';
const swordLeftUrl='https://hyperrushnet.github.io/game/images/sword-left.png';
const textureCache=new Map();
const imagesToLoad=[...new Set([...mapData.textures,swordRightUrl,swordLeftUrl,...mapData.teleporters.map(t=>t.texture)])];
let imagesLoaded=0;

const DOM={canvas:document.getElementById("gameCanvas"),background:document.getElementById('background'),loadingBar:document.getElementById('loadingBar'),loadingText:document.getElementById('loadingText'),loadingScreen:document.getElementById('loadingScreen'),hud:{dash:document.getElementById('dash'),airhop:document.getElementById('airhop'),sword:document.getElementById('sword'),slopeInfo:document.getElementById('slopeInfo')}};

let canvasWidth=window.innerWidth, canvasHeight=window.innerHeight;

function preloadImages(){
  imagesToLoad.forEach(src=>{
    const img=new Image();
    img.src=src;
    img.onload=()=>{textureCache.set(src,{w:img.width,h:img.height});imagesLoaded++;updateLoading();}
    img.onerror=()=>{imagesLoaded++;updateLoading();}
  });
}

function updateLoading(){
  const progress=(imagesLoaded/imagesToLoad.length)*100;
  DOM.loadingBar.style.width=`${progress}%`;
  DOM.loadingText.textContent=`Laden... ${Math.round(progress)}%`;
  if(imagesLoaded===imagesToLoad.length)setTimeout(()=>{DOM.loadingScreen.style.display='none';startGame();},500);
}

let gameStarted=false;

function startGame(){
  if(gameStarted)return;
  gameStarted=true;

  const {Engine,Render,Runner,Bodies,World,Body,Events,Composite,Query,Vector}=Matter;
  DOM.canvas.width=canvasWidth;
  DOM.canvas.height=canvasHeight;

  const engine=Engine.create();
  engine.world.gravity.y=CONFIG.gravity;

  const render=Render.create({canvas:DOM.canvas,engine:engine,options:{width:canvasWidth,height:canvasHeight,wireframes:false,background:'transparent'}});
  Render.run(render);
  const runner=Runner.create();
  Runner.run(runner,engine);

  let player=Bodies.rectangle(mapData.playerStart.x,mapData.playerStart.y,mapData.playerStart.w,mapData.playerStart.h,{
    restitution:0,
    friction:0,
    frictionAir:0.02,
    frictionStatic:0,
    render:{fillStyle:'#f00'},
    label:'player',
    collisionFilter:CONFIG.player.collisionFilter
  });
  player.render.zIndex=1;
  World.add(engine.world,player);

  mapData.platforms.forEach(p=>{
    const texture=mapData.textures[p.textureId];
    const imgSize=textureCache.get(texture)||{w:p.w,h:p.h};
    const body=Bodies.rectangle(p.x,p.y,p.w,p.h,{
      isStatic:true,
      restitution:0,
      friction:0,
      frictionStatic:0,
      render:texture?{sprite:{texture,xScale:p.w/imgSize.w,yScale:p.h/imgSize.h}}:{fillStyle:'#654321'},
      label:'platform',
      angle:(p.angle||0)*Math.PI/180,
      collisionFilter:{category:0x0002,mask:0x0001},
      zIndex:0,
      id:p.id
    });
    World.add(engine.world,body);
  });

  // Teleporters
  const teleporters={};
  mapData.teleporters.forEach(t=>{
    const imgSize=textureCache.get(t.texture)||{w:t.w,h:t.h};
    const body=Bodies.rectangle(t.x,t.y,t.w,t.h,{
      isStatic:true,
      isSensor:true,
      render:{sprite:{texture:t.texture,xScale:t.w/imgSize.w,yScale:t.h/imgSize.h}},
      label:'teleporter',
      id:t.id
    });
    body.linkedId=t.linkedId;
    body.onCooldown=false;
    teleporters[t.id]=body;
    World.add(engine.world,body);
  });

  const state={keys:{left:false,right:false,up:false,dash:false,hop:false,sword:false,run:false},isDashing:false,dashStartTime:0,lastDash:0,lastHop:0,isFrozen:false,facingDirection:1};

  const keyMap={ArrowLeft:'left',ArrowRight:'right',ArrowUp:'up',ShiftLeft:'dash',ShiftRight:'dash',Space:'hop',KeyC:'sword',KeyR:'run'};

  document.addEventListener('keydown',e=>{if(keyMap[e.code]) state.keys[keyMap[e.code]]=true;});
  document.addEventListener('keyup',e=>{if(keyMap[e.code]) state.keys[keyMap[e.code]]=false;});

  function isPlayerOnGround(){
    const sensorOffsetY = CONFIG.player.size/2 + 0.5;
    const sensor = Bodies.rectangle(player.position.x,player.position.y + sensorOffsetY, CONFIG.player.size, 2, { isSensor:true, isStatic:true, collisionFilter: CONFIG.player.collisionFilter, render:{fillStyle:'transparent'} });
    World.add(engine.world,sensor);
    const collisions=Query.collides(sensor, Composite.allBodies(engine.world));
    World.remove(engine.world,sensor);

    let isOnGround=false, onSlope=false, slopeAngle=0;
    for(const c of collisions){
      const other=c.bodyA.label==='platform'?c.bodyA:c.bodyB.label==='platform'?c.bodyB:null;
      if(other){isOnGround=true; const plat=mapData.platforms.find(p=>p.id===other.id); if(plat && plat.angle!==0){onSlope=true; slopeAngle=plat.angle;} break;}
    }
    return {isOnGround,onSlope,slopeAngle};
  }

  window.addEventListener('resize',()=>{
    canvasWidth=window.innerWidth; canvasHeight=window.innerHeight;
    DOM.canvas.width=canvasWidth; DOM.canvas.height=canvasHeight;
    render.options.width=canvasWidth; render.options.height=canvasHeight;
  });

  Events.on(engine,'beforeUpdate',()=>{
    const now=Date.now();
    const ground=isPlayerOnGround();

    if(state.keys.right&&!state.keys.left)state.facingDirection=1;
    else if(state.keys.left&&!state.keys.right)state.facingDirection=-1;

    // Smooth horizontal input
    let targetVX=(state.keys.right?CONFIG.player.speed:0)-(state.keys.left?CONFIG.player.speed:0);
    if(state.keys.run) targetVX=(state.keys.right?CONFIG.player.runSpeed:0)-(state.keys.left?CONFIG.player.runSpeed:0);
    const lerpFactor=0.15;
    Body.setVelocity(player,{x:player.velocity.x + (targetVX - player.velocity.x)*lerpFactor, y:player.velocity.y});

    // Slope glide
    if(ground.onSlope){
      const slopeRad = ground.slopeAngle*Math.PI/180;
      const vy = Math.tan(slopeRad)*player.velocity.x;
      Body.setVelocity(player,{x:player.velocity.x, y:vy});
    }

    // Jump/AirHop
    if(state.keys.up && ground.isOnGround) Body.setVelocity(player,{x:player.velocity.x, y:CONFIG.player.jumpVelocity});
    if(state.keys.hop && !ground.isOnGround && now-state.lastHop>=CONFIG.player.hopCooldown){ Body.setVelocity(player,{x:player.velocity.x, y:CONFIG.player.airHopVelocity}); state.lastHop=now;}

    // Smooth rotation along slope
    const targetAngle = ground.onSlope ? ground.slopeAngle*Math.PI/180 : 0;
    const maxTilt = CONFIG.rotationLimit*Math.PI/180;
    const clamped = Math.max(Math.min(player.angle,targetAngle+maxTilt),targetAngle-maxTilt);
    Body.setAngle(player,player.angle + (clamped - player.angle)*0.2);

    DOM.hud.slopeInfo.textContent = ground.onSlope ? `Slope: Active (${Math.round(ground.slopeAngle)}°)` : 'Slope: None (0°)';
    DOM.hud.slopeInfo.className=`ability ${ground.onSlope?'ready':''}`;

    // Teleporter logic
    Object.values(teleporters).forEach(tp=>{
      if(tp.onCooldown) return;
      const collided=Query.collides(player,[tp]).length>0;
      if(collided){
        const dest=teleporters[tp.linkedId];
        if(dest && !dest.onCooldown){
          Body.setPosition(player,{x:dest.position.x, y:dest.position.y - (player.bounds.max.y - player.position.y)});
          tp.onCooldown=true;
          dest.onCooldown=true;
          setTimeout(()=>{tp.onCooldown=false; dest.onCooldown=false;}, CONFIG.teleporterCooldown);
        }
      }
    });
  });
}

preloadImages();
</script>
</body>
</html>
