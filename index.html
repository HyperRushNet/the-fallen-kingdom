<!-- The Fallen Kingdom - Still in development! -->
<!-- 2025 - HyperRush Network - Do not use this code without permission from hyperrushnetwork@gmail.com -->

<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Platformer Runner - No Fall Rotation</title>
<style>
  body { margin: 0; overflow: hidden; font-family: sans-serif; color: white; }
  #background { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-color: #08003b }
  canvas { display: block; background: transparent; }
  #hud { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; font-size: 16px; z-index: 1; }
  .ability { margin-bottom: 5px; }
  .ready { color: #0f0; }
  .cooldown { color: #f00; }
  #loadingScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; }
  #loadingBarContainer { width: 300px; height: 20px; background: #333; border: 1px solid #666; border-radius: 10px; overflow: hidden; }
  #loadingBar { width: 0; height: 100%; background: #0f0; transition: width 0.3s ease; }
  #loadingText { color: white; margin-top: 10px; font-size: 18px; }
  #fpsMeter { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.5); color: #0f0; padding: 5px 10px; border-radius: 5px; font-family: monospace; z-index: 2; }
</style>
</head>
<body>
<div id="loadingScreen">
  <div id="loadingBarContainer"><div id="loadingBar"></div></div>
  <div id="loadingText">Laden... 0%</div>
</div>
<div id="background"></div>
<div id="hud">
  <div class="ability" id="dash">Dash (Shift): Ready</div>
  <div class="ability" id="airhop">Air Hop (Space): Ready</div>
  <div class="ability" id="sword">Sword (C): Ready</div>
  <div class="ability" id="slopeInfo">Slope: None (0°)</div>
</div>
<div id="fpsMeter">FPS: 0</div>
<canvas id="gameCanvas"></canvas>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
const CONFIG = {
  gravity: 1.2,
  player: { size: 50, speed: 5, runSpeed: 7, dashSpeed: 15, jumpVelocity: -15, airHopVelocity: -12, dashDuration: 100, dashCooldown: 2000, hopCooldown: 1500, collisionFilter: { category: 0x0001, mask: 0x0002 } },
  sword: { height: 25, swingDuration: 200, swingArc: Math.PI/2, offsetX: 35, offsetY: 0, collisionFilter: { category: 0x0008, mask: 0x0002 } },
  camera: { smoothFactor: 0.2, bgPanSpeed: 0.5 },
  culling: { physicsMargin: 200, renderMargin: 100 },
  rotationLimit: 1
};

const mapData = {
  "playerStart": {
    "x": 200,
    "y": 200,
    "w": 50,
    "h": 50
  },
  "textures": [],
  "platforms": [
    {
      "id": "69TEfZW83EIM-bgZN9zrTdKyr",
      "type": "platform",
      "x": 232,
      "y": 300,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null
    },
    {
      "id": "utxBmqhLc86O-qb4x9YJeDzEw",
      "type": "platform",
      "x": 372,
      "y": 302,
      "w": 100,
      "h": 20,
      "angle": 20,
      "textureId": null
    },
    {
      "id": "qeiXiq9nAQKv-u1EDdTjHgDD5",
      "type": "wall",
      "x": 445,
      "y": 223,
      "w": 1000,
      "h": 20,
      "angle": 90,
      "textureId": null
    }
  ],
  "decor": [
    {
      "id": "gyHoIVudykl1-28OSSE6ji3gN",
      "type": "decor",
      "x": 385,
      "y": 255,
      "w": 100,
      "h": 20,
      "angle": -20,
      "layer": "front",
      "textureId": null
    }
  ]
};

const swordRightUrl='https://hyperrushnet.github.io/v3concept/sword-image-game-no-bg.png';
const swordLeftUrl='https://hyperrushnet.github.io/game/images/sword-left.png';
const textureCache=new Map();
const imagesToLoad=[...new Set([...mapData.textures,swordRightUrl,swordLeftUrl])];
let imagesLoaded=0;

const DOM={canvas:document.getElementById("gameCanvas"),background:document.getElementById('background'),loadingBar:document.getElementById('loadingBar'),loadingText:document.getElementById('loadingText'),loadingScreen:document.getElementById('loadingScreen'),hud:{dash:document.getElementById('dash'),airhop:document.getElementById('airhop'),sword:document.getElementById('sword'),slopeInfo:document.getElementById('slopeInfo')}};

let canvasWidth=window.innerWidth;
let canvasHeight=window.innerHeight;

function preloadImages(){
  imagesToLoad.forEach(src=>{
    const img=new Image();
    img.src=src;
    img.onload=()=>{textureCache.set(src,{w:img.width,h:img.height});imagesLoaded++;updateLoading();}
    img.onerror=()=>{imagesLoaded++;updateLoading();}
  });
}

function updateLoading(){
  const progress=(imagesLoaded/imagesToLoad.length)*100;
  DOM.loadingBar.style.width=`${progress}%`;
  DOM.loadingText.textContent=`Laden... ${Math.round(progress)}%`;
  if(imagesLoaded===imagesToLoad.length)setTimeout(()=>{DOM.loadingScreen.style.display='none';startGame();},500);
}

let gameStarted=false;

function startGame(){
  if(gameStarted)return;
  gameStarted=true;

  const {Engine,Render,Runner,Bodies,World,Body,Events,Composite,Query}=Matter;
  DOM.canvas.width=canvasWidth;
  DOM.canvas.height=canvasHeight;

  const engine=Engine.create();
  engine.world.gravity.y=CONFIG.gravity;

  const render=Render.create({canvas:DOM.canvas,engine:engine,options:{width:canvasWidth,height:canvasHeight,wireframes:false,background:'transparent'}});
  Render.run(render);
  const runner=Runner.create();
  Runner.run(runner,engine);

  let player=Bodies.rectangle(mapData.playerStart.x,mapData.playerStart.y,mapData.playerStart.w,mapData.playerStart.h,{
    restitution:0,
    friction:0,
    frictionAir:0.02,
    render:{fillStyle:'#f00'},
    label:'player',
    collisionFilter:CONFIG.player.collisionFilter
  });
  player.render.zIndex=1;
  World.add(engine.world,player);

  let camPos={x:mapData.playerStart.x,y:mapData.playerStart.y};
  let camTarget={x:camPos.x,y:camPos.y};

  mapData.platforms.forEach(p=>{
    const texture=mapData.textures[p.textureId];
    const imgSize=textureCache.get(texture)||{w:p.w,h:p.h};
    const body=Bodies.rectangle(p.x,p.y,p.w,p.h,{
      isStatic:true,
      restitution:0,
      friction:0,
      frictionStatic:0,
      render:texture?{sprite:{texture,xScale:p.w/imgSize.w,yScale:p.h/imgSize.h}}:{fillStyle:p.type==='wall'?'#444':'#654321'},
      label:p.type,
      angle:(p.angle||0)*Math.PI/180,
      collisionFilter:{category:0x0002,mask:0x0001},
      zIndex:0,
      id:p.id
    });
    World.add(engine.world,body);
  });

  mapData.decor?.forEach(d=>{
    const texture=mapData.textures[d.textureId];
    const imgSize=textureCache.get(texture)||{w:d.w,h:d.h};
    const decor=Bodies.rectangle(d.x,d.y,d.w,d.h,{isStatic:true,isSensor:true,render:texture?{sprite:{texture,xScale:d.w/imgSize.w,yScale:d.h/imgSize.h}}:{fillStyle:'#888'},label:'decor',collisionFilter:{mask:0x0000}});
    decor.render.zIndex=d.layer==='behind'?-1:d.layer==='front'?2:0;
    World.add(engine.world,decor);
  });

  let sword;
  const swordScale=(CONFIG.player.size*0.5)/220;
  sword=Bodies.rectangle(-1000,-1000,540*swordScale,220*swordScale,{isSensor:false,restitution:0,render:{sprite:{texture:swordRightUrl,xScale:swordScale,yScale:swordScale,opacity:1}},label:'sword',collisionFilter:CONFIG.sword.collisionFilter});
  sword.render.zIndex=1;
  sword.active=false;
  World.add(engine.world,sword);

  const state={keys:{left:false,right:false,up:false,dash:false,hop:false,sword:false,run:false},isDashing:false,dashStartTime:0,lastDash:0,lastHop:0,isFrozen:false,facingDirection:1};
  const keyMap={ArrowLeft:'left',ArrowRight:'right',ArrowUp:'up',ShiftLeft:'dash',ShiftRight:'dash',Space:'hop',KeyC:'sword',KeyR:'run'};

  let lastSwordTime = 0;
  const swordCooldown = 50;
  let swordInterval;

  document.addEventListener('keydown',e=>{
    if(keyMap[e.code]) state.keys[keyMap[e.code]]=true;
    if(e.code==='KeyC') startSwordSwing();
  });
  document.addEventListener('keyup',e=>{
    if(keyMap[e.code]) state.keys[keyMap[e.code]]=false;
  });

  function startSwordSwing(){
    const now = Date.now();
    if(now-lastSwordTime < swordCooldown) return;
    lastSwordTime = now;
    if(swordInterval) clearInterval(swordInterval);
    sword.active=true;
    const dir=state.facingDirection;
    sword.render.sprite.texture=dir===1?swordRightUrl:swordLeftUrl;
    const swingDuration=CONFIG.sword.swingDuration;
    const startAngle=-Math.PI/4;
    const endAngle=Math.PI/4;
    const totalSteps=swingDuration/16;
    let stepCount=0;
    sword.isStatic=true;
    sword.render.visible=true;

    swordInterval=setInterval(()=>{
      const t=stepCount/totalSteps;
      const angle=startAngle+(endAngle-startAngle)*t;
      const offsetX=CONFIG.sword.offsetX*dir;
      const offsetY=CONFIG.sword.offsetY;
      const x=player.position.x+offsetX;
      const y=player.position.y+offsetY;
      Body.setPosition(sword,{x,y});
      Body.setAngle(sword,angle*dir);
      stepCount++;
      if(stepCount>totalSteps){clearInterval(swordInterval);sword.active=false;sword.render.visible=false;sword.isStatic=false;Body.setPosition(sword,{x:-1000,y:-1000});}
    },16);
  }

  function isPlayerOnGround(){
    const sensorOffsetY = CONFIG.player.size / 2 + 0.5;
    const groundSensor = Bodies.rectangle(player.position.x,player.position.y + sensorOffsetY, CONFIG.player.size, 2, { isSensor:true, isStatic:true, collisionFilter: CONFIG.player.collisionFilter, render:{fillStyle:'transparent'} });
    World.add(engine.world, groundSensor);
    const bodies = Composite.allBodies(engine.world);
    const collisions = Query.collides(groundSensor, bodies);
    World.remove(engine.world, groundSensor);

    let isOnGround=false, onSlope=false, slopeAngle=0;
    for(const collision of collisions){
      const otherBody = collision.bodyA.label==='platform'?collision.bodyA:collision.bodyB.label==='platform'?collision.bodyB:null;
      if(otherBody && otherBody.label==='platform'){
        isOnGround=true;
        const platform = mapData.platforms.find(p=>p.id===otherBody.id);
        if(platform && platform.angle!==0){onSlope=true; slopeAngle=Math.round(platform.angle);}
        break;
      }
    }
    return { isOnGround, onSlope, slopeAngle };
  }

  function updateHUD(){
    const now=Date.now();
    const updateStatus=(element,name,lastTime,cooldown)=>{
      const isReady=now-lastTime>=cooldown;
      element.className=`ability ${isReady?'ready':'cooldown'}`;
      element.textContent=`${name}: ${isReady?'Ready':'Cooldown'}`;
    };
    updateStatus(DOM.hud.dash,'Dash (Shift)',state.lastDash,CONFIG.player.dashCooldown);
    updateStatus(DOM.hud.airhop,'Air Hop (Space)',state.lastHop,CONFIG.player.hopCooldown);
    DOM.hud.sword.className='ability ready';
    DOM.hud.sword.textContent=`Sword (C): ${Date.now()-lastSwordTime>=swordCooldown?'Ready':'Cooldown'}`;
  }

  window.addEventListener('resize',()=>{
    canvasWidth=window.innerWidth;
    canvasHeight=window.innerHeight;
    DOM.canvas.width=canvasWidth;
    DOM.canvas.height=canvasHeight;
    render.options.width=canvasWidth;
    render.options.height=canvasHeight;
  });

  Render.lookAt(render,{min:{x:mapData.playerStart.x-canvasWidth/2,y:mapData.playerStart.y-canvasHeight/2},max:{x:mapData.playerStart.x+canvasWidth/2,y:mapData.playerStart.y+canvasHeight/2}});

  let lastTime=performance.now();
  let frames=0;
  let fps=0;
  function updateFPS(){
    const now=performance.now();
    frames++;
    if(now-lastTime>=1000){fps=frames;frames=0;lastTime=now;document.getElementById('fpsMeter').textContent='FPS: '+fps;}
    requestAnimationFrame(updateFPS);
  }
  updateFPS();

  Events.on(engine,'beforeUpdate',()=>{
    const now=Date.now();
    if(state.keys.right&&!state.keys.left)state.facingDirection=1;
    else if(state.keys.left&&!state.keys.right)state.facingDirection=-1;

    if(!state.isFrozen){
      if(state.keys.dash&&!state.isDashing&&now-state.lastDash>=CONFIG.player.dashCooldown){
        let dashDir=0;
        if(state.keys.left)dashDir=-CONFIG.player.dashSpeed;
        if(state.keys.right)dashDir=CONFIG.player.dashSpeed;
        if(dashDir!==0){Body.setVelocity(player,{x:dashDir,y:player.velocity.y});state.isDashing=true;state.dashStartTime=now;state.lastDash=now;}
      }
      if(state.isDashing&&now-state.dashStartTime>=CONFIG.player.dashDuration){state.isDashing=false;Body.setVelocity(player,{x:0,y:player.velocity.y});}

      const groundInfo=isPlayerOnGround();
      let moveSpeed = (state.keys.right?CONFIG.player.speed:0)-(state.keys.left?CONFIG.player.speed:0);
      if(state.keys.run) moveSpeed = (state.keys.right?CONFIG.player.runSpeed:0)-(state.keys.left?CONFIG.player.runSpeed:0);
      Body.setVelocity(player,{x:player.velocity.x + (moveSpeed - player.velocity.x)*0.2, y:player.velocity.y});

      // Air hop
      if(state.keys.hop && !groundInfo.isOnGround && now-state.lastHop>=CONFIG.player.hopCooldown){
          Body.setVelocity(player, { x: player.velocity.x, y: CONFIG.player.airHopVelocity });
          state.lastHop=now;
      }

      if(state.keys.up && groundInfo.isOnGround){Body.setVelocity(player,{x:player.velocity.x, y:CONFIG.player.jumpVelocity});}
    }

    const { onSlope, slopeAngle }=isPlayerOnGround();
    const maxTilt = CONFIG.rotationLimit * Math.PI/180;
    let targetAngle = onSlope ? slopeAngle*Math.PI/180 : 0;
    let clampedAngle = Math.max(Math.min(player.angle, targetAngle+maxTilt), targetAngle-maxTilt);
    const lerpSpeed = onSlope ? 0.2 : 0.15;
    const newAngle = player.angle + (clampedAngle - player.angle) * lerpSpeed;
    Body.setAngle(player,newAngle);

    DOM.hud.slopeInfo.textContent = onSlope ? `Slope: Active (${slopeAngle}°)` : `Slope: None (0°)`;
    DOM.hud.slopeInfo.className = `ability ${onSlope?'ready':''}`;

    camTarget.x=player.position.x;
    camTarget.y=player.position.y;
    camPos.x+=(camTarget.x-camPos.x)*CONFIG.camera.smoothFactor;
    camPos.y+=(camTarget.y-camPos.y)*CONFIG.camera.smoothFactor;

    const camX=camPos.x-canvasWidth/2;
    const camY=camPos.y-canvasHeight/2;
    render.bounds.min.x=camX;
    render.bounds.min.y=camY;
    render.bounds.max.x=camX+canvasWidth;
    render.bounds.max.y=camY+canvasHeight;
    Render.lookAt(render,{min:{x:camX,y:camY},max:{x:camX+canvasWidth,y:camY+canvasHeight}});
    DOM.background.style.backgroundPosition=`${-camX*CONFIG.camera.bgPanSpeed}px ${-camY*CONFIG.camera.bgPanSpeed}px`;

    const physicsMargin = CONFIG.culling.physicsMargin;
    const physCullBounds = {min:{x:camX-physicsMargin,y:camY-physicsMargin},max:{x:camX+canvasWidth+physicsMargin,y:camY+canvasHeight+physicsMargin}};
    const bodies=Composite.allBodies(engine.world);
    bodies.sort((a,b)=>(a.render.zIndex||0)-(b.render.zIndex||0));
    bodies.forEach(body=>{
      if(body.label==='player'||body.label==='sword') return;
      const b=body.bounds;
      const inPhysView=b.max.x>physCullBounds.min.x&&b.min.x<physCullBounds.max.x&&b.max.y>physCullBounds.min.y&&b.min.y<physCullBounds.max.y;
      if(inPhysView){
        if(body.label==='platform'||body.label==='slope') body.collisionFilter.mask=0x0001;
      } else {
        body.collisionFilter.mask=0x0000;
      }
    });

    const renderMargin = CONFIG.culling.renderMargin;
    const cullBounds={min:{x:camX-renderMargin,y:camY-renderMargin},max:{x:camX+canvasWidth+renderMargin,y:camY+canvasHeight+renderMargin}};
    bodies.forEach(body=>{
      if(body.label==='player'||body.label==='sword'){body.render.visible=true;return;}
      const b=body.bounds;
      const inView=b.max.x>cullBounds.min.x&&b.min.x<cullBounds.max.x&&b.max.y>cullBounds.min.y&&b.min.y<cullBounds.max.y;
      body.render.visible=inView;
    });
  });

  setInterval(updateHUD,16);
}

preloadImages();
</script>
</body>
</html>
