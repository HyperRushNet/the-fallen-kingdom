<!-- The Fallen Kingdom - v2.3.7 - Fixed wall and slope bugs (friction) -->
<!----------------------------------------->
<!-- Copyright, HyperRush Network - 2025 -->
<!-- hyperrushnetwork@gmail.com -->
<!--------------------->
<!-- Game code START -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>v2.3.7 - The Fallen Kingdom</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=MedievalSharp&display=swap" rel="stylesheet">
<style>
  body{margin:0;overflow:hidden;font-family:'MedievalSharp',cursive;color:#e6d7b7;background:#000}
  #background{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;background-color:black;opacity:0}
  canvas{display:block;background:transparent;position:relative;z-index:10}
  #hud{position:fixed;top:10px;left:10px;background:rgba(20,15,10,0.8);padding:10px;border-radius:8px;border:1px solid #d4af37;font-size:12px;z-index:100;min-width:150px}
  .ability{margin-bottom:8px;display:flex;align-items:center;gap:5px}
  .ability-icon{width:16px;height:16px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:10px;color:white;background:#2a2a2a;border:1px solid #d4af37}
  .ready{color:#90ee90}
  .cooldown{color:#ff6b6b}
  .slope-info{background:rgba(0,0,0,0.3);padding:3px 6px;border-radius:3px;margin-top:5px;font-size:11px}
  .coords{font-family:'Courier New',monospace;background:rgba(0,0,0,0.4);padding:3px;border-radius:3px;margin-top:5px;font-size:11px}
  .health-container{margin-top:5px;display:flex;align-items:center;gap:5px;font-size:11px}
  .health-bar{flex:1;height:6px;background:rgba(0,0,0,0.5);border-radius:3px;overflow:hidden;border:1px solid #d4af37}
  .health-fill{height:100%;background:linear-gradient(90deg,#ff0000,#00ff00);transition:width 0.3s ease;border-radius:2px}
  #loadingScreen{position:fixed;top:0;left:0;width:100%;height:100%;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:1000}
  #loadingBarContainer{width:min(400px,90vw);height:20px;background:#333;border:1px solid #d4af37;border-radius:10px;overflow:hidden;margin:0 10px}
  #loadingBar{width:0;height:100%;background:#d4af37;transition:width 0.3s ease;border-radius:8px}
  #loadingText{color:#e6d7b7;margin-top:10px;font-size:clamp(14px,4vw,16px);text-shadow:0 0 5px #d4af37;font-family:'Cinzel',serif}
  .title{font-size:clamp(24px,8vw,40px);color:#d4af37;margin-bottom:10px;text-shadow:1px 1px 2px rgba(0,0,0,0.8);font-family:'Cinzel',serif}
  #startButton{margin-top:15px;padding:clamp(8px,2vw,10px) clamp(16px,4vw,20px);background:#d4af37;color:#1a0f0a;border:none;border-radius:25px;font-size:clamp(14px,4vw,16px);cursor:pointer;display:none;font-family:'Cinzel',serif;font-weight:600;transition:background 0.3s ease;touch-action:manipulation}
  #fpsMeter{position:fixed;top:10px;right:10px;background:rgba(20,15,10,0.8);color:#90ee90;padding:5px 10px;border-radius:5px;font-family:'Courier New',monospace;z-index:101;border:1px solid #90ee90;font-size:clamp(10px,3vw,12px)}
  @media (max-width:768px){
    #hud{top:5px;left:5px;padding:8px;font-size:clamp(10px,3vw,12px);min-width:auto;width:calc(100vw-10px);max-width:300px;border-radius:6px}
    .ability{flex-wrap:wrap;gap:3px}
    .ability-icon{width:14px;height:14px;font-size:9px}
    .slope-info,.coords{font-size:clamp(9px,2.5vw,11px);padding:2px 4px}
    .health-container{font-size:clamp(9px,2.5vw,11px);gap:3px}
    .health-bar{height:5px}
    #fpsMeter{top:5px;right:5px;padding:4px 8px;font-size:clamp(9px,2.5vw,12px)}
    .title{margin-bottom:5px}
    #loadingBarContainer{margin:5px 10px}
    #startButton{margin-top:10px}
  }
  #lightCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 15;
    pointer-events: none;
    mix-blend-mode: multiply;
  }
</style>
</head>
<body>
<div id="loadingScreen">
  <div class="title">The Fallen Kingdom</div>
  <div id="loadingBarContainer"><div id="loadingBar"></div></div>
  <div id="loadingText">Loading... 0%</div>
  <button id="startButton">Start Game</button>
</div>
<div id="background"></div>
<div id="hud">
  <div class="ability" id="dash">
    <div class="ability-icon">‚ö°</div>
    <span>Dash (Shift): Ready</span>
  </div>
  <div class="ability" id="airhop">
    <div class="ability-icon">ü¶Ö</div>
    <span>Air Hop (Space): Ready</span>
  </div>
  <div class="ability" id="block">
    <div class="ability-icon">‚öîÔ∏è</div>
    <span>Sword (C): Ready</span>
  </div>
  <div class="slope-info" id="slopeInfo">Slope: None (0¬∞)</div>
  <div class="coords" id="playerCoords">Coords: (0, 0)</div>
  <div class="health-container">
    <span>Health:</span>
    <div class="health-bar">
      <div class="health-fill" id="healthFill" style="width: 100%;"></div>
    </div>
    <span id="healthText">100</span>
  </div>
  <div class="coords" id="objectsInView">Objects in view: 0</div>
</div>
<div id="fpsMeter">FPS: 0</div>
<canvas id="gameCanvas"></canvas>
<canvas id="lightCanvas"></canvas>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
  const CONFIG = {
    gravity: 1.3,
    maxGravityAcceleration: 15,
    zIndex: {
        background: 0,
        sword: 10,
        decor: 2,
        platform: 3,
        player: 4,
        hud: 100,
        fpsMeter: 101,
        loadingScreen: 1000
    },
    parallax: {
        decor: 0.5
    },
    player: {
        width: 50,
        height: 75,
        speed: 5,
        runSpeed: 7,
        dashSpeed: 15,
        jumpVelocity: -15,
        airHopVelocity: -12,
        dashDuration: 200,
        dashCooldown: 500,
        hopCooldown: 1000,
        collisionFilter: {
            category: 0x0001,
            mask: 0x0002 | 0x0004
        }
    },
    sword: {
        width: 50,
        height: 75,
        offsetYUp: 1
    },
    camera: {
        smoothFactor: 0.2,
        bgPanSpeed: 0,
        cullThreshold: 50
    },
    culling: {
        physicsMargin: 300,
        renderMargin: 100
    },
    rotationLimit: 5,
    maxVideoResolution: {
        width: 1920,
        height: 1080
    },
    fixedDelta: 1000 / 60,
    light: {
      enabled: true,
      radius: 200,
      gradientStops: [
        { offset: 0, color: 'rgba(255, 255, 255, 0.3)' },
        { offset: 0.5, color: 'rgba(0, 0, 0, 0.2)' },
        { offset: 1, color: 'rgba(0, 0, 0, 0.7)' }
      ],
      blendMode: 'multiply',
      canvasZIndex: 15
    },
    hudUpdateInterval: 100
  };

  const mapData = {
  "playerStart": {
    "x": 347,
    "y": 262,
    "w": 50,
    "h": 75,
    "zIndex": 1,
    "angle": 0
  },
  "textures": [
    "https://static.vecteezy.com/system/resources/previews/003/711/473/large_2x/rough-stone-texture-photo.jpg"
  ],
  "platforms": [
    {
      "id": "Fv1D2fXtvgSh-xH6roNigQlf6",
      "type": "platform",
      "x": 345,
      "y": 312,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": 0,
      "zIndex": 1
    }
  ],
  "decor": []
};

  const playerAnimations = {
    idle: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    runLeft: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    runRight: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    jump: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    fall: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackUp: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackDown: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackLeft: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackRight: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm'
  };

  const swordAnimations = {
    attackUp: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackDown: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackLeft: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackRight: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm'
  };

  const textureCache = new Map();
  const videoTextures = new Map();
  let soundtrack;
  const uniqueImageUrls = [...new Set(mapData.textures.filter(src => !src.endsWith('.webm')))];
  const uniqueVideoUrls = [...new Set([...Object.values(playerAnimations), ...Object.values(swordAnimations), ...mapData.textures.filter(src => src.endsWith('.webm'))])];
  let totalAssets = uniqueImageUrls.length + uniqueVideoUrls.length + 1;
  let loadedAssets = 0;

  const DOM = {
    canvas: document.getElementById("gameCanvas"),
    lightCanvas: document.getElementById("lightCanvas"),
    background: document.getElementById('background'),
    loadingBar: document.getElementById('loadingBar'),
    loadingText: document.getElementById('loadingText'),
    loadingScreen: document.getElementById('loadingScreen'),
    startButton: document.getElementById('startButton'),
    hud: {
      dash: document.getElementById('dash'),
      airhop: document.getElementById('airhop'),
      block: document.getElementById('block'),
      slopeInfo: document.getElementById('slopeInfo'),
      playerCoords: document.getElementById('playerCoords'),
      health: document.getElementById('healthText'),
      healthFill: document.getElementById('healthFill'),
      objectsInView: document.getElementById('objectsInView')
    }
  };

  let canvasWidth = window.innerWidth;
  let canvasHeight = window.innerHeight;
  let screenPlayerPos = { x: 0, y: 0 };

  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  function preloadImages() {
    uniqueImageUrls.forEach(src => {
      const img = new Image();
      img.src = src;
      img.crossOrigin = "anonymous";
      img.onload = () => {
        textureCache.set(src, { w: img.width, h: img.height, img });
        loadedAssets++;
        updateLoading();
      };
      img.onerror = () => {
        loadedAssets++;
        updateLoading();
      };
    });
  }

  function preloadAnimations() {
    uniqueVideoUrls.forEach((src, index) => {
      const video = document.createElement('video');
      video.src = src;
      video.crossOrigin = "anonymous";
      video.muted = true;
      video.playsInline = true;
      video.preload = "auto";
      video.addEventListener('loadedmetadata', () => {
        const playerVideo = video.cloneNode(true);
        playerVideo.loop = true;
        const playerData = { video: playerVideo, w: video.videoWidth, h: video.videoHeight, loaded: true, isPlaying: false, lastVisible: false };
        Object.keys(playerAnimations).forEach(key => {
          videoTextures.set(`player_${key}`, playerData);
        });

        const swordVideo = video.cloneNode(true);
        swordVideo.loop = false;
        const swordData = { video: swordVideo, w: video.videoWidth, h: video.videoHeight, loaded: true, isPlaying: false, duration: video.duration * 1000, lastVisible: false };
        Object.keys(swordAnimations).forEach(key => {
          videoTextures.set(`sword_${key}`, swordData);
        });

        if (mapData.textures.includes(src)) {
          videoTextures.set(`texture_${index}`, { video, w: video.videoWidth, h: video.videoHeight, loaded: true, isPlaying: false, lastVisible: false });
        }
        loadedAssets++;
        updateLoading();
      });
      video.onerror = () => {
        const fallbackPlayer = { video: null, w: 0, h: 0, loaded: true, isPlaying: false, lastVisible: false };
        Object.keys(playerAnimations).forEach(key => {
          videoTextures.set(`player_${key}`, fallbackPlayer);
        });
        const fallbackSword = { video: null, w: 0, h: 0, loaded: true, isPlaying: false, duration: 200, lastVisible: false };
        Object.keys(swordAnimations).forEach(key => {
          videoTextures.set(`sword_${key}`, fallbackSword);
        });
        if (mapData.textures.includes(src)) {
          videoTextures.set(`texture_${index}`, { video: null, w: 0, h: 0, loaded: true, isPlaying: false, lastVisible: false });
        }
        loadedAssets++;
        updateLoading();
      };
      video.load();
    });
  }

  function updateLoading() {
    const progress = totalAssets > 0 ? Math.min((loadedAssets / totalAssets) * 100, 100) : 0;
    DOM.loadingBar.style.width = `${progress}%`;
    DOM.loadingText.textContent = `Loading... ${Math.round(progress)}%`;
    if (loadedAssets >= totalAssets) {
      setTimeout(() => {
        DOM.startButton.style.display = 'block';
      }, 500);
    }
    setTimeout(() => {
      if (loadedAssets < totalAssets) {
        loadedAssets = totalAssets;
        DOM.loadingBar.style.width = '100%';
        DOM.loadingText.textContent = 'Loading... 100%';
        DOM.startButton.style.display = 'block';
      }
    }, 10000);
  }

  let gameStarted = false;
  const tempNearbyArray = [];
  const tempAllVisible = [];
  let lastCamPosForCull = { x: 0, y: 0 };
  let lastHudUpdate = 0;
  let lastGroundInfo = { isOnGround: false, onSlope: false, slopeAngle: 0 };

  function startGame() {
    if (gameStarted) return;
    gameStarted = true;
    soundtrack.play().catch(e => {});

    const { Engine, Render, Runner, Bodies, World, Body, Events, Composite, Query, Vector, Bounds, Common } = Matter;

    DOM.canvas.width = canvasWidth;
    DOM.canvas.height = canvasHeight;
    DOM.lightCanvas.width = canvasWidth;
    DOM.lightCanvas.height = canvasHeight;

    const engine = Engine.create();
    engine.world.gravity.y = CONFIG.gravity;
    engine.timing.timeScale = 1;
    Common._nextDelta = CONFIG.fixedDelta;

    const render = Render.create({
      canvas: DOM.canvas,
      engine: engine,
      options: {
        width: canvasWidth,
        height: canvasHeight,
        wireframes: false,
        background: 'transparent'
      }
    });

    const blockHitboxes = [];
    let initialCamPos = { x: mapData.playerStart.x, y: mapData.playerStart.y };
    let decorObjects = [];
    let staticRenderables = [];
    let staticBodies = [];

    function drawBodyVideo(ctx, source, x, y, w, h, angle) {
      if (!source) return;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.drawImage(source, -w / 2, -h / 2, w, h);
      ctx.restore();
    }

    function updateVideoPlay(videoData, isVisible) {
      if (!videoData || !videoData.video) return;
      if (isVisible !== videoData.lastVisible) {
        videoData.lastVisible = isVisible;
        if (isVisible && !videoData.isPlaying) {
          videoData.video.play().catch(() => {});
          videoData.isPlaying = true;
        } else if (!isVisible && videoData.isPlaying) {
          videoData.video.pause();
          videoData.isPlaying = false;
        }
      }
    }

    const boundsOverlap = (min1, max1, min2, max2) => !(max1.x < min2.x || min1.x > max2.x || max1.y < min2.y || min1.y > max2.y);

    Render.bodies = function(render, bodies, context) {
      const c = context;
      const baseCullBounds = {
        min: { x: render.bounds.min.x - CONFIG.culling.renderMargin, y: render.bounds.min.y - CONFIG.culling.renderMargin },
        max: { x: render.bounds.max.x + CONFIG.culling.renderMargin, y: render.bounds.max.y + CONFIG.culling.renderMargin }
      };
      tempAllVisible.length = 0;

      let visibleStatic = [];
      for (let i = 0; i < staticRenderables.length; i++) {
        const {type, item, zIndex} = staticRenderables[i];
        let b;
        if (type === 'body') {
          b = item.bounds;
        } else {
          if (!item.currentPos) continue;
          b = {
            min: { x: item.currentPos.x - item.w / 2, y: item.currentPos.y - item.h / 2 },
            max: { x: item.currentPos.x + item.w / 2, y: item.currentPos.y + item.h / 2 }
          };
        }
        if (b && boundsOverlap(baseCullBounds.min, baseCullBounds.max, b.min, b.max)) {
          visibleStatic.push({type, item, zIndex});
          let videoData;
          if (type === 'body' && item.platformVideo) {
            videoData = videoTextures.get(item.videoTextureId);
          } else if (type === 'decor' && item.isVideo) {
            videoData = videoTextures.get(item.videoTextureId);
          }
          if (videoData) updateVideoPlay(videoData, true);
        } else {
          let videoData;
          if (type === 'body' && item.platformVideo) {
            videoData = videoTextures.get(item.videoTextureId);
          } else if (type === 'decor' && item.isVideo) {
            videoData = videoTextures.get(item.videoTextureId);
          }
          if (videoData) updateVideoPlay(videoData, false);
        }
      }

      const dynamicVisible = [];
      const allBodies = Composite.allBodies(render.engine.world);
      for (let i = 0; i < allBodies.length; i++) {
        const body = allBodies[i];
        if (body.label === 'player' || body.label === 'block_hitbox' || body.label === 'particle') {
          const b = body.bounds;
          if (b && boundsOverlap(baseCullBounds.min, baseCullBounds.max, b.min, b.max)) {
            dynamicVisible.push({type: 'body', item: body, zIndex: body.render ? (body.render.zIndex || 0) : 0});
            if (body.playerVideo || body.swordVideo) {
              const videoData = videoTextures.get(body.videoTextureId);
              updateVideoPlay(videoData, true);
            }
          } else if (body.playerVideo || body.swordVideo) {
            const videoData = videoTextures.get(body.videoTextureId);
            updateVideoPlay(videoData, false);
          }
        }
      }

      tempAllVisible.length = 0;
      tempAllVisible.push(...visibleStatic, ...dynamicVisible);
      tempAllVisible.sort((a, b) => a.zIndex - b.zIndex);

      DOM.hud.objectsInView.textContent = `Objects in view: ${tempAllVisible.length}`;

      for (let i = 0; i < tempAllVisible.length; i++) {
        const {type, item} = tempAllVisible[i];
        if (type === 'decor') {
          const decor = item;
          if (decor.isVideo) {
            const videoData = videoTextures.get(decor.videoTextureId);
            if (videoData && videoData.loaded && videoData.video) {
              drawBodyVideo(c, videoData.video, decor.currentPos.x, decor.currentPos.y, decor.videoW || decor.w, decor.videoH || decor.h, decor.angle);
            } else {
              c.save();
              c.translate(decor.currentPos.x, decor.currentPos.y);
              c.rotate(decor.angle);
              c.fillStyle = '#888';
              c.fillRect(-decor.w / 2, -decor.h / 2, decor.w, decor.h);
              c.restore();
            }
          } else if (decor.isImage) {
            const textureSrc = mapData.textures[decor.textureId];
            const img = textureCache.get(textureSrc)?.img;
            if (img && img.complete) {
              c.save();
              c.translate(decor.currentPos.x, decor.currentPos.y);
              c.rotate(decor.angle);
              c.drawImage(img, -decor.w / 2, -decor.h / 2, decor.w, decor.h);
              c.restore();
            }
          }
        } else {
          const body = item;
          if (!body.position || (!body.circleRadius && (!body.width || !body.height))) continue;
          if (body.label === 'player' && body.playerVideo) {
            const videoData = videoTextures.get(body.videoTextureId);
            if (videoData && videoData.loaded && videoData.video) {
              drawBodyVideo(c, videoData.video, body.position.x, body.position.y, body.videoW || body.width, body.videoH || body.height, body.angle);
            } else {
              c.save();
              c.translate(body.position.x, body.position.y);
              c.rotate(body.angle);
              c.fillStyle = '#f00';
              c.fillRect(-body.width / 2, -body.height / 2, body.width, body.height);
              c.restore();
            }
          } else if (body.label === "platform" && body.platformVideo) {
            const videoData = videoTextures.get(body.videoTextureId);
            if (videoData && videoData.loaded && videoData.video) {
              drawBodyVideo(c, videoData.video, body.position.x, body.position.y, body.videoW || body.width, body.videoH || body.height, body.angle);
            } else {
              c.save();
              c.translate(body.position.x, body.position.y);
              c.rotate(body.angle);
              c.fillStyle = '#888';
              c.fillRect(-body.width / 2, -body.height / 2, body.width, body.height);
              c.restore();
            }
          } else if (body.label === 'block_hitbox' && body.swordVideo) {
            const videoData = videoTextures.get(body.videoTextureId);
            if (videoData && videoData.loaded && videoData.video) {
              if (!videoData.isPlaying) {
                videoData.video.currentTime = 0;
                videoData.video.play().catch(() => {});
                videoData.isPlaying = true;
              }
              drawBodyVideo(c, videoData.video, body.position.x, body.position.y, body.videoW || body.width, body.videoH || body.height, body.angle);
            } else {
              c.save();
              c.translate(body.position.x, body.position.y);
              c.rotate(body.angle);
              c.fillStyle = '#00ff00';
              c.fillRect(-body.width / 2, -body.height / 2, body.width, body.height);
              c.restore();
            }
          } else if (body.render.sprite && body.render.sprite.texture) {
            const img = textureCache.get(body.render.sprite.texture)?.img;
            if (img && img.complete) {
              c.save();
              c.translate(body.position.x, body.position.y);
              c.rotate(body.angle);
              c.drawImage(img, -body.width / 2, -body.height / 2, body.width, body.height);
              c.restore();
            }
          } else if (body.render.fillStyle) {
            c.save();
            c.translate(body.position.x, body.position.y);
            c.rotate(body.angle);
            c.fillStyle = body.render.fillStyle;
            if (body.circleRadius) {
              c.beginPath();
              c.arc(0, 0, body.circleRadius, 0, Math.PI * 2);
              c.fill();
            } else {
              c.fillRect(-body.width / 2, -body.height / 2, body.width, body.height);
            }
            c.restore();
          }
        }
      }
    };

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    let player = Bodies.rectangle(mapData.playerStart.x, mapData.playerStart.y, mapData.playerStart.w, mapData.playerStart.h, {
      restitution: 0,
      friction: 0,
      frictionAir: 0,
      frictionStatic: 0,
      inertia: Infinity,
      render: { zIndex: CONFIG.zIndex.player },
      label: 'player',
      collisionFilter: CONFIG.player.collisionFilter,
      playerVideo: true,
      videoTextureId: 'player_idle',
      videoW: mapData.playerStart.w,
      videoH: mapData.playerStart.h,
      health: 100,
      isStatic: false
    });
    player.width = mapData.playerStart.w;
    player.height = mapData.playerStart.h;
    World.add(engine.world, player);

    const groundSensor = Bodies.rectangle(mapData.playerStart.x, mapData.playerStart.y + mapData.playerStart.h / 2 + 1, mapData.playerStart.w, 3, {
      isSensor: true,
      isStatic: false,
      collisionFilter: CONFIG.player.collisionFilter,
      render: { visible: false, fillStyle: 'transparent' }
    });
    groundSensor.width = mapData.playerStart.w;
    groundSensor.height = 3;
    World.add(engine.world, groundSensor);

    let camPos = { x: mapData.playerStart.x, y: mapData.playerStart.y };
    let camTarget = { x: camPos.x, y: camPos.y };
    const walls = [];
    const platforms = [];

    mapData.platforms.forEach(p => {
      let body;
      const texture = mapData.textures[p.textureId];
      const zIndex = p.zIndex || CONFIG.zIndex.platform;
      if (texture.endsWith('.webm')) {
        body = Bodies.rectangle(p.x, p.y, p.w, p.h, {
          isStatic: true,
          restitution: 0,
          friction: 0,
          frictionStatic: 0,
          frictionAir: 0,
          label: p.type,
          angle: (p.angle || 0) * Math.PI / 180,
          collisionFilter: { category: 0x0004, mask: 0x0001 },
          render: { zIndex: zIndex }
        });
        body.platformVideo = true;
        body.videoTextureId = `texture_${p.textureId}`;
        body.videoW = p.w;
        body.videoH = p.h;
      } else {
        const imgSize = textureCache.get(texture) || { w: p.w, h: p.h };
        body = Bodies.rectangle(p.x, p.y, p.w, p.h, {
          isStatic: true,
          restitution: 0,
          friction: 0,
          frictionStatic: 0,
          frictionAir: 0,
          render: {
            sprite: texture ? { texture, xScale: p.w / imgSize.w, yScale: p.h / imgSize.h } : undefined,
            fillStyle: texture ? undefined : (p.type === 'wall' ? '#444' : '#654321'),
            zIndex: zIndex
          },
          label: p.type,
          angle: (p.angle || 0) * Math.PI / 180,
          collisionFilter: { category: 0x0004, mask: 0x0001 },
          id: p.id
        });
      }
      body.width = p.w;
      body.height = p.h;
      body.inWorld = true;
      World.add(engine.world, body);
      staticBodies.push(body);
      staticRenderables.push({type: 'body', item: body, zIndex: body.render.zIndex || 0});
      if (p.type === 'wall') walls.push(body);
      if (p.type === 'platform') platforms.push(body);
    });

    const collidableBodies = [...platforms, ...walls];
    const obstacles = collidableBodies;

    mapData.decor.forEach(d => {
      const texture = mapData.textures[d.textureId];
      const decor = {
        id: d.id,
        x: d.x,
        y: d.y,
        w: d.w,
        h: d.h,
        angle: (d.angle || 0) * Math.PI / 180,
        textureId: d.textureId,
        zIndex: d.zIndex || CONFIG.zIndex.decor,
        parallaxSpeed: d.parallaxSpeed !== undefined ? d.parallaxSpeed : CONFIG.parallax.decor,
        originalPos: { x: d.x, y: d.y }
      };
      decor.enteredView = false;
      decor.baseCamPos = null;
      if (texture.endsWith('.webm')) {
        decor.isVideo = true;
        decor.videoTextureId = `texture_${d.textureId}`;
        decor.videoW = d.w;
        decor.videoH = d.h;
      } else {
        decor.isImage = true;
      }
      decorObjects.push(decor);
      staticRenderables.push({type: 'decor', item: decor, zIndex: decor.zIndex || 0});
    });
    staticRenderables.sort((a, b) => a.zIndex - b.zIndex);

    const state = {
      keys: { left: false, right: false, up: false, down: false, dash: false, hop: false, sword: false, run: false },
      isDashing: false,
      dashStartTime: 0,
      lastDash: 0,
      lastHop: 0,
      isFrozen: false,
      facingDirection: 1,
      lastDirection: { x: 0, y: 0 },
      dashVelocity: { x: 0, y: 0 },
      wasInAir: false,
      currentAnimation: 'idle',
      isAttacking: false,
      attackDirection: null,
      attackStartTime: 0,
      dashHopInitiated: false
    };

    const keyMap = {
      ArrowLeft: 'left',
      ArrowRight: 'right',
      ArrowUp: 'up',
      ArrowDown: 'down',
      ShiftLeft: 'dash',
      ShiftRight: 'dash',
      Space: 'hop',
      KeyC: 'sword',
      KeyR: 'run'
    };

    let lastBlockTime = 0;
    const blockCooldown = 50;

    document.addEventListener('keydown', e => {
      if (keyMap[e.code]) state.keys[keyMap[e.code]] = true;
      if (e.code === 'KeyC') placeBlock();
    });

    document.addEventListener('keyup', e => {
      if (keyMap[e.code]) state.keys[keyMap[e.code]] = false;
    });

    function createParticles(x, y, count) {
      for (let i = 0; i < count; i++) {
        const particle = Bodies.circle(x, y, 3, {
          isStatic: false,
          label: 'particle',
          collisionFilter: { mask: 0x0000 },
          render: { fillStyle: '#ffff00' },
          friction: 0,
          frictionStatic: 0,
          frictionAir: 0
        });
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        Body.setVelocity(particle, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
        World.add(engine.world, particle);
        setTimeout(() => World.remove(engine.world, particle), 500);
      }
    }

    function placeBlock() {
      const now = Date.now();
      if (now - lastBlockTime < blockCooldown || state.isAttacking) return;
      lastBlockTime = now;
      let direction;
      if (state.keys.down) {
        direction = 'down';
      } else if (state.lastDirection.y < 0) {
        direction = 'up';
      } else if (state.lastDirection.x > 0) {
        direction = 'right';
      } else if (state.lastDirection.x < 0) {
        direction = 'left';
      } else {
        direction = 'right';
      }
      state.isAttacking = true;
      state.attackDirection = direction;
      state.attackStartTime = now;
      let blockWidth = CONFIG.sword.width;
      let blockHeight = CONFIG.sword.height;
      let blockOffsetX = 0, blockOffsetY = 0;
      const extend = CONFIG.sword.offsetYUp;
      if (direction === 'up' || direction === 'down') {
        blockHeight = player.height + CONFIG.sword.height * extend;
        if (direction === 'up') {
          blockOffsetY = -player.height / 2;
        } else {
          blockOffsetY = player.height / 2;
        }
      } else {
        blockWidth = player.width + CONFIG.sword.width * extend;
        if (direction === 'right') {
          blockOffsetX = player.width / 2;
        } else {
          blockOffsetX = -player.width / 2;
        }
      }
      const attackDir = `attack${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
      const videoTextureId = `sword_${attackDir}`;
      const videoData = videoTextures.get(videoTextureId) || { w: blockWidth, h: blockHeight, duration: 200 };
      const block = Bodies.rectangle(player.position.x + blockOffsetX, player.position.y + blockOffsetY, blockWidth, blockHeight, {
        isSensor: true,
        isStatic: false,
        friction: 0,
        frictionStatic: 0,
        frictionAir: 0,
        label: 'block_hitbox',
        render: { zIndex: CONFIG.zIndex.sword },
        collisionFilter: { mask: 0x0000 },
        swordVideo: true,
        videoTextureId: videoTextureId,
        videoW: blockWidth,
        videoH: blockHeight,
        creationTime: performance.now(),
        duration: videoData.duration || 200,
        offsetX: blockOffsetX,
        offsetY: blockOffsetY,
        isStatic: false
      });
      block.width = blockWidth;
      block.height = blockHeight;
      blockHitboxes.push(block);
      World.add(engine.world, block);
      setTimeout(() => {
        if (block) {
          block.render.visible = false;
          World.remove(engine.world, block);
          const index = blockHitboxes.indexOf(block);
          if (index !== -1) blockHitboxes.splice(index, 1);
        }
        state.isAttacking = false;
        state.attackDirection = null;
        const videoData = videoTextures.get(videoTextureId);
        if (videoData && videoData.video && videoData.isPlaying) {
          videoData.video.pause();
          videoData.video.currentTime = 0;
          videoData.isPlaying = false;
        }
      }, block.duration);
      createParticles(player.position.x + blockOffsetX, player.position.y + blockOffsetY, 5);
    }

    function getVertices(body) {
      if (!body || !body.position || (!body.circleRadius && (!body.width || !body.height))) return [];
      const { position, angle } = body;
      const cos = Math.cos(angle), sin = Math.sin(angle);
      if (body.circleRadius) {
        const sides = 16;
        const vertices = [];
        for (let i = 0; i < sides; i++) {
          const theta = (i / sides) * Math.PI * 2;
          const vx = body.circleRadius * Math.cos(theta);
          const vy = body.circleRadius * Math.sin(theta);
          vertices.push({ x: vx * cos - vy * sin + position.x, y: vx * sin + vy * cos + position.y });
        }
        return vertices;
      } else {
        const hw = body.width / 2, hh = body.height / 2;
        const vertices = [{ x: -hw, y: -hh }, { x: hw, y: -hh }, { x: hw, y: hh }, { x: -hw, y: hh }];
        return vertices.map(v => ({ x: v.x * cos - v.y * sin + position.x, y: v.x * sin + v.y * cos + position.y }));
      }
    }

    function projectVertices(vertices, axis) {
      let min = Infinity, max = -Infinity;
      for (const v of vertices) {
        const dot = v.x * axis.x + v.y * axis.y;
        min = Math.min(min, dot);
        max = Math.max(max, dot);
      }
      return { min, max };
    }

    function getAxes(body) {
      const vertices = getVertices(body);
      if (vertices.length === 0) return [];
      const axes = [];
      for (let i = 0; i < vertices.length; i++) {
        const p1 = vertices[i];
        const p2 = vertices[(i + 1) % vertices.length];
        const edge = { x: p2.x - p1.x, y: p2.y - p1.y };
        const normal = { x: -edge.y, y: edge.x };
        const len = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
        if (len === 0) continue;
        axes.push({ x: normal.x / len, y: normal.y / len });
      }
      return axes;
    }

    function satCollision(bodyA, bodyB) {
      if (!bodyA || !bodyB || !bodyA.position || !bodyB.position) return null;
      const axes = [...getAxes(bodyA), ...getAxes(bodyB)];
      if (axes.length === 0) return null;
      let mtv = null, overlap = Infinity;
      for (const axis of axes) {
        const projA = projectVertices(getVertices(bodyA), axis);
        const projB = projectVertices(getVertices(bodyB), axis);
        if (projA.max < projB.min || projB.max < projA.min) return null;
        const o = Math.min(projA.max - projB.min, projB.max - projA.min);
        if (o < overlap) {
          overlap = o;
          mtv = { axis, overlap };
        }
      }
      if (!mtv || isNaN(mtv.overlap) || isNaN(mtv.axis.x) || isNaN(mtv.axis.y)) return null;
      const aCenter = bodyA.position;
      const bCenter = bodyB.position;
      const centerDiff = { x: aCenter.x - bCenter.x, y: aCenter.y - bCenter.y };
      const dot = centerDiff.x * mtv.axis.x + centerDiff.y * mtv.axis.y;
      if (dot < 0) {
        mtv.axis.x = -mtv.axis.x;
        mtv.axis.y = -mtv.axis.y;
      }
      return mtv;
    }

    function isPlayerOnGround() {
      if (!player || !groundSensor) return { isOnGround: false, onSlope: false, slopeAngle: 0 };
      const sensorHeight = 3;
      const sensorOffsetY = player.height / 2 + 1;
      const angle = player.angle;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const sensorOffsetX = -sensorOffsetY * sin;
      const sensorOffsetYVal = sensorOffsetY * cos;
      Body.setPosition(groundSensor, { x: player.position.x + sensorOffsetX, y: player.position.y + sensorOffsetYVal });
      Body.setAngle(groundSensor, angle);
      Body.setVelocity(groundSensor, { x: 0, y: 0 });
      Body.setAngularVelocity(groundSensor, 0);
      const margin = 100;
      const queryMin = { x: groundSensor.position.x - groundSensor.width / 2 - margin, y: groundSensor.position.y - groundSensor.height / 2 - margin };
      const queryMax = { x: groundSensor.position.x + groundSensor.width / 2 + margin, y: groundSensor.position.y + groundSensor.height / 2 + margin };
      tempNearbyArray.length = 0;
      for (let i = 0; i < collidableBodies.length; i++) {
        const body = collidableBodies[i];
        const b = body.bounds;
        if (!b) continue;
        if (boundsOverlap(queryMin, queryMax, b.min, b.max)) {
          tempNearbyArray.push(body);
        }
      }
      const collisions = Query.collides(groundSensor, tempNearbyArray);
      let isOnGround = false, onSlope = false, slopeAngle = 0;
      let deepestCollision = null;
      let maxDepth = 0;
      for (const collision of collisions) {
        let otherBody = null;
        if (collision.bodyA && (collision.bodyA.label === 'platform' || collision.bodyA.label === 'wall')) {
          otherBody = collision.bodyA;
        } else if (collision.bodyB && (collision.bodyB.label === 'platform' || collision.bodyB.label === 'wall')) {
          otherBody = collision.bodyB;
        }
        if (otherBody && collision.normal && collision.normal.y < -0.5) {
          const depth = collision.depth || 0;
          if (depth > maxDepth) {
            maxDepth = depth;
            deepestCollision = otherBody;
          }
        }
      }
      if (deepestCollision) {
        isOnGround = true;
        if (deepestCollision.label === 'platform') {
          const platform = mapData.platforms.find(p => p.id === deepestCollision.id);
          if (platform && Math.abs(platform.angle) > 5) {
            onSlope = true;
            slopeAngle = Math.round(platform.angle);
          }
        }
      }
      return { isOnGround, onSlope, slopeAngle };
    }

    function updatePlayerAnimation(now, groundInfo) {
      const velY = player ? player.velocity.y : 0;
      let newAnimation = state.currentAnimation;
      if (state.isAttacking && now - state.attackStartTime < (videoTextures.get(`player_attack${state.attackDirection.charAt(0).toUpperCase() + state.attackDirection.slice(1)}`)?.duration || 200)) {
        newAnimation = `attack${state.attackDirection.charAt(0).toUpperCase()+state.attackDirection.slice(1)}`;
      } else {
        if (!groundInfo.isOnGround) {
          if (velY < -1) {
            newAnimation = 'jump';
          } else if (velY > 1) {
            newAnimation = 'fall';
          }
        } else {
          if (state.keys.right && !state.keys.left) {
            newAnimation = 'runRight';
          } else if (state.keys.left && !state.keys.right) {
            newAnimation = 'runLeft';
          } else {
            newAnimation = 'idle';
          }
        }
      }
      if (newAnimation !== state.currentAnimation) {
        const prevVideoData = videoTextures.get(`player_${state.currentAnimation}`);
        if (prevVideoData && prevVideoData.video && prevVideoData.isPlaying) {
          prevVideoData.video.pause();
          prevVideoData.isPlaying = false;
        }
        state.currentAnimation = newAnimation;
        if (player) {
          player.videoTextureId = `player_${newAnimation}`;
        }
        const videoData = videoTextures.get(player ? player.videoTextureId : `player_${newAnimation}`);
        if (videoData && videoData.video && !videoData.isPlaying) {
          videoData.video.play().catch(() => {});
          videoData.isPlaying = true;
        }
      }
    }

    function updateHUD(now) {
      if (!player || now - lastHudUpdate < CONFIG.hudUpdateInterval) return;
      lastHudUpdate = now;
      const updateStatus = (element, name, lastTime, cooldown) => {
        const isReady = now - lastTime >= cooldown;
        element.className = `ability ${isReady?'ready':'cooldown'}`;
        element.querySelector('span').textContent = `${name}: ${isReady?'Ready':'Cooldown'}`;
      };
      updateStatus(DOM.hud.dash, 'Dash (Shift)', state.lastDash, CONFIG.player.dashCooldown);
      updateStatus(DOM.hud.airhop, 'Air Hop (Space)', state.lastHop, CONFIG.player.hopCooldown);
      DOM.hud.block.className = 'ability ready';
      DOM.hud.block.querySelector('span').textContent = `Sword (C): ${Date.now()-lastBlockTime>=blockCooldown?'Ready':'Cooldown'}`;
      const { onSlope, slopeAngle } = lastGroundInfo;
      DOM.hud.slopeInfo.textContent = onSlope ? `Slope: Active (${slopeAngle}¬∞)` : `Slope: None (0¬∞)`;
      DOM.hud.slopeInfo.className = onSlope ? 'slope-info ready' : 'slope-info';
      DOM.hud.playerCoords.textContent = `Coords: (${Math.round(player.position.x)}, ${Math.round(player.position.y)})`;
      const healthPercent = (player.health / 100) * 100;
      DOM.hud.health.textContent = Math.round(player.health);
      DOM.hud.healthFill.style.width = `${healthPercent}%`;
    }

    const resizeHandler = debounce(() => {
      canvasWidth = window.innerWidth;
      canvasHeight = window.innerHeight;
      DOM.canvas.width = canvasWidth;
      DOM.canvas.height = canvasHeight;
      DOM.lightCanvas.width = canvasWidth;
      DOM.lightCanvas.height = canvasHeight;
      render.options.width = canvasWidth;
      render.options.height = canvasHeight;
    }, 100);

    window.addEventListener('resize', resizeHandler);

    Render.lookAt(render, {
      min: { x: mapData.playerStart.x - canvasWidth / 2, y: mapData.playerStart.y - canvasHeight / 2 },
      max: { x: mapData.playerStart.x + canvasWidth / 2, y: mapData.playerStart.y + canvasHeight / 2 }
    });

    let lastTime = performance.now();
    let frames = 0;
    let fps = 0;

    function updateFPS() {
      const now = performance.now();
      frames++;
      if (now - lastTime >= 1000) {
        fps = frames;
        frames = 0;
        lastTime = now;
        document.getElementById('fpsMeter').textContent = 'FPS: ' + fps;
      }
      requestAnimationFrame(updateFPS);
    }

    updateFPS();

    function endDash() {
      if (state.isDashing) {
        state.isDashing = false;
        state.lastDash = Date.now();
        const postDashSpeed = CONFIG.player.speed;
        if (state.dashHopInitiated) {
          const dashDirection = state.dashVelocity.x > 0 ? 1 : -1;
          Body.setVelocity(player, { x: dashDirection * postDashSpeed, y: player.velocity.y });
        } else {
          const magnitude = Math.sqrt(state.dashVelocity.x ** 2 + state.dashVelocity.y ** 2);
          const scaledX = magnitude > 0 ? state.dashVelocity.x * (postDashSpeed / magnitude) : 0;
          const scaledY = magnitude > 0 ? state.dashVelocity.y * (postDashSpeed / magnitude) : 0;
          Body.setVelocity(player, { x: scaledX, y: scaledY });
        }
        player.force = { x: 0, y: 0 };
        state.dashHopInitiated = false;
      }
    }

    let lastGroundState = { isOnGround: false, onSlope: false, slopeAngle: 0 };
    let slopeFrameCount = 0;
    const hysteresisFrames = 3;
    let previousPlayerState = {
      position: { x: mapData.playerStart.x, y: mapData.playerStart.y },
      velocity: { x: 0, y: 0 },
      angle: 0
    };

    Events.on(engine, 'beforeUpdate', () => {
      if (!player) return;
      previousPlayerState = {
        position: { ...player.position },
        velocity: { ...player.velocity },
        angle: player.angle
      };
      const now = Date.now();
      const groundInfo = isPlayerOnGround();
      updatePlayerAnimation(now, groundInfo);
      if (state.keys.right && !state.keys.left) {
        state.facingDirection = 1;
        state.lastDirection = { x: 1, y: 0 };
      } else if (state.keys.left && !state.keys.right) {
        state.facingDirection = -1;
        state.lastDirection = { x: -1, y: 0 };
      } else if (state.keys.up && !state.keys.right && !state.keys.left) {
        state.lastDirection = { x: 0, y: -1 };
      }
      const justLanded = !lastGroundState.isOnGround && groundInfo.isOnGround;
      const maxTilt = CONFIG.rotationLimit * Math.PI / 180;
      if (groundInfo.onSlope) {
        slopeFrameCount = Math.min(slopeFrameCount + 1, hysteresisFrames);
      } else {
        slopeFrameCount = Math.max(slopeFrameCount - 1, 0);
      }
      groundInfo.onSlope = slopeFrameCount >= hysteresisFrames;
      if (!groundInfo.onSlope) groundInfo.slopeAngle = 0;
      let targetAngle = groundInfo.onSlope ? groundInfo.slopeAngle * Math.PI / 180 : 0;
      targetAngle = Math.max(-maxTilt * 10, Math.min(targetAngle, maxTilt * 10));
      let lerpSpeed = 0.1;
      if (justLanded && groundInfo.onSlope) {
        lerpSpeed = 0.3;
      }
      const newPlayerAngle = player.angle + (targetAngle - player.angle) * lerpSpeed;
      Body.setAngle(player, newPlayerAngle);
      const sensorOffsetYVal = player.height / 2 + 1;
      const angle = player.angle;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const groundSensorOffsetX = -sensorOffsetYVal * sin;
      const groundSensorOffsetY = sensorOffsetYVal * cos;
      Body.setPosition(groundSensor, { x: player.position.x + groundSensorOffsetX, y: player.position.y + groundSensorOffsetY });
      Body.setAngle(groundSensor, angle);
      Body.setVelocity(groundSensor, { x: 0, y: 0 });
      Body.setAngularVelocity(groundSensor, 0);
      lastGroundState = groundInfo;
      lastGroundInfo = groundInfo;
      state.wasInAir = !groundInfo.isOnGround;
      if (state.isDashing && now - state.dashStartTime < CONFIG.player.dashDuration) {
        if (state.dashHopInitiated) {
          Body.setVelocity(player, { x: state.dashVelocity.x, y: player.velocity.y });
          player.force = { x: 0, y: 0 };
        } else {
          const g = engine.world.gravity;
          player.force.y = -(g.y * g.scale * player.mass);
          player.force.x = 0;
        }
      } else if (state.isDashing) {
        endDash();
      }
      if (state.keys.dash && !state.isDashing && now - state.lastDash >= CONFIG.player.dashCooldown) {
        const dir = state.keys.right ? 1 : state.keys.left ? -1 : state.facingDirection;
        let dashVx = dir * CONFIG.player.dashSpeed;
        let dashVy = 0;
        if (groundInfo.isOnGround && groundInfo.onSlope) {
          const theta = groundInfo.slopeAngle * Math.PI / 180;
          dashVx = dir * CONFIG.player.dashSpeed * Math.cos(theta);
          dashVy = dir * CONFIG.player.dashSpeed * Math.sin(theta);
        }
        state.dashVelocity = { x: dashVx, y: dashVy };
        Body.setVelocity(player, state.dashVelocity);
        state.isDashing = true;
        state.dashStartTime = now;
        state.dashHopInitiated = false;
        player.frictionAir = 0;
        setTimeout(endDash, CONFIG.player.dashDuration);
      }
      if (!state.isDashing) {
        const input = (state.keys.right ? 1 : 0) - (state.keys.left ? 1 : 0);
        const speed = state.keys.run ? CONFIG.player.runSpeed : CONFIG.player.speed;
        let targetVelX = input * speed;
        let targetVelY = 0;
        if (groundInfo.isOnGround && groundInfo.onSlope) {
          const theta = groundInfo.slopeAngle * Math.PI / 180;
          targetVelX = input * speed * Math.cos(theta);
          targetVelY = input * speed * Math.sin(theta);
        }
        if (groundInfo.isOnGround) {
          Body.setVelocity(player, { x: targetVelX, y: targetVelY });
        } else {
          Body.setVelocity(player, { x: player.velocity.x + (targetVelX - player.velocity.x) * 0.1, y: player.velocity.y });
        }
        if (state.keys.right) state.facingDirection = 1;
        if (state.keys.left) state.facingDirection = -1;
      }
      if (state.keys.hop && !groundInfo.isOnGround && now - state.lastHop >= CONFIG.player.hopCooldown) {
        const hopVelocity = state.isDashing ? CONFIG.player.jumpVelocity : CONFIG.player.airHopVelocity;
        Body.setVelocity(player, { x: player.velocity.x, y: hopVelocity });
        state.lastHop = now;
        if (state.isDashing) {
          state.dashHopInitiated = true;
        }
      }
      if (state.keys.up && groundInfo.isOnGround) {
        Body.setVelocity(player, { x: player.velocity.x, y: CONFIG.player.jumpVelocity });
      }
      if (!state.isDashing && !groundInfo.isOnGround) {
        const maxFallSpeed = CONFIG.maxGravityAcceleration;
        if (player.velocity.y > maxFallSpeed) {
          Body.setVelocity(player, { x: player.velocity.x, y: maxFallSpeed });
        }
      }
      let wallCollision = false;
      const playerMargin = 20;
      const pMin = { x: player.position.x - player.width / 2 - playerMargin, y: player.position.y - player.height / 2 - playerMargin };
      const pMax = { x: player.position.x + player.width / 2 + playerMargin, y: player.position.y + player.height / 2 + playerMargin };
      tempNearbyArray.length = 0;
      for (let i = 0; i < obstacles.length; i++) {
        const body = obstacles[i];
        const b = body.bounds;
        if (!b) continue;
        if (boundsOverlap(pMin, pMax, b.min, b.max)) {
          tempNearbyArray.push(body);
        }
      }
      for (let j = 0; j < tempNearbyArray.length; j++) {
        const obstacle = tempNearbyArray[j];
        if (!obstacle.position || (!obstacle.circleRadius && (!obstacle.width || !obstacle.height))) continue;
        const mtv = satCollision(player, obstacle);
        if (mtv && mtv.overlap > 0.1) {
          const pos = player.position;
          Body.setPosition(player, { x: pos.x + mtv.axis.x * mtv.overlap * 1.01, y: pos.y + mtv.axis.y * mtv.overlap * 1.01 });
          const vel = player.velocity;
          const dot = vel.x * mtv.axis.x + vel.y * mtv.axis.y;
          if (dot < 0) {
            const normalVel = { x: dot * mtv.axis.x, y: dot * mtv.axis.y };
            let newVelX = vel.x - normalVel.x;
            let newVelY = vel.y - normalVel.y;
            if (groundInfo.isOnGround && Math.abs(mtv.axis.x) > 0.7) {
              newVelX = vel.x;
            }
            if (state.isDashing && Math.abs(mtv.axis.x) > 0.7) {
              endDash();
              newVelX = Math.abs(mtv.axis.x) > 0.9 ? 0 : newVelX;
              newVelY = Math.abs(mtv.axis.y) > 0.9 ? 0 : newVelY;
            }
            Body.setVelocity(player, { x: newVelX, y: newVelY });
          }
          wallCollision = true;
        }
      }
      camTarget.x = player.position.x;
      camTarget.y = player.position.y;
      camPos.x += (camTarget.x - camPos.x) * CONFIG.camera.smoothFactor;
      camPos.y += (camTarget.y - camPos.y) * CONFIG.camera.smoothFactor;
      decorObjects.forEach(decor => {
        const staticX = decor.originalPos.x;
        const staticY = decor.originalPos.y;
        const halfW = decor.w / 2;
        const halfH = decor.h / 2;
        const staticMinX = staticX - halfW;
        const staticMaxX = staticX + halfW;
        const staticMinY = staticY - halfH;
        const staticMaxY = staticY + halfH;
        const camX = camPos.x - canvasWidth / 2;
        const camY = camPos.y - canvasHeight / 2;
        const viewRight = camX + canvasWidth;
        const viewBottom = camY + canvasHeight;
        const isInView = !(staticMaxX < camX || staticMinX > viewRight || staticMaxY < camY || staticMinY > viewBottom);
        if (isInView && !decor.enteredView) {
          decor.enteredView = true;
          decor.baseCamPos = { x: camPos.x, y: camPos.y };
        }
        let offsetX = 0, offsetY = 0;
        if (decor.enteredView) {
          const deltaCamX = camPos.x - decor.baseCamPos.x;
          const deltaCamY = camPos.y - decor.baseCamPos.y;
          const speed = decor.parallaxSpeed;
          offsetX = deltaCamX * speed;
          offsetY = deltaCamY * speed;
        }
        decor.currentPos = { x: decor.originalPos.x + offsetX, y: decor.originalPos.y + offsetY };
      });
      const camX = camPos.x - canvasWidth / 2;
      const camY = camPos.y - canvasHeight / 2;
      render.bounds.min.x = camX;
      render.bounds.min.y = camY;
      render.bounds.max.x = camX + canvasWidth;
      render.bounds.max.y = camY + canvasHeight;
      screenPlayerPos.x = player.position.x - camX;
      screenPlayerPos.y = player.position.y - camY;
      const camDist = Math.sqrt((camPos.x - lastCamPosForCull.x)**2 + (camPos.y - lastCamPosForCull.y)**2);
      if (camDist > CONFIG.camera.cullThreshold) {
        lastCamPosForCull = { ...camPos };
        const physBounds = {
          min: { x: camX - CONFIG.culling.physicsMargin, y: camY - CONFIG.culling.physicsMargin },
          max: { x: camX + canvasWidth + CONFIG.culling.physicsMargin, y: camY + canvasHeight + CONFIG.culling.physicsMargin }
        };
        for (let k = 0; k < staticBodies.length; k++) {
          const body = staticBodies[k];
          if (!body) continue;
          const b = body.bounds;
          if (!b) continue;
          const inPhysView = boundsOverlap(physBounds.min, physBounds.max, b.min, b.max);
          if (inPhysView && !body.inWorld) {
            World.add(engine.world, body);
            body.inWorld = true;
          } else if (!inPhysView && body.inWorld) {
            World.remove(engine.world, body);
            body.inWorld = false;
            if (body.platformVideo) {
              const videoData = videoTextures.get(body.videoTextureId);
              updateVideoPlay(videoData, false);
            }
          }
        }
      }
      if (isNaN(player.position.x) || isNaN(player.position.y) || isNaN(player.velocity.x) || isNaN(player.velocity.y) || isNaN(player.angle)) {
        Body.setPosition(player, previousPlayerState.position);
        Body.setVelocity(player, previousPlayerState.velocity);
        Body.setAngle(player, previousPlayerState.angle);
      }
      updateHUD(now);
    });

    Events.on(engine, 'afterUpdate', () => {
      blockHitboxes.forEach(block => {
        if (!block || !player) return;
        const playerAngle = player.angle;
        const cos = Math.cos(playerAngle);
        const sin = Math.sin(playerAngle);
        const rotatedOffsetX = block.offsetX * cos - block.offsetY * sin;
        const rotatedOffsetY = block.offsetX * sin + block.offsetY * cos;
        Body.setPosition(block, { x: player.position.x + rotatedOffsetX, y: player.position.y + rotatedOffsetY });
        Body.setAngle(block, playerAngle);
        Body.setVelocity(block, { x: 0, y: 0 });
        Body.setAngularVelocity(block, 0);
      });
    });

    function drawLight() {
      if (!CONFIG.light.enabled || !player) return;
      const lightCtx = DOM.lightCanvas.getContext('2d', { willReadFrequently: false });
      lightCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      const gradient = lightCtx.createRadialGradient(
        screenPlayerPos.x, screenPlayerPos.y, 0,
        screenPlayerPos.x, screenPlayerPos.y, CONFIG.light.radius
      );
      CONFIG.light.gradientStops.forEach(stop => {
        gradient.addColorStop(stop.offset, stop.color);
      });
      lightCtx.fillStyle = gradient;
      lightCtx.fillRect(0, 0, canvasWidth, canvasHeight);
      requestAnimationFrame(drawLight);
    }

    drawLight();
  }

  preloadImages();
  preloadAnimations();

  soundtrack = new Audio('https://github.com/HyperRushNet/game/releases/download/soundtrack/soundtrack.mp3');
  soundtrack.loop = true;
  soundtrack.volume = 1;
  soundtrack.preload = "auto";
  soundtrack.addEventListener('canplaythrough', () => {
    loadedAssets++;
    updateLoading();
  });
  soundtrack.onerror = () => {
    loadedAssets++;
    updateLoading();
  };
  soundtrack.load();

  DOM.startButton.addEventListener('click', () => {
    DOM.loadingScreen.style.display = 'none';
    startGame();
  });
</script>
</body>
</html>
<!-- Game code END -->
